// Generated by CoffeeScript 1.6.2
(function() {
  var ArgumentError, ArityError, Compiler, Env, Error, TypeError, beautify, compile, fs, il, _, _ref, _ref1, _ref2,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  fs = require("fs");

  beautify = require('js-beautify').js_beautify;

  il = require("./interlang");

  exports.solve = function(exp, path) {
    path = compile(exp, path);
    delete require.cache[require.resolve(path)];
    return require(path).main();
  };

  compile = function(exp, path) {
    var code, compiler, fd;

    compiler = new Compiler();
    code = "solve = require('f:/daonode/lib/compiler/core.js').solve;\n" + ("exports.main = " + (compiler.compile(exp))) + "\n//exports.main();";
    code = beautify(code, {
      indent_size: 2
    });
    path = path || "f:/daonode/lib/compiler/test/compiled.js";
    fd = fs.openSync(path, 'w');
    fs.writeSync(fd, code);
    fs.closeSync(fd);
    return path;
  };

  exports.Compiler = Compiler = (function() {
    var name, vop;

    function Compiler() {
      this.nameToVarIndex = {};
      this.exits = {};
      this.continues = {};
      this.protect = function(cont) {
        return cont;
      };
    }

    Compiler.prototype.compile = function(exp) {
      var f, fromCont, v;

      v = il.vari('v');
      fromCont = this.cont(exp, il.clamda(v, v));
      f = il.clamda(v, fromCont);
      f = f.optimize(new Env(), this);
      f = f.jsify();
      return f.toCode(this);
    };

    Compiler.prototype.cont = function(exp, cont) {
      var head, length, _ref;

      if (_.isString(exp)) {
        return cont.call(il.vari(exp));
      }
      if (!_.isArray(exp)) {
        return cont.call(exp);
      }
      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      }
      head = exp[0];
      if (!_.isString(head)) {
        return cont.call(exp);
      }
      if (!this.specials.hasOwnProperty(head)) {
        return cont.call(exp);
      }
      return (_ref = this.specials[head]).call.apply(_ref, [this, cont].concat(__slice.call(exp.slice(1))));
    };

    Compiler.prototype.leftValueCont = function(cont, op, item, exp) {
      var cont1, head, i, index, length, obj, object, v;

      if (_.isString(item)) {
        v = il.vari('v');
        if (op === 'assign') {
          return this.cont(exp, il.clamda(v, il.assign(il.vari(item), v), cont.call(v)));
        } else {
          return cont.call(il[op].call(il.vari(item)));
        }
      }
      if (!_.isArray(item)) {
        throw "Left Value should be an sexpression.";
      }
      length = item.length;
      if (length === 0) {
        throw "Left Value side should not be empty list.";
      }
      head = item[0];
      if (!_.isString(head)) {
        throw "Keyword should be a string.";
      }
      if (head === "index") {
        object = item[1];
        index = item[2];
        obj = il.vari('obj');
        i = il.vari('i');
        v = il.vari('v');
        if (op === 'assign') {
          cont1 = this.cont(exp, il.clamda(v, il.assign(il.index.call(obj, i), cont.call(v))));
        } else {
          cont1 = cont.call(il[op].call(il.index.call(obj, i)));
        }
        return this.cont(object, il.clamda(obj, this.cont(index, il.clamda(i, cont1))));
      } else {
        throw "Left Value side should be assignable expression.";
      }
    };

    Compiler.prototype.specials = {
      "quote": function(cont, exp) {
        return cont.call(exp);
      },
      "eval": function(cont, exp, path) {
        var p, v;

        v = il.vari('v');
        p = il.vari('path');
        return this.cont(exp, il.clamda(v, this.cont(path, il.clamda(p, cont.call(il.evalexpr.call(v, p))))));
      },
      'string': function(cont, exp) {
        return cont.call(exp);
      },
      "begin": function() {
        var cont, exps;

        cont = arguments[0], exps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return this.expsCont(exps, cont);
      },
      "assign": function(cont, left, exp) {
        return this.leftValueCont(cont, "assign", left, exp);
      },
      'inc': function(cont, item) {
        return this.leftValueCont(cont, "inc", item);
      },
      'suffixinc': function(cont, item) {
        return this.leftValueCont(cont, "suffixinc", item);
      },
      'dec': function(item) {
        return this.leftValueCont(cont, "dec", item);
      },
      'suffixdec': function(item) {
        return this.leftValueCont(cont, "suffixdec", item);
      },
      "if": function(cont, test, then_, else_) {
        var v;

        v = il.vari('v');
        return this.cont(test, il.clamda(v, il.if_(v, this.cont(then_, cont), this.cont(else_, cont))));
      },
      "jsfun": function(cont, func) {
        var v;

        v = il.vari('v');
        return this.cont(func, il.clamda(v, cont.call(il.jsfun(v))));
      },
      "lambda": function() {
        var body, cont, k, p, params;

        cont = arguments[0], params = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        k = il.vari('cont');
        params = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            p = params[_i];
            _results.push(il.vari(p));
          }
          return _results;
        })();
        return cont.call(il.lamda([k].concat(params), this.expsCont(body, k)));
      },
      "macro": function() {
        var body, cont, e, k, p, params, params1;

        cont = arguments[0], params = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        k = il.vari('cont');
        params1 = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            p = params[_i];
            _results.push(il.vari(p));
          }
          return _results;
        })();
        body = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = body.length; _i < _len; _i++) {
            e = body[_i];
            _results.push(this.substMacroArgs(e, params));
          }
          return _results;
        }).call(this);
        return cont.call(il.lamda([k].concat(params1), this.expsCont(body, k)));
      },
      "evalarg": function(cont, name) {
        return cont.call(il.vari(name).call(cont));
      },
      "funcall": function() {
        var args, caller, compiler, cont, f, i, length, params, _i, _ref;

        cont = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        compiler = this;
        f = il.vari('f');
        length = args.length;
        params = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(il.vari('a' + i));
          }
          return _results;
        })();
        cont = f.apply([cont].concat(params));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          cont = (function(i, cont) {
            return compiler.cont(args[i], il.clamda(params[i], cont));
          })(i, cont);
        }
        return this.cont(caller, il.clamda(f, cont));
      },
      "macall": function() {
        var args, caller, compiler, cont, f, i, length, params, v, _i, _ref;

        cont = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        compiler = this;
        f = il.vari('f');
        v = il.vari('v');
        length = args.length;
        params = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(il.vari('a' + i));
          }
          return _results;
        })();
        cont = f.apply([cont].concat(params));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          cont = (function(i, cont) {
            return il.clamda(params[i], cont).call(il.lamda([], compiler.cont(args[i], il.clamda(v, v))));
          })(i, cont);
        }
        return this.cont(caller, il.clamda(f, cont));
      },
      "quasiquote": function(cont, exp) {
        return this.quasiquote(exp, cont);
      },
      "unquote": function(cont, exp) {
        throw "unquote: too many unquote and unquoteSlice";
      },
      "unquote-slice": function(cont, exp) {
        throw "unquoteSlice: too many unquote and unquoteSlice";
      },
      'block': function() {
        var body, cont, continues, defaultContinues, defaultExits, exits, f, fun, label, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

        cont = arguments[0], label = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        label = label[1];
        if (!_.isString(label)) {
          label = '';
          body = [label].concat(body);
        }
        exits = (_ref = (_base = this.exits)[label]) != null ? _ref : _base[label] = [];
        exits.push(cont);
        defaultExits = (_ref1 = (_base1 = this.exits)['']) != null ? _ref1 : _base1[''] = [];
        defaultExits.push(cont);
        continues = (_ref2 = (_base2 = this.continues)[label]) != null ? _ref2 : _base2[label] = [];
        f = il.vari('block' + label);
        fun = il.clamda(il.vari('v'), null);
        continues.push(f);
        defaultContinues = (_ref3 = (_base3 = this.continues)['']) != null ? _ref3 : _base3[''] = [];
        defaultContinues.push(f);
        fun.body = this.expsCont(body, cont);
        exits.pop();
        if (exits.length === 0) {
          delete this.exits[label];
        }
        continues.pop();
        if (continues.length === 0) {
          delete this.continues[label];
        }
        defaultExits.pop();
        defaultContinues.pop();
        return il.begin(il.assign(f, fun), f.apply([null]));
      },
      'break': function(cont, label, value) {
        var exitCont, exits;

        label = label[1];
        exits = this.exits[label];
        if (!exits || exits === []) {
          throw Error(label);
        }
        exitCont = exits[exits.length - 1];
        return this.cont(value, this.protect(exitCont));
      },
      'continue': function(cont, label) {
        var continueCont, continues;

        label = label[1];
        continues = this.continues[label];
        if (!continues || continues === []) {
          throw Error(label);
        }
        continueCont = continues[continues.length - 1];
        return this.protect(continueCont).call(null);
      }
    };

    Compiler = Compiler;

    for (name in il) {
      vop = il[name];
      if (vop instanceof il.VirtualOperation) {
        (function(name, vop) {
          return Compiler.prototype.specials['vop_' + name] = function() {
            var args, compiler, cont, i, length, params, _i, _ref;

            cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            compiler = this;
            length = args.length;
            params = (function() {
              var _i, _results;

              _results = [];
              for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
                _results.push(il.vari('a' + i));
              }
              return _results;
            })();
            cont = cont.call(vop.apply(params));
            for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
              cont = (function(i, cont) {
                return compiler.cont(args[i], il.clamda(params[i], cont));
              })(i, cont);
            }
            return cont;
          };
        })(name, vop);
      }
    }

    Compiler.prototype.optimize = function(exp, env) {
      var expOptimize;

      expOptimize = exp != null ? exp.optimize : void 0;
      if (expOptimize) {
        return expOptimize.call(exp, env, this);
      } else {
        return exp;
      }
    };

    Compiler.prototype.toCode = function(exp) {
      var exptoCode;

      exptoCode = exp != null ? exp.toCode : void 0;
      if (exptoCode) {
        return exptoCode.call(exp, this);
      } else {
        if (exp === void 0) {
          return 'undefined';
        } else if (exp === null) {
          return 'null';
        } else if (_.isNumber(exp)) {
          return exp.toString();
        } else if (_.isString(exp)) {
          return JSON.stringify(exp);
        } else if (exp === true) {
          return "true";
        } else if (exp === false) {
          return "false";
        } else {
          return JSON.stringify(exp);
        }
      }
    };

    Compiler.prototype.expsCont = function(exps, cont) {
      var length, v;

      length = exps.length;
      if (length === 0) {
        throw exports.TypeError(exps);
      } else if (length === 1) {
        return this.cont(exps[0], cont);
      } else {
        v = il.vari('v');
        return this.cont(exps[0], il.clamda(v, this.expsCont(exps.slice(1), cont)));
      }
    };

    Compiler.prototype.quasiquote = function(exp, cont) {
      var e, head, i, length, quasilist, v, _i, _ref;

      if (!_.isArray(exp)) {
        return cont.call(exp);
      }
      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      }
      head = exp[0];
      if (!_.isString(head)) {
        return cont.call(exp);
      }
      if (!this.specials.hasOwnProperty(head)) {
        return cont.call(exp);
      }
      head = exp[0];
      if (head === "unquote") {
        return this.cont(exp[1], cont);
      } else if (head === "unquote-slice") {
        return this.cont(exp[1], cont);
      } else if (head === "quote") {
        return cont.call(exp);
      } else if (head === "string") {
        return cont.call(exp);
      } else {
        quasilist = il.vari('quasilist');
        v = il.vari('v');
        cont = cont.call(quasilist);
        for (i = _i = _ref = exp.length - 1; _i >= 1; i = _i += -1) {
          e = exp[i];
          if (_.isArray(e) && e.length > 0 && e[0] === "unquote-slice") {
            cont = this.quasiquote(e, il.clamda(v, il.assign(quasilist, il.concat.call(quasilist, v)), cont));
          } else {
            cont = this.quasiquote(e, il.clamda(v, il.push.call(quasilist, v), cont));
          }
        }
        return il.begin(il.assign(quasilist, il.list.call(head)), cont);
      }
    };

    Compiler.prototype.substMacroArgs = function(exp, params) {
      var e, head, length;

      if (__indexOf.call(params, exp) >= 0) {
        return ['evalarg', exp];
      }
      if (!_.isArray(exp)) {
        return exp;
      }
      length = exp.length;
      if (length === 0) {
        return exp;
      }
      head = exp[0];
      if (!_.isString(head)) {
        return exp;
      }
      if (!this.specials.hasOwnProperty(head)) {
        return exp;
      }
      if (head === 'lambda' || head === 'macro') {
        params = ((function() {
          var _i, _len, _results;

          if (__indexOf.call(exp[1], e) < 0) {
            _results = [];
            for (_i = 0, _len = params.length; _i < _len; _i++) {
              e = params[_i];
              _results.push(e);
            }
            return _results;
          }
        })());
        return exp.slice(0, 2).concat((function() {
          var _i, _len, _ref, _results;

          _ref = exp.slice(2);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            _results.push(this.substMacroArgs(e, params));
          }
          return _results;
        }).call(this));
      } else if (head === 'quote') {
        return exp;
      } else if (head === 'string') {
        return exp;
      } else if (head === 'quasiquote') {
        return exp;
      } else {
        return [exp[0]].concat((function() {
          var _i, _len, _ref, _results;

          _ref = exp.slice(1);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            _results.push(this.substMacroArgs(e, params));
          }
          return _results;
        }).call(this));
      }
    };

    return Compiler;

  })();

  Env = (function() {
    function Env(outer, data) {
      this.outer = outer;
      this.data = data != null ? data : {};
    }

    Env.prototype.extend = function(vari, value) {
      var data;

      data = {};
      data[vari.name] = value;
      return new Env(this, data);
    };

    Env.prototype.lookup = function(vari) {
      var data, name, outer;

      data = this.data;
      name = vari.name;
      if (data.hasOwnProperty(name)) {
        return data[name];
      } else {
        outer = this.outer;
        if (outer) {
          return outer.lookup(vari);
        } else {
          return vari;
        }
      }
    };

    return Env;

  })();

  exports.Error = Error = (function() {
    function Error(exp, message, stack) {
      this.exp = exp;
      this.message = message != null ? message : '';
      this.stack = stack != null ? stack : this;
    }

    Error.prototype.toString = function() {
      return "" + this.constructor.name + ": " + this.exp + " >>> " + this.message;
    };

    return Error;

  })();

  exports.TypeError = TypeError = (function(_super) {
    __extends(TypeError, _super);

    function TypeError() {
      _ref = TypeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TypeError;

  })(Error);

  exports.ArgumentError = ArgumentError = (function(_super) {
    __extends(ArgumentError, _super);

    function ArgumentError() {
      _ref1 = ArgumentError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ArgumentError;

  })(Error);

  exports.ArityError = ArityError = (function(_super) {
    __extends(ArityError, _super);

    function ArityError() {
      _ref2 = ArityError.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return ArityError;

  })(Error);

}).call(this);

/*
//@ sourceMappingURL=core.map
*/
