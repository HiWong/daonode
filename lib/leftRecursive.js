// Generated by CoffeeScript 1.6.2
(function() {
  var cursor, hasOwnProperty, memo, originalRules, recursive, rules, symbolDescedentsMap, text, textLength, _memo, _memo2,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  rules = void 0;

  symbolDescedentsMap = {};

  originalRules = {};

  _memo = {};

  text = '';

  textLength = 0;

  cursor = 0;

  _memo = {};

  _memo2 = {};

  hasOwnProperty = Object.hasOwnProperty;

  exports.parse = function(data, grammar, start) {
    start = start || grammar.rootSymbol;
    text = data;
    textLength = text.length;
    cursor = 0;
    _memo = {};
    rules = grammar;
    return grammar[start](0);
  };

  exports.addParentChildrens = function() {
    var children, grammar, list, map, name, parent, parentChildren, parentChildrens, _i, _j, _len, _len1, _ref, _ref1;

    grammar = arguments[0], parentChildrens = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    map = (_ref = grammar.parentToChildren) != null ? _ref : grammar.parentToChildren = {};
    for (_i = 0, _len = parentChildrens.length; _i < _len; _i++) {
      parentChildren = parentChildrens[_i];
      for (parent in parentChildren) {
        children = parentChildren[parent];
        list = (_ref1 = map[parent]) != null ? _ref1 : map[parent] = [];
        for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
          name = children[_j];
          if (__indexOf.call(list, name) < 0) {
            list.push(name);
          }
        }
      }
    }
    return null;
  };

  exports.addRecCircles = function() {
    var circle, grammar, i, j, length, list, map, name, parent, recursiveCircles, _i, _len, _ref, _ref1;

    grammar = arguments[0], recursiveCircles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    map = (_ref = grammar.parentToChildren) != null ? _ref : grammar.parentToChildren = {};
    for (_i = 0, _len = recursiveCircles.length; _i < _len; _i++) {
      circle = recursiveCircles[_i];
      i = 0;
      length = circle.length;
      while (i < length) {
        if (i === length - 1) {
          j = 0;
        } else {
          j = i + 1;
        }
        name = circle[i];
        parent = circle[j];
        list = (_ref1 = map[parent]) != null ? _ref1 : map[parent] = [];
        if (__indexOf.call(list, name) < 0) {
          list.push(name);
        }
        i++;
      }
    }
    return null;
  };

  exports.computeLeftRecursives = function(grammar) {
    var addDescendents, descendents, meetTable, parentToChildren, symbol;

    parentToChildren = grammar.parentToChildren;
    addDescendents = function(symbol, meetTable, descedents) {
      var child, children, _i, _len, _results;

      children = parentToChildren[symbol];
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        if (__indexOf.call(descedents, child) < 0) {
          descedents.push(child);
        }
        if (!meetTable[child]) {
          _results.push(addDescendents(child, meetTable, descedents));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    symbolDescedentsMap = {};
    for (symbol in parentToChildren) {
      meetTable = {};
      meetTable[symbol] = true;
      descendents = symbolDescedentsMap[symbol] = [];
      addDescendents(symbol, meetTable, descendents);
      if (__indexOf.call(descendents, symbol) >= 0) {
        originalRules[symbol] = grammar[symbol];
        grammar[symbol] = recursive(symbol);
      }
    }
    return symbolDescedentsMap;
  };

  exports.recursive = recursive = function(symbol) {
    var originalRule;

    originalRule = originalRules[symbol];
    return function(start) {
      var child, hash, m, result, _i, _j, _len, _len1, _ref, _ref1, _ref2;

      _ref = symbolDescedentsMap[symbol];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child !== symbol) {
          rules[child] = originalRules[child];
        }
      }
      hash = symbol + start;
      m = (_ref1 = _memo[hash]) != null ? _ref1 : _memo[hash] = [void 0, -1];
      if (m[1] >= 0) {
        cursor = m[1];
        return m[0];
      }
      while (1) {
        result = originalRule(start);
        if (m[1] < 0) {
          m[0] = result;
          if (result) {
            m[1] = cursor;
          } else {
            m[1] = start;
          }
          continue;
        } else {
          if (m[1] === cursor) {
            m[0] = result;
            return result;
          } else if (cursor < m[1]) {
            m[0] = result;
            cursor = m[1];
            return result;
          } else {
            m[0] = result;
            m[1] = cursor;
          }
        }
      }
      _ref2 = symbolDescedentsMap[symbol];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        child = _ref2[_j];
        if (child !== symbol) {
          rules[child] = recursive(child);
        }
      }
      return result;
    };
  };

  exports.setRules = function(rules1) {
    return rules = rules1;
  };

  exports.memo = memo = function(symbol) {
    return function(start) {
      var hash, m;

      hash = symbol + start;
      m = _memo[hash];
      if (m) {
        return m[0];
      }
    };
  };

  exports.andp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      cursor = start;
      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (!(result = exp(cursor))) {
          return;
        }
      }
      return result;
    };
  };

  exports.orp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (result = exp(start)) {
          return result;
        }
      }
    };
  };

  exports.notp = function(exp) {
    return function(start) {
      if (exp(start)) {

      } else {
        return true;
      }
    };
  };

  exports.char = function(c) {
    return function(start) {
      if (text[start] === c) {
        cursor = start + 1;
        return c;
      }
    };
  };

  exports.literal = function(string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  exports.spaces = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  exports.spaces1 = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return cursor = cursor;
      return len;
    }
  };

  exports.wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    return function(start) {
      var result;

      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  exports.cur = function() {
    return cursor;
  };

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
