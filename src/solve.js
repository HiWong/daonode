// Generated by CoffeeScript 1.6.2
(function() {
  var cons, dao, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  dao = exports;

  dao.NoSolution = (function() {
    function NoSolution(exp) {
      this.exp = exp;
    }

    NoSolution.prototype.toString = function() {
      return this.exp.toString();
    };

    return NoSolution;

  })();

  dao.Solutions = (function() {
    function Solutions(exp, solutions) {
      this.exp = exp;
      this.solutions = solutions;
    }

    Solutions.prototype.next = function() {
      return this.solutions.next();
    };

    return Solutions;

  })();

  dao.Bindings = (function() {
    function Bindings() {}

    Bindings.prototype.getitem = function(vari) {
      return this[vari] || vari;
    };

    Bindings.prototype.setitem = function(vari, value) {
      return this[vari] = value;
    };

    Bindings.prototype.detitem = function(vari) {
      return delete this[vari];
    };

    Bindings.prototype.copy = function() {
      return new dao.Bindings(_.clone(this));
    };

    Bindings.prototype.deref = function(exp) {
      if (exp.deref != null) {
        return exp.deref(this);
      } else {
        return exp;
      }
    };

    Bindings.prototype.get_value = function(exp, memo, bindings) {
      if (exp.getvalue != null) {
        return exp.deref(this, memo, bindings);
      } else {
        return exp;
      }
    };

    return Bindings;

  })();

  dao.LogicVar = (function() {
    function LogicVar(name) {
      this.name = name;
    }

    LogicVar.prototype.deref = function(bindings) {
      var next;

      while (1) {
        next = bindings.getitem(this);
        if (!isinstance(next, LogicVar) || next === this) {
          return next;
        } else {
          next;
        }
      }
    };

    LogicVar.prototype.getvalue = function(memo, bindings) {
      var result;

      if (memo.hasOwnProperty(this)) {
        return memo[this];
      } else {
        result = this.deref(bindings);
        if (isinstance(result, LogicVar)) {
          memo[this] = result;
          result;
        }
        if (result.getvalue != null) {
          return result.getvalue(memo, bindings);
        } else {
          memo[this] = result;
          return result;
        }
      }
    };

    LogicVar.prototype.unify = function(x, y, solver) {
      solver.bindings[x] = y;
      return true;
    };

    LogicVar.prototype.__eq__ = function(x, y) {
      return x.constructor === y.constructor && x.name === y.name;
    };

    LogicVar.prototype.__hash__ = function() {
      return hash(this.name);
    };

    LogicVar.prototype.toString = function() {
      return "%s" % this.name;
    };

    return LogicVar;

  })();

  dao.DummyVar = (function(_super) {
    __extends(DummyVar, _super);

    function DummyVar() {
      _ref = DummyVar.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    DummyVar.prototype.deref = function(bindings) {
      return this;
    };

    return DummyVar;

  })(dao.LogicVar);

  dao.Cons = (function() {
    function Cons(head, tail) {
      this.head = head;
      this.tail = tail;
    }

    Cons.prototype.unify = function(other, solver) {
      if (this.constructor !== other.constructor) {
        return solver.fail_cont.callOn(false);
      }
      if (solver.unify(this.head, other.head)) {
        if (solver.unify(this.tail, other.tail)) {
          return true;
        }
      }
      return solver.fail_cont.callOn(false);
    };

    Cons.prototype.match = function(other) {
      if (this.constructor !== other.constructor) {
        return false;
      }
      return match(this.head, other.head) && match(this.tail, other.tail);
    };

    Cons.prototype.unify_rule_head = function(other, env, subst) {
      var _, _i, _len, _ref1, _results;

      if (this.constructor !== other.constructor) {
        return;
      }
      _ref1 = unify_rule_head(this.head, other.head, env, subst);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ = _ref1[_i];
        _results.push((function() {
          var _j, _len1, _ref2, _results1;

          _ref2 = unify_rule_head(this.tail, other.tail, env, subst);
          _results1 = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            _ = _ref2[_j];
            _results1.push(pyyield(true));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Cons.prototype.copy_rule_head = function(env) {
      var head, tail;

      head = copy_rule_head(this.head, env);
      tail = copy_rule_head(this.tail, env);
      if (head === this.head && tail === this.tail) {
        return this;
      }
      return Cons(head, tail);
    };

    Cons.prototype.getvalue = function(memo, env) {
      var head, tail;

      head = get_value(this.head, memo, env);
      tail = get_value(this.tail, memo, env);
      return Cons(head, tail);
    };

    Cons.prototype.take_value = function(env) {
      var head, tail;

      head = take_value(this.head, env);
      tail = take_value(this.tail, env);
      if (head === this.head && tail === this.tail) {
        return this;
      }
      return Cons(head, tail);
    };

    Cons.prototype.copy = function(memo) {
      return Cons(copy(this.head, memo), copy(this.tail, memo));
    };

    Cons.prototype.closure = function(env) {
      var head, tail;

      head = closure(this.head, env);
      tail = closure(this.tail, env);
      if (head === this.head && tail === this.tail) {
        return this;
      }
      return Cons(head, tail);
    };

    Cons.prototype.__eq__ = function(other) {
      return this.constructor === other.constructor && this.head === other.head && this.tail === other.tail;
    };

    Cons.prototype.__iter__ = function() {
      var tail;

      tail = this;
      while (1) {
        pyyield(tail.head);
        if (tail.tail === nil) {
          return;
        } else if (isinstance(tail.tail, Cons)) {
          tail = tail.tail;
        } else {
          pyyield(tail.tail);
          return;
        }
      }
    };

    Cons.prototype.length = function() {
      var e;

      return ((function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          e = this[_i];
          _results.push(e);
        }
        return _results;
      }).call(this)).length;
    };

    Cons.prototype.toString = function() {
      var e;

      return "L(" + (join(' ', [
        (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = this.length; _i < _len; _i++) {
            e = this[_i];
            _results.push(e);
          }
          return _results;
        }).call(this)
      ])) + ")";
    };

    return Cons;

  })();

  cons = function(head, tail) {
    return new dao.Cons(head, tail);
  };

  dao.Nil = (function() {
    function Nil() {}

    Nil.prototype.alpha = function(env, compiler) {
      return new il.Nil();
    };

    Nil.prototype.length = function() {
      return 0;
    };

    Nil.prototype.__iter__ = function() {
      if (0) {
        return pyyield;
      }
    };

    Nil.prototype.toString = function() {
      return 'nil';
    };

    return Nil;

  })();

  dao.nil = new dao.Nil();

  dao.conslist = function() {
    var elements, result, term, _i, _len, _ref1;

    elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = nil;
    _ref1 = reversed(elements);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      term = _ref1[_i];
      result = new dao.Cons(term, result);
    }
    return result;
  };

  dao.cons2tuple = function(item) {
    var x, _i, _len, _results;

    if (!isinstance(item, Cons) && !isinstance(item, Array)) {
      return item;
    } else {
      _results = [];
      for (_i = 0, _len = item.length; _i < _len; _i++) {
        x = item[_i];
        _results.push(cons2tuple(x));
      }
      return _results;
    }
  };

  dao.UnquoteSplice = (function() {
    function UnquoteSplice(Qitem) {}

    UnquoteSplice.prototype.toString = function() {
      return ",@" + this.item;
    };

    return UnquoteSplice;

  })();

  dao.ExpressionWithCode = (function() {
    var __iter__;

    function ExpressionWithCode(exp, fun) {
      this.exp = exp;
      this.fun = fun;
    }

    ExpressionWithCode.prototype.__eq__ = function(x, y) {
      return (x.constructor === y.constructor && x.exp === y.exp) || x.exp === y;
    };

    __iter__ = function() {
      return iter(this.exp);
    };

    ExpressionWithCode.prototype.toString = function() {
      return this.exp.toString();
    };

    return ExpressionWithCode;

  })();

  dao.Macro = (function() {
    function Macro() {}

    return Macro;

  })();

  dao.MacroFunction = (function(_super) {
    __extends(MacroFunction, _super);

    function MacroFunction(fun) {
      this.fun = fun;
    }

    MacroFunction.prototype.callOn = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.fun.apply(this, args);
    };

    return MacroFunction;

  })(dao.Macro);

  dao.MacroRules = (function(_super) {
    __extends(MacroRules, _super);

    function MacroRules(fun) {
      this.fun = fun;
    }

    MacroRules.prototype.callOn = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.fun.apply(this, args);
    };

    MacroRules.prototype.default_end_cont = function(v) {
      throw new dao.NoSolution(v);
    };

    return MacroRules;

  })(dao.Macro);

  dao.Solver = (function() {
    function Solver() {
      this.bindings = new dao.Bindings();
      this.parse_state = void 0;
      this.catch_cont_map = {};
      this.cut_cont = this.cut_or_cont = this.fail_cont = default_end_cont;
    }

    Solver.prototype.unify = function(x, y) {
      var e, x_unify, y_unify;

      x = deref(x, this.bindings);
      y = deref(y, this.bindings);
      try {
        x_unify = x.unify;
      } catch (_error) {
        e = _error;
        try {
          y_unify = y.unify;
        } catch (_error) {
          e = _error;
          if (x === y) {
            return true;
          }
        }
        return this.fail_cont.callOn(false);
      }
      return y_unify(x, this);
      return x_unify(y, this);
    };

    Solver.prototype.find_catch_cont = function(tag) {
      var cont_stack, e;

      try {
        cont_stack = this.catch_cont_map[tag];
      } catch (_error) {
        e = _error;
        throw new dao.UncaughtThrow(tag);
      }
      return cont_stack.pop();
    };

    return Solver;

  })();

}).call(this);

/*
//@ sourceMappingURL=solve.map
*/
