// Generated by CoffeeScript 1.6.2
(function() {
  var ArgumentError, ArityError, Compiler, CpsEnv, Env, Error, OptimizationEnv, TypeError, VarLookupError, beautify, compile, fs, hasOwnProperty, il, _, _ref, _ref1, _ref2,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  fs = require("fs");

  beautify = require('js-beautify').js_beautify;

  il = require("./interlang");

  hasOwnProperty = Object.prototype.hasOwnProperty;

  exports.solve = function(exp, path) {
    var compiled, e;

    path = process.cwd() + '/lib/compiled.js';
    try {
      fs.unlinkSync(path);
    } catch (_error) {
      e = _error;
      null;
    }
    compile(exp, path);
    delete require.cache[require.resolve(path)];
    compiled = require(path);
    return compiled.main();
  };

  compile = function(exp, path) {
    var code, compiler, fd;

    compiler = new Compiler();
    code = compiler.compile(exp) + "\n//exports.main();";
    code = beautify(code, {
      indent_size: 2
    });
    fd = fs.openSync(path, 'w');
    fs.writeSync(fd, code);
    return fs.closeSync(fd);
  };

  exports.Compiler = Compiler = (function() {
    var e, instance, name, vop;

    function Compiler() {
      this.nameToVarIndex = {};
      this.exits = {};
      this.continues = {};
      this.protect = function(cont) {
        return cont;
      };
      this.nameVarMap = {};
    }

    Compiler.prototype.compile = function(exp) {
      var done, env, exps, lamda, v;

      this.env = env = new CpsEnv(null, {});
      exp = this.alpha(exp);
      this.env = env;
      v = this.newconst('v');
      done = il.idcont();
      exps = [il.assign(il.uservar('_'), il.require('underscore')), il.assign(il.uservar('__slice'), il.attr([], il.symbol('slice'))), il.assign(il.uservar('solve'), il.attr(il.require('./core'), il.symbol('solve'))), il.assign(il.uservar('parser'), il.require('./parser')), il.assign(il.uservar('solvecore'), il.require('./solve')), il.assign(il.uservar('Solver'), il.attr(il.uservar('solvecore'), il.symbol('Solver'))), il.assign(il.uservar('Trail'), il.attr(il.uservar('solvecore'), il.symbol('Trail'))), il.assign(il.uservar('Var'), il.attr(il.uservar('solvecore'), il.symbol('Var'))), il.assign(il.uservar('DummyVar'), il.attr(il.uservar('solvecore'), il.symbol('DummyVar'))), il.assign(il.uservar('solver'), il["new"](il.symbol('Solver').call())), il.assign(il.uservar('UArray'), il.attr(il.uservar('solvecore'), il.symbol('UArray'))), il.assign(il.uservar('UObject'), il.attr(il.uservar('solvecore'), il.symbol('UObject'))), il.assign(il.uservar('Cons'), il.attr(il.uservar('solvecore'), il.symbol('Cons'))), il.assign(il.state, null), il.assign(il.catches, {}), il.assign(il.trail, il.newTrail), il.assign(il.failcont, done), il.assign(il.cutcont, il.failcont), il.userlamda([], this.cont(exp, done)).call()];
      lamda = il.userlamda.apply(il, [[]].concat(__slice.call(exps)));
      env = new OptimizationEnv(env, {});
      lamda = this.optimize(lamda, env);
      lamda = lamda.jsify(this, env);
      exp = il.assign(il.attr(il.uservar('exports'), il.symbol('main')), lamda);
      return exp.toCode(this);
    };

    Compiler.prototype.lookup = function(name) {
      var e;

      try {
        return this.env.lookup(name);
      } catch (_error) {
        e = _error;
        return name;
      }
    };

    Compiler.prototype.uservar = function(name) {
      var map, v;

      map = this.nameVarMap;
      v = map[name];
      if (v) {
        return v;
      } else {
        map[name] = v = il.uservar(name);
        return v;
      }
    };

    Compiler.prototype.userconst = function(name) {
      var map, v;

      map = this.nameVarMap;
      v = map[name];
      if (v) {
        return v;
      } else {
        map[name] = v = il.uservar(name);
        v.isConst = true;
        return v;
      }
    };

    Compiler.prototype.newvar = function(v) {
      if (_.isString(v)) {
        return this.env.newvar(il.internalvar(v));
      } else {
        return this.env.newvar(v);
      }
    };

    Compiler.prototype.newconst = function(v) {
      if (_.isString(v)) {
        return this.env.newconst(il.internalvar(v));
      } else {
        return this.env.newconst(v);
      }
    };

    Compiler.prototype.pushEnv = function() {
      return this.env = this.env.extend();
    };

    Compiler.prototype.popEnv = function() {
      return this.env = this.env.outer;
    };

    Compiler.prototype.alpha = function(exp) {
      var head, i, length, result, _i, _ref;

      if (_.isString(exp)) {
        return this.lookup(exp);
      }
      if (!_.isArray(exp)) {
        return exp;
      }
      length = exp.length;
      if (length === 0) {
        return exp;
      }
      if (length === 1) {
        exp;
      }
      head = exp[0];
      if (!_.isString(head)) {
        return exp;
      }
      if (hasOwnProperty.call(this.specials, head)) {
        if (hasOwnProperty.call(this.specialsAlpha, head)) {
          return (_ref = this.specialsAlpha[head]).call.apply(_ref, [this, head].concat(__slice.call(exp.slice(1))));
        } else {
          result = [head];
          for (i = _i = 1; 1 <= length ? _i < length : _i > length; i = 1 <= length ? ++_i : --_i) {
            result.push(this.alpha(exp[i]));
          }
          return result;
        }
      } else {
        return exp;
      }
    };

    Compiler.prototype.cont = function(exp, cont) {
      var head, length, _ref;

      if (_.isString(exp)) {
        return cont.call(this.uservar(exp));
      }
      if (!_.isArray(exp)) {
        return cont.call(exp);
      }
      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      }
      head = exp[0];
      if (!_.isString(head)) {
        return cont.call(exp);
      }
      if (hasOwnProperty.call(this.specials, head)) {
        return (_ref = this.specials[head]).call.apply(_ref, [this, cont].concat(__slice.call(exp.slice(1))));
      } else {
        return cont.call(exp);
      }
    };

    Compiler.prototype.specials = {
      "quote": function(cont, exp) {
        return cont.call(exp);
      },
      "eval": function(cont, exp, path) {
        var p, v;

        v = this.newconst('v');
        p = this.newconst('path');
        return this.cont(exp, il.clamda(v, this.cont(path, il.clamda(p, cont.call(il.evalexpr(v, p))))));
      },
      'string': function(cont, exp) {
        return cont.call(exp);
      },
      "begin": function() {
        var cont, exps;

        cont = arguments[0], exps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return this.expsCont(exps, cont);
      },
      "nonlocal": function() {
        var cont, name, names;

        cont = arguments[0], names = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return il.begin(il.nonlocal((function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            _results.push(this.uservar(name));
          }
          return _results;
        }).call(this)), cont.call(null));
      },
      "variable": function() {
        var cont, name, v, vars, _i, _len;

        cont = arguments[0], vars = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        for (_i = 0, _len = vars.length; _i < _len; _i++) {
          name = vars[_i];
          v = this.uservar(name);
          delete v.isConst;
        }
        return cont.call(null);
      },
      "uniquevar": function(cont, name) {
        return cont.call(this.uservar(name));
      },
      "uniqueconst": function(cont, name) {
        return cont.call(this.userconst(name));
      },
      "assign": function(cont, left, exp) {
        return this.leftValueCont(cont, "assign", left, exp);
      },
      "augment-assign": function(cont, op, left, exp) {
        return this.leftValueCont(cont, "augment-assign", left, exp, op);
      },
      'inc': function(cont, item) {
        return this.leftValueCont(cont, "inc", item);
      },
      'suffixinc': function(cont, item) {
        return this.leftValueCont(cont, "suffixinc", item);
      },
      'dec': function(cont, item) {
        return this.leftValueCont(cont, "dec", item);
      },
      'suffixdec': function(cont, item) {
        return this.leftValueCont(cont, "suffixdec", item);
      },
      'incp': function(cont, item) {
        return this.leftValueCont(cont, "incp", item);
      },
      'suffixincp': function(cont, item) {
        return this.leftValueCont(cont, "suffixincp", item);
      },
      'decp': function(cont, item) {
        return this.leftValueCont(cont, "decp", item);
      },
      'suffixdecp': function(cont, item) {
        return this.leftValueCont(cont, "suffixdecp", item);
      },
      "if": function(cont, test, then_, else_) {
        var v;

        v = this.newconst('v');
        return this.cont(test, il.clamda(v, il.if_(v, this.cont(then_, cont), this.cont(else_, cont))));
      },
      "switch": function(cont, test, clauses, else_) {
        var act, clause, v, value, values;

        v = this.newconst('v');
        clauses = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = clauses.length; _i < _len; _i++) {
            clause = clauses[_i];
            values = clause[0];
            act = clause[1];
            values = (function() {
              var _j, _len1, _results1;

              _results1 = [];
              for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
                value = values[_j];
                _results1.push(il.lamda([], this.cont(value, il.idcont())).call());
              }
              return _results1;
            }).call(this);
            act = this.cont(act, cont);
            _results.push([values, act]);
          }
          return _results;
        }).call(this);
        return this.cont(test, il.clamda(v, il.switch_(v, clauses, this.cont(else_, cont))));
      },
      "jsfun": function(cont, func) {
        var f;

        f = il.jsfun(func);
        f._effect = this._effect;
        return cont.call(f);
      },
      "direct": function(cont, exp) {
        return il.begin(exp, cont.call());
      },
      "pure": function(cont, exp) {
        var oldEffect, result;

        oldEffect = this._effect;
        this._effect = il.PURE;
        result = this.cont(exp, cont);
        this._effect = oldEffect;
        return result;
      },
      "effect": function(cont, exp) {
        var oldEffect, result;

        oldEffect = this._effect;
        this._effect = il.EFFECT;
        result = this.cont(exp, cont);
        this._effect = oldEffect;
        return result;
      },
      "io": function(cont, exp) {
        var oldEffect, result;

        oldEffect = this._effect;
        this._effect = il.IO;
        result = this.cont(exp, cont);
        this._effect = oldEffect;
        return result;
      },
      "lambda": function() {
        var body, cont, k, p, params;

        cont = arguments[0], params = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        this.pushEnv();
        params = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            p = params[_i];
            _results.push(this.uservar(p));
          }
          return _results;
        }).call(this);
        k = this.newconst('cont');
        params.push(k);
        cont = cont.call(il.userlamda(params, this.expsCont(body, k)));
        this.popEnv();
        return cont;
      },
      "macro": function() {
        var body, cont, k, p, params, params1;

        cont = arguments[0], params = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        this.pushEnv();
        params1 = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            p = params[_i];
            _results.push(this.uservar(p));
          }
          return _results;
        }).call(this);
        k = this.newconst('cont');
        params1.push(k);
        cont = cont.call(il.lamda(params1, this.expsCont(body, k)));
        this.popEnv();
        return cont;
      },
      "evalarg": function(cont, name) {
        return cont.call(this.uservar(name).call());
      },
      "array": function() {
        var args, compiler, cont, i, length, xs, _i, _ref;

        cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        compiler = this;
        length = args.length;
        xs = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('x' + i));
          }
          return _results;
        }).call(this);
        cont = cont.call(il.array(xs));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          cont = (function(i, cont) {
            return compiler.cont(args[i], il.clamda(xs[i], cont));
          })(i, cont);
        }
        return cont;
      },
      "uarray": function() {
        var args, compiler, cont, i, length, xs, _i, _ref;

        cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        compiler = this;
        length = args.length;
        xs = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('x' + i));
          }
          return _results;
        }).call(this);
        cont = cont.call(il.uarray(xs));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          cont = (function(i, cont) {
            return compiler.cont(args[i], il.clamda(xs[i], cont));
          })(i, cont);
        }
        return cont;
      },
      "makeobject": function() {
        var args, compiler, cont, i, length, obj, xs, _i, _ref;

        cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        compiler = this;
        length = args.length;
        obj = this.newconst('object1');
        xs = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('x' + i));
          }
          return _results;
        }).call(this);
        cont = il.begin(il.assign(obj, {}), il.setobject(obj, xs), cont.call(obj));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          cont = (function(i, cont) {
            return compiler.cont(args[i], il.clamda(xs[i], cont));
          })(i, cont);
        }
        return cont;
      },
      "uobject": function() {
        var args, compiler, cont, i, length, obj, uobj, xs, _i, _ref;

        cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        compiler = this;
        length = args.length;
        obj = this.newconst('object1');
        uobj = this.newconst('uobject1');
        xs = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('x' + i));
          }
          return _results;
        }).call(this);
        cont = il.begin(il.assign(obj, {}), il.setobject(obj, xs), il.assign(uobj, il.uobject(obj)), cont.call(uobj));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          cont = (function(i, cont) {
            return compiler.cont(args[i], il.clamda(xs[i], cont));
          })(i, cont);
        }
        return cont;
      },
      "cons": function(cont, head, tail) {
        var v, v2;

        v = this.newconst('v');
        v2 = this.newconst('v');
        return this.cont(head, il.clamda(v, this.cont(tail, il.clamda(v1, cont.call(il.cons(v, v1))))));
      },
      "funcall": function() {
        var args, body, caller, compiler, cont, f, i, length, params, _i, _ref;

        cont = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        compiler = this;
        f = this.newconst('func');
        length = args.length;
        params = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('arg' + i));
          }
          return _results;
        }).call(this);
        params.push(cont);
        body = f.apply(params);
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          body = (function(i, body) {
            return compiler.cont(args[i], il.clamda(params[i], body));
          })(i, body);
        }
        return this.cont(caller, il.clamda(f, body));
      },
      "macall": function() {
        var args, body, caller, compiler, cont, f, i, length, params, _i, _ref;

        cont = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        compiler = this;
        f = this.newconst('func');
        length = args.length;
        params = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('arg' + i));
          }
          return _results;
        }).call(this);
        params.push(cont);
        body = f.apply(params);
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          body = (function(i, body) {
            return il.clamda(params[i], body).call(il.lamda([], compiler.cont(args[i], il.idcont())));
          })(i, body);
        }
        return this.cont(caller, il.clamda(f, body));
      },
      "jsfuncall": function() {
        var args, body, caller, compiler, cont, f, i, length, params, _i, _ref;

        cont = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        compiler = this;
        f = this.newconst('func');
        length = args.length;
        params = (function() {
          var _i, _results;

          _results = [];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            _results.push(this.newconst('arg' + i));
          }
          return _results;
        }).call(this);
        body = cont.call(f.apply(params));
        for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
          body = (function(i, body) {
            return compiler.cont(args[i], il.clamda(params[i], body));
          })(i, body);
        }
        return this.cont(caller, il.clamda(f, body));
      },
      "for": function() {
        var body, cont, init, step, test;

        cont = arguments[0], init = arguments[1], test = arguments[2], step = arguments[3], body = 5 <= arguments.length ? __slice.call(arguments, 4) : [];
        init = il.lamda([], compiler.cont(init, il.idcont())).call();
        test = il.lamda([], compiler.cont(test, il.idcont())).call();
        step = il.lamda([], compiler.cont(step, il.idcont())).call();
        body = compiler.expsCont(body, il.idcont());
        return il.begin(il.for_(init, test, step, body), cont.call(null));
      },
      "forin": function() {
        var body, cont, container, vari;

        cont = arguments[0], vari = arguments[1], container = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
        container = il.lamda([], compiler.cont(container, il.idcont())).call();
        body = compiler.expsCont(body, il.idcont());
        return il.begin(il.forin(this.userconst(vari), container), cont.call(null));
      },
      "forof": function() {
        var body, cont, container, vari;

        cont = arguments[0], vari = arguments[1], container = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
        container = il.lamda([], compiler.cont(container, il.idcont())).call();
        body = compiler.expsCont(body, il.idcont());
        return il.begin(il.forof(this.userconst(vari), container), cont.call(null));
      },
      "try": function(cont, test, vari, catchBody, final) {
        test = il.lamda([], compiler.cont(test, il.idcont())).call();
        catchBody = compiler.cont(catchBody, il.idcont());
        final = compiler.cont(final, il.idcont());
        return il.begin(il["try"](test, this.userconst(vari), clauses, final), cont.call(null));
      },
      "quasiquote": function(cont, exp) {
        return this.quasiquote(exp, cont);
      },
      "unquote": function(cont, exp) {
        throw new Error("unquote: too many unquote and unquoteSlice");
      },
      "unquote-slice": function(cont, exp) {
        throw new Error("unquoteSlice: too many unquote and unquoteSlice");
      },
      'block': function() {
        var body, cont, continues, defaultContinues, defaultExits, exits, f, fun, label, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

        cont = arguments[0], label = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        label = label[1];
        if (!_.isString(label)) {
          label = '';
          body = [label].concat(body);
        }
        exits = (_ref = (_base = this.exits)[label]) != null ? _ref : _base[label] = [];
        exits.push(cont);
        defaultExits = (_ref1 = (_base1 = this.exits)['']) != null ? _ref1 : _base1[''] = [];
        defaultExits.push(cont);
        continues = (_ref2 = (_base2 = this.continues)[label]) != null ? _ref2 : _base2[label] = [];
        f = this.newconst(il.blockvar('block' + label));
        f.isRecursive = true;
        fun = il.blocklamda(null);
        continues.push(f);
        defaultContinues = (_ref3 = (_base3 = this.continues)['']) != null ? _ref3 : _base3[''] = [];
        defaultContinues.push(f);
        fun.body = this.expsCont(body, cont);
        exits.pop();
        if (exits.length === 0) {
          delete this.exits[label];
        }
        continues.pop();
        if (continues.length === 0) {
          delete this.continues[label];
        }
        defaultExits.pop();
        defaultContinues.pop();
        return il.begin(il.assign(f, fun), f.call());
      },
      'break': function(cont, label, value) {
        var exitCont, exits;

        label = label[1];
        exits = this.exits[label];
        if (!exits || exits === []) {
          throw new Error(label);
        }
        exitCont = exits[exits.length - 1];
        cont = this.cont(value, this.protect(exitCont));
        return cont;
      },
      'continue': function(cont, label) {
        var continueCont, continues;

        label = label[1];
        continues = this.continues[label];
        if (!continues || continues === []) {
          throw new Error(label);
        }
        continueCont = continues[continues.length - 1];
        return this.protect(continueCont).call();
      },
      'catch': function() {
        var cont, forms, tag, temp1, temp2, v, v2;

        cont = arguments[0], tag = arguments[1], forms = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        v = this.newconst('v');
        v2 = this.newconst('v');
        temp1 = this.newconst('temp');
        temp2 = this.newconst('temp');
        return this.cont(tag, il.clamda(v, il.assign(temp1, v), il.pushCatch(temp1, cont), this.expsCont(forms, il.clamda(v2, il.assign(temp2, v2), il.popCatch(temp1), cont.call(temp2)))));
      },
      "throw": function(cont, tag, form) {
        var temp, temp2, v, v2;

        v = this.newconst('v');
        v2 = this.newconst('v');
        temp = this.newconst('temp');
        temp2 = this.newconst('temp');
        return this.cont(tag, il.clamda(v, il.assign(temp, v), this.cont(form, il.clamda(v2, il.assign(temp2, v2), this.protect(il.findCatch(temp)).call(temp2)))));
      },
      'unwind-protect': function() {
        var cleanup, compiler, cont, form, oldprotect, result, temp, temp2, v1, v2;

        cont = arguments[0], form = arguments[1], cleanup = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        oldprotect = this.protect;
        v1 = this.newconst('v');
        v2 = this.newconst('v');
        temp = this.newconst('temp');
        temp2 = this.newconst('temp');
        compiler = this;
        this.protect = function(cont) {
          return il.clamda(v1, il.assign(temp, v1), compiler.expsCont(cleanup, il.clamda(v2, v2, oldprotect(cont).call(temp))));
        };
        result = this.cont(form, il.clamda(v1, il.assign(temp, v1), this.expsCont(cleanup, il.clamda(v2, v2, cont.call(temp)))));
        this.protect = oldprotect;
        return result;
      },
      'callcc': function(cont, fun) {
        var v;

        v = this.newconst('v');
        return this.cont(fun, il.clamda(v, cont.call(v.call(cont, cont))));
      },
      'callfc': function(cont, fun) {
        var v;

        v = this.newconst('v');
        return this.cont(fun, il.clamda(v, cont.call(v.call(il.failcont, cont))));
      },
      'logicvar': function(cont, name) {
        return cont.call(il.newLogicVar(name));
      },
      'dummy': function(cont, name) {
        return cont.call(il.newDummyVar(name));
      },
      'unify': function(cont, x, y) {
        var x1, y1;

        x1 = this.newconst('x');
        y1 = this.newconst('y');
        return this.cont(x, il.clamda(x1, this.cont(y, il.clamda(y1, il.if_(il.unify(x1, y1), cont.call(true), il.failcont.call(false))))));
      },
      'notunify': function(cont, x, y) {
        var x1, y1;

        x1 = this.newconst('x');
        y1 = this.newconst('y');
        return this.cont(x, il.clamda(x1, this.cont(y, il.clamda(y1, il.if_(il.unify(x, y), il.failcont.call(false), cont.call(true))))));
      },
      'is': function(cont, vari, exp) {
        var v;

        v = this.newconst('v');
        return this.cont(exp, il.clamda(v, il.bind(vari, v), cont.call(true)));
      },
      'bind': function(cont, vari, term) {
        return il.begin(il.bind(vari, il.deref(term)), cont.call(true));
      },
      'getvalue': function(cont, term) {
        return cont.call(il.getvalue(this.interlang(term)));
      },
      'succeed': function(cont) {
        return cont.call(true);
      },
      'fail': function(cont) {
        return il.failcont.call(false);
      },
      'pushp': function(cont, list, value) {
        var fc, list1, list2, v, value1, value2;

        list1 = this.newconst('list');
        value1 = this.newconst('value');
        list2 = this.newconst('list');
        value2 = this.newconst('value');
        fc = this.newconst('fc');
        v = this.newconst('v');
        return this.cont(list, il.clamda(list1, il.assign(list2, list1), this.cont(value, il.clamda(value1, il.assign(value2, value1), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.pop(list2), fc.call(value2))), il.push(list2, value2), cont.call(value2)))));
      },
      'orp': function(cont, x, y) {
        var e, fc, state, trail, v;

        v = this.newconst('v');
        e = this.newconst('e');
        trail = this.newconst('trail');
        state = this.newconst('state');
        fc = this.newconst('fc');
        return il.begin(il.assign(trail, il.trail), il.assign(state, il.state), il.assign(fc, il.failcont), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, v, il.undotrail(il.trail), il.settrail(trail), il.setstate(state), il.setfailcont(fc), this.cont(y, cont))), this.cont(x, cont));
      },
      'ifp': function(cont, test, action) {
        var fc, v;

        v = this.newconst('v');
        fc = this.newconst('fc');
        return il.begin(il.assign(fc, il.failcont), this.cont(test, il.clamda(v, v, il.setfailcont(fc), this.cont(action, cont))));
      },
      'notp': function(cont, goal) {
        var fc, state, trail, v, v1;

        v = this.newconst('v');
        v1 = this.newconst('v');
        trail = this.newconst('trail');
        state = this.newconst('state');
        fc = this.newconst('fc');
        return il.begin(il.assign(trail, il.trail), il.assign(fc, il.failcont), il.assign(state, il.state), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, il.assign(v1, v), il.undotrail(il.trail), il.settrail(trail), il.setstate(state), il.setfailcont(fc), cont.call(v1))), this.cont(goal, fc));
      },
      'repeat': function(cont) {
        return il.begin(il.setfailcont(cont), cont.call(null));
      },
      'cutable': function(cont, goal) {
        var cc, v, v1;

        cc = this.newconst('cutcont');
        v = this.newconst('v');
        v1 = this.newconst('v');
        return il.begin(il.assign(cc, il.cutcont), il.assign(il.cutcont, il.failcont), this.cont(goal, il.clamda(v, il.assign(v1, v), il.setcutcont(cc), cont.call(v1))));
      },
      'cut': function(cont) {
        return il.begin(il.setfailcont(il.cutcont), cont.call(null));
      },
      'findall': function(cont, goal, result, template) {
        var fc, result1, v, v1, v2;

        fc = this.newconst('fc');
        v = this.newconst('v');
        v1 = this.newconst('v');
        if (result == null) {
          return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))), this.cont(goal, il.failcont));
        } else {
          v2 = this.newconst('v');
          result1 = this.newconst('result');
          return il.begin(il.assign(result1, []), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v2, il.assign(v1, v2), il.if_(il.unify(this.interlang(result), result1), il.begin(il.setfailcont(fc), cont.call(null)), fc.call(v1)))), this.cont(goal, il.clamda(v, il.assign(v1, v), il.push(result1, il.getvalue(this.interlang(template))), il.failcont.call(v1))));
        }
      },
      'once': function(cont, goal) {
        var fc, v, v1;

        fc = this.newconst('fc');
        v = this.newconst('v');
        v1 = this.newconst('v');
        return il.begin(il.assign(fc, il.failcont), this.cont(goal, il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))));
      },
      'parse': function(cont, exp, state) {
        var oldState, v, v1;

        v = this.newconst('v');
        v1 = this.newconst('v');
        oldState = this.newconst('state');
        return this.cont(state, il.clamda(v, il.assign(oldState, il.state), il.setstate(v), this.cont(exp, il.clamda(v, il.assign(v1, v), il.setstate(oldState), cont.call(v1)))));
      },
      'parsetext': function(cont, exp, text) {
        var oldState, v, v1;

        v = this.newconst('v');
        v1 = this.newconst('v');
        oldState = this.newconst('state');
        return this.cont(text, il.clamda(v, il.begin(il.assign(oldState, il.state), il.setstate(il.array(v, 0)), this.cont(exp, il.clamda(v, il.assign(v1, v), il.setstate(oldState), cont.call(v1))))));
      },
      'setstate': function(cont, state) {
        var v;

        v = this.newconst('v');
        return this.cont(state, il.clamda(v, il.setstate(v), cont.call(true)));
      },
      'settext': function(cont, text) {
        var v;

        v = this.newconst('v');
        return this.cont(text, il.clamda(v, il.setstate(il.array(v, 0)), cont.call(true)));
      },
      'setpos': function(cont, pos) {
        var v;

        v = this.newconst('v');
        return this.cont(pos, il.clamda(v, il.assign(il.index(il.state, 1), v), cont.call(true)));
      },
      'getstate': function(cont) {
        return cont.call(il.state);
      },
      'gettext': function(cont) {
        return cont.call(il.index(il.state, 0));
      },
      'getpos': function(cont) {
        return cont.call(il.index(il.state, 1));
      },
      'eoi': function(cont) {
        var data, pos;

        data = this.newconst('data');
        pos = this.newconst('pos');
        return il.begin(il.listassign(data, pos, il.state), il.if_(il.ge(pos, il.length(data)), cont.call(true), il.failcont.call(false)));
      },
      'boi': function(cont) {
        return il.if_(il.eq(il.index(il.state, 1), 0), cont.call(true), il.failcont.call(false));
      },
      'eol': function(cont) {
        var c, pos, text;

        text = this.newconst('text');
        pos = this.newconst('pos');
        c = this.newconst('c');
        return il.begin(il.listassign(text, pos, il.state), il.if_(il.ge(pos, il.length(text)), cont.call(true), il.begin(il.assign(c, il.index(text, pos, 1)), il.if_(il.or_(il.eq(c, "\r"), il.eq(c, "\n")), cont.call(true), il.failcont.call(false)))));
      },
      'bol': function(cont) {
        var c, pos, text;

        text = this.newconst('text');
        pos = this.newconst('pos');
        c = this.newconst('c');
        return il.begin(il.listassign(text, pos, il.state), il.if_(il.eq(pos, 0), cont.call(true), il.begin(il.assign(c, il.index(text, il.sub(pos, 1))), il.if_(il.or_(il.eq(c, "\r"), il.eq(c, "\n")), cont.call(true), il.failcont.call(false)))));
      },
      'step': function(cont, n) {
        var pos, pos1, text, v;

        v = this.newconst('v');
        text = this.newconst('text');
        pos = this.newconst('pos');
        pos1 = this.newconst('pos');
        return this.cont(n, il.clamda(v, il.listassign(text, pos, il.state), il.assign(pos1, il.add(pos, v)), il.setstate(il.array(text, pos1)), cont.call(pos1)));
      },
      'lefttext': function(cont) {
        return cont.call(il.slice(il.index(il.state, 0), il.index(il.state, 1)));
      },
      'subtext': function(cont, length, start) {
        var length1, length2, length3, pos, start1, start2, start3, text;

        text = this.newconst('text');
        pos = this.newconst('pos');
        start1 = this.newconst('start');
        length1 = this.newconst('length');
        start2 = this.newconst('start');
        length2 = this.newconst('length');
        start3 = this.newconst('start');
        length3 = this.newconst('length');
        return this.cont(length, il.clamda(length1, il.assign(length2, length1), this.cont(start, il.clamda(start1, il.assign(start2, start1), il.listassign(text, pos, il.state), il.begin(il.assign(start3, il.if_(il.ne(start2, null), start2, pos)), il.assign(length3, il.if_(il.ne(length2, null), length2, il.length(text))), cont.call(il.slice(text, start3, il.add(start3, length3))))))));
      },
      'nextchar': function(cont) {
        var pos, text;

        text = this.newconst('text');
        pos = this.newconst('pos');
        return il.begin(il.listassign(text, pos, il.state), cont.call(il.index(text, pos)));
      },
      'may': function(cont, exp) {
        return il.begin(il.appendFailcont(cont), this.cont(exp, cont));
      },
      'lazymay': function(cont, exp) {
        var fc, v;

        fc = this.newconst('fc');
        v = this.newconst('v');
        return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.setfailcont(fc), this.cont(exp, cont))), cont.call(null));
      },
      'greedymay': function(cont, exp) {
        var fc, v, v1, v2;

        fc = this.newconst('fc');
        v = this.newconst('v');
        v1 = this.newconst('v');
        v2 = this.newconst('v');
        return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))), this.cont(exp, il.clamda(v, il.assign(v2, v), il.setfailcont(fc), cont.call(v2))));
      },
      'any': function(cont, exp) {
        var anyCont, fc, state, trail, v, v1;

        fc = this.newconst('fc');
        trail = this.newconst('trail');
        state = this.newconst('state');
        anyCont = this.newconst('anyCont');
        anyCont.isRecursive = true;
        v = this.newconst('v');
        v1 = this.newconst('v');
        return il.begin(il.assign(anyCont, il.recclamda(v, il.assign(fc, il.failcont), il.assign(trail, il.trail), il.assign(state, il.state), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, il.assign(v1, v), il.undotrail(il.trail), il.settrail(trail), il.setstate(state), il.setfailcont(fc), cont.call(v1))), this.cont(exp, anyCont))), anyCont.call(null));
      },
      'lazyany': function(cont, exp) {
        var anyCont, anyFcont, fc, trail, v;

        fc = this.newconst('fc');
        trail = this.newconst('trail');
        v = this.newconst('v');
        anyCont = this.newconst('anyCont');
        anyFcont = this.newconst('anyFcont');
        anyCont.isRecursive = true;
        anyFcont.isRecursive = true;
        return il.begin(il.local(trail), il.assign(anyCont, il.recclamda(v, il.nonlocal(trail), il.assign(trail, il.trail), il.settrail(il.newTrail), il.setfailcont(anyFcont), cont.call(null))), il.assign(anyFcont, il.recclamda(v, il.undotrail(il.trail), il.settrail(trail), il.setfailcont(fc), this.cont(exp, anyCont))), il.assign(fc, il.failcont), anyCont.call(null));
      },
      'greedyany': function(cont, exp) {
        var anyCont, fc, v, v1;

        fc = this.newconst('fc');
        anyCont = this.newconst('anyCont');
        anyCont.isRecursive = true;
        v = this.newconst('v');
        v1 = this.newconst('v');
        return il.begin(il.assign(anyCont, il.recclamda(v, this.cont(exp, anyCont))), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))), anyCont.call(null));
      },
      'parallel': function(cont, x, y, checkFunction) {
        var right, state, v, v1;

        if (checkFunction == null) {
          checkFunction = function(state, baseState) {
            return state[1] === baseState[1];
          };
        }
        state = this.newconst('state');
        right = this.newconst('right');
        v = this.newconst('v');
        v1 = this.newconst('v');
        return il.begin(il.assign(state, il.state), this.cont(x, il.clamda(v, v, il.assign(right, il.state), il.setstate(state), this.cont(y, il.clamda(v, il.assign(v1, v), il.if_(il.fun(checkFunction).call(il.state, right), cont.call(v1), il.failcont.call(v1)))))));
      },
      'follow': function(cont, item) {
        var state, v, v1;

        state = this.newconst('state');
        v = this.newconst('v');
        v1 = this.newconst('v');
        state = this.newconst('state');
        return il.begin(il.assign(state, il.state), this.cont(item, il.clamda(v, il.assign(v1, v), il.setstate(state), cont.call(v))));
      },
      'notfollow': function(cont, item) {
        var fc, state, v, v1;

        state = this.newconst('state');
        fc = this.newconst('fc');
        v = this.newconst('v');
        v1 = this.newconst('v');
        return il.begin(il.assign(fc, il.failcont), il.assign(state, il.state), il.setfailcont(cont), this.cont(item, il.clamda(v, il.assign(v1, v), il.setstate(state), fc.call(v1))));
      }
    };

    Compiler = Compiler;

    for (name in il) {
      vop = il[name];
      try {
        instance = typeof vop === "function" ? vop() : void 0;
      } catch (_error) {
        e = _error;
        continue;
      }
      if (instance instanceof il.VirtualOperation && __indexOf.call(il.excludes, name) < 0) {
        (function(name, vop) {
          return Compiler.prototype.specials['vop_' + name] = function() {
            var args, compiler, cont, i, length, params, _i, _ref;

            cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            compiler = this;
            length = args.length;
            params = (function() {
              var _i, _results;

              _results = [];
              for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
                _results.push(this.newconst('a' + i));
              }
              return _results;
            }).call(this);
            cont = cont.call(vop.apply(null, params));
            for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
              cont = (function(i, cont) {
                return compiler.cont(args[i], il.clamda(params[i], cont));
              })(i, cont);
            }
            return cont;
          };
        })(name, vop);
      }
    }

    Compiler.prototype.leftValueCont = function(cont, task, item, exp, op) {
      var assignExpCont, head, i, index, length, obj, object,
        _this = this;

      assignExpCont = function(item) {
        var fc, temp, v;

        v = _this.newconst('v');
        temp = _this.newconst('temp');
        switch (task) {
          case 'assign':
            return _this.cont(exp, il.clamda(v, il.assign(item, v), cont.call(item)));
          case 'augment-assign':
            return _this.cont(exp, il.clamda(v, il.assign(item, il[op](item, v)), cont.call(item)));
          case 'inc':
            return il.begin(il.assign(item, il.add(item, 1)), cont.call(item));
          case 'dec':
            return il.begin(il.assign(item, il.sub(item, 1)), cont.call(item));
          case 'suffixinc':
            return il.begin(il.assign(temp, item), il.assign(item, il.add(item, 1)), cont.call(temp));
          case 'suffixdec':
            return il.begin(il.assign(temp, item), il.assign(item, il.sub(item, 1)), cont.call(temp));
          case 'incp':
            fc = _this.newconst('fc');
            return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.sub(item, 1)), fc.call(item))), il.assign(item, il.add(item, 1)), cont.call(item));
          case 'decp':
            fc = _this.newconst('fc');
            return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.add(item, 1)), fc.call(item))), il.assign(item, il.sub(item, 1)), cont.call(item));
          case 'suffixincp':
            fc = _this.newconst('fc');
            return il.begin(il.assign(temp, item), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.sub(item, 1)), fc.call(temp))), il.assign(item, il.add(item, 1)), cont.call(temp));
          case 'suffixdecp':
            fc = _this.newconst('fc');
            return il.begin(il.assign(temp, item), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.add(item, 1)), fc.call(temp))), il.assign(item, il.sub(item, 1)), cont.call(temp));
        }
      };
      if (_.isString(item)) {
        return assignExpCont(this.uservar(item));
      }
      if (!_.isArray(item)) {
        throw new Error("Left value should be an sexpression.");
      }
      length = item.length;
      if (length === 0) {
        throw new Error("Left value side should not be empty list.");
      }
      head = item[0];
      if (!_.isString(head)) {
        throw new Error("Keyword should be a string.");
      }
      if (head === "index") {
        object = item[1];
        index = item[2];
        obj = this.newconst('obj');
        i = this.newconst('i');
        return this.cont(object, il.clamda(obj, this.cont(index, il.clamda(i, assignExpCont(il.index(obj, i))))));
      } else if (head === 'uniquevar') {
        return assignExpCont(this.uservar(item[1]));
      } else if (head === 'uniqueconst') {
        return assignExpCont(this.userconst(item[1]));
      } else {
        throw new Error("Left Value side should be assignable expression.");
      }
    };

    Compiler.prototype.expsCont = function(exps, cont) {
      var length, v;

      length = exps.length;
      if (length === 0) {
        throw new exports.TypeError(exps);
      } else if (length === 1) {
        return this.cont(exps[0], cont);
      } else {
        v = this.newconst('v');
        return this.cont(exps[0], il.clamda(v, v, this.expsCont(exps.slice(1), cont)));
      }
    };

    Compiler.prototype.quasiquote = function(exp, cont) {
      var head, i, length, quasilist, v, _i, _ref;

      if (!_.isArray(exp)) {
        return cont.call(exp);
      }
      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      }
      head = exp[0];
      if (!_.isString(head)) {
        return cont.call(exp);
      }
      if (!this.specials.hasOwnProperty(head)) {
        return cont.call(exp);
      }
      head = exp[0];
      if (head === "unquote") {
        return this.cont(exp[1], cont);
      } else if (head === "unquote-slice") {
        return this.cont(exp[1], cont);
      } else if (head === "quote") {
        return cont.call(exp);
      } else if (head === "string") {
        return cont.call(exp);
      } else {
        quasilist = this.newvar('quasilist');
        v = this.newconst('v');
        cont = cont.call(quasilist);
        for (i = _i = _ref = exp.length - 1; _i >= 1; i = _i += -1) {
          e = exp[i];
          if (_.isArray(e) && e.length > 0 && e[0] === "unquote-slice") {
            cont = this.quasiquote(e, il.clamda(v, il.assign(quasilist, il.concat(quasilist, v)), cont));
          } else {
            cont = this.quasiquote(e, il.clamda(v, il.push(quasilist, v), cont));
          }
        }
        return il.begin(il.assign(quasilist, il.list(head)), cont);
      }
    };

    Compiler.prototype.interlang = function(term) {
      var head, length;

      if (_.isString(term)) {
        return this.uservar(term);
      }
      if (!_.isArray(term)) {
        return term;
      }
      length = term.length;
      if (length === 0) {
        return term;
      }
      head = term[0];
      if (!_.isString(head)) {
        return term;
      }
      if (head === 'string') {
        return term[1];
      }
      if (head === 'uniquevar') {
        return this.uservar(term);
      }
      if (head === 'uniqueconst') {
        return this.userconst(term);
      }
      return term;
    };

    Compiler.prototype.specialsAlpha = {
      'string': function(head, exp) {
        return [head, exp];
      },
      "begin": function() {
        var exps, head, result, _i, _len;

        head = arguments[0], exps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        result = [head];
        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          e = exps[_i];
          result.push(this.alpha(e));
        }
        return result;
      },
      "nonlocal": function() {
        var head, result, vars, _i, _len;

        head = arguments[0], vars = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        result = [head];
        for (_i = 0, _len = vars.length; _i < _len; _i++) {
          name = vars[_i];
          result.push(this.env.alphaName(name));
        }
        return result;
      },
      "variable": function() {
        var head, result, vars;

        head = arguments[0], vars = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        result = [head];
        result.push((function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = vars.length; _i < _len; _i++) {
            name = vars[_i];
            _results.push(this.env.alphaName(name));
          }
          return _results;
        }).call(this));
        return result;
      },
      "assign": function(head, left, exp) {
        if (_.isString(left)) {
          left = this.env.alphaName(left);
        } else {
          left = this.alpha(left);
        }
        return [head, left, this.alpha(exp)];
      },
      "augment-assign": function(head, op, left, exp) {
        return [head, op, this.alpha(left), this.alpha(exp)];
      },
      "uniquevar": function(head, name, index) {
        return [head, this.env.uniqueName(name, index)];
      },
      "uniqueconst": function(head, name, index) {
        return [head, this.env.uniqueName(name, index)];
      },
      "jsfun": function(head, exp) {
        return [head, exp];
      },
      "direct": function(head, exp) {
        return [head, exp];
      },
      "pure": function(head, exp) {
        return [head, exp];
      },
      "effect": function(head, exp) {
        return [head, exp];
      },
      "io": function(head, exp) {
        return [head, exp];
      },
      "lambda": function() {
        var body, head, p, params, result, _i, _len;

        head = arguments[0], params = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        result = [head];
        this.pushEnv();
        result.push((function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            p = params[_i];
            _results.push(this.env.alphaName(p));
          }
          return _results;
        }).call(this));
        for (_i = 0, _len = body.length; _i < _len; _i++) {
          e = body[_i];
          result.push(this.alpha(e));
        }
        this.popEnv();
        return result;
      },
      "macro": function() {
        var bindings, body, head, p, params, result, _i, _j, _len, _len1;

        head = arguments[0], params = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        result = [head];
        this.pushEnv();
        result.push((function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = params.length; _i < _len; _i++) {
            p = params[_i];
            _results.push(this.env.alphaName(p));
          }
          return _results;
        }).call(this));
        bindings = this.env.bindings;
        for (_i = 0, _len = params.length; _i < _len; _i++) {
          p = params[_i];
          bindings[p] = ['evalarg', bindings[p]];
        }
        for (_j = 0, _len1 = body.length; _j < _len1; _j++) {
          e = body[_j];
          result.push(this.alpha(e));
        }
        this.popEnv();
        return result;
      },
      "quasiquote": function(head, exp) {
        return [head, this.alpha(exp)];
      },
      "unquote": function(head, exp) {
        return [head, this.alpha(exp)];
      },
      "unquote-slice": function(head, exp) {
        return [head, this.alpha(exp)];
      },
      'block': function() {
        var body, head, label, result, _i, _len;

        head = arguments[0], label = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        result = [head, label];
        for (_i = 0, _len = body.length; _i < _len; _i++) {
          e = body[_i];
          result.push(this.alpha(e));
        }
        return result;
      },
      'break': function(head, label, value) {
        return [head, label, this.alpha(value)];
      },
      'continue': function(head, label) {
        return [head, label];
      },
      'logicvar': function(head, name) {
        return [head, name];
      },
      'dummy': function(head, name) {
        return [head, name];
      }
    };

    Compiler.prototype.optimize = function(exp, env) {
      var expOptimize;

      expOptimize = exp != null ? exp.optimize : void 0;
      if (expOptimize) {
        return expOptimize.call(exp, env, this);
      } else {
        return exp;
      }
    };

    Compiler.prototype.toCode = function(exp) {
      var exptoCode;

      exptoCode = exp != null ? exp.toCode : void 0;
      if (exptoCode) {
        return exptoCode.call(exp, this);
      } else if (typeof exp === 'function') {
        return exp.toString();
      } else {
        return JSON.stringify(exp);
      }
    };

    return Compiler;

  })();

  Env = (function() {
    function Env() {}

    return Env;

  })();

  exports.Env = Env = (function() {
    function Env(outer, bindings) {
      this.outer = outer;
      this.bindings = bindings;
    }

    Env.prototype.extend = function(bindings) {
      if (bindings == null) {
        bindings = {};
      }
      return new this.constructor(this, bindings);
    };

    Env.prototype.lookup = function(vari) {
      var bindings, outer;

      bindings = this.bindings;
      if (bindings.hasOwnProperty(vari)) {
        return bindings[vari];
      } else {
        outer = this.outer;
        if (outer) {
          return outer.lookup(vari);
        } else {
          return vari;
        }
      }
    };

    return Env;

  })();

  CpsEnv = (function(_super) {
    __extends(CpsEnv, _super);

    function CpsEnv(outer, bindings) {
      this.outer = outer;
      this.bindings = bindings;
      if (this.outer) {
        this.indexMap = this.outer.indexMap;
        this.vars = this.outer.vars;
      } else {
        this.indexMap = {};
        this.vars = {};
      }
    }

    CpsEnv.prototype.newvar = function(vari) {
      var index, vars;

      vars = this.vars;
      index = this.indexMap[vari.name] || 2;
      while (1) {
        if (!hasOwnProperty.call(vars, vari)) {
          vars[vari] = vari;
          this.indexMap[vari.name] = index;
          return vari;
        }
        vari = new vari.constructor(vari.name, (index++).toString());
      }
    };

    CpsEnv.prototype.alphaNewName = function(name) {
      var index, newName, vars;

      vars = this.vars;
      index = this.indexMap[name] || 2;
      newName = name;
      while (1) {
        if (!hasOwnProperty.call(vars, newName)) {
          vars[name] = newName;
          this.indexMap[name] = index;
          return newName;
        }
        newName = name + index;
      }
    };

    CpsEnv.prototype.newconst = function(vari) {
      var index, vars;

      vars = this.vars;
      index = this.indexMap[vari.name] || 2;
      while (1) {
        if (!hasOwnProperty.call(vars, vari)) {
          vars[vari] = vari;
          this.indexMap[vari.name] = index;
          vari.isConst = true;
          return vari;
        }
        vari = new vari.constructor(vari.name, (index++).toString());
      }
    };

    CpsEnv.prototype.lookup = function(vari) {
      var bindings, outer;

      bindings = this.bindings;
      if (hasOwnProperty.call(bindings, vari)) {
        return bindings[vari];
      } else {
        outer = this.outer;
        if (outer) {
          return outer.lookup(vari);
        } else {
          throw new VarLookupError(vari);
        }
      }
    };

    CpsEnv.prototype.getvar = function(vari) {
      var e, v;

      try {
        return this.lookup(vari);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[vari] = v = this.newconst(vari);
          return v;
        }
      }
    };

    CpsEnv.prototype.alphaName = function(name) {
      var e;

      try {
        return name = this.lookup(name);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[name] = name = this.alphaNewName(name);
          return name;
        }
      }
    };

    CpsEnv.prototype.alphaMacroParam = function(name) {
      var e, result;

      try {
        return name = this.lookup(name);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[name] = result = ['evalarg', this.alphaNewName(name)];
          return result;
        }
      }
    };

    CpsEnv.prototype.uniqueName = function(name, index) {
      var e, uniquename, v;

      uniquename = '@' + name + index;
      try {
        return this.lookup(uniquename);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[uniquename] = v = this.alphaNewName(name);
          return v;
        }
      }
    };

    return CpsEnv;

  })(Env);

  exports.OptimizationEnv = OptimizationEnv = (function(_super) {
    __extends(OptimizationEnv, _super);

    function OptimizationEnv(outer, bindings, lamda) {
      this.outer = outer;
      this.lamda = lamda;
      if (bindings) {
        this.bindings = bindings;
      } else {
        this.bindings = outer.bindings;
      }
      if (this.outer) {
        this.indexMap = this.outer.indexMap;
        this.vars = this.outer.vars;
      } else {
        this.indexMap = {};
        this.vars = {};
      }
      if (lamda instanceof il.UserLamda) {
        this.userlamda = lamda;
      } else {
        while (outer) {
          if (outer.userlamda) {
            this.userlamda = outer.userlamda;
            return;
          }
          outer = outer.outer;
        }
      }
    }

    OptimizationEnv.prototype.extendBindings = function(bindings, lamda) {
      return new OptimizationEnv(this, bindings, lamda);
    };

    OptimizationEnv.prototype.lookup = function(vari) {
      var bindings, outer;

      bindings = this.bindings;
      if (bindings.hasOwnProperty(vari)) {
        return bindings[vari];
      } else {
        if (this.isConst) {
          outer = this.outer;
          if (outer) {
            return outer.lookup(vari);
          } else {
            return vari;
          }
        } else {
          return vari;
        }
      }
    };

    return OptimizationEnv;

  })(CpsEnv);

  exports.Error = Error = (function() {
    function Error(exp, message, stack) {
      this.exp = exp;
      this.message = message != null ? message : '';
      this.stack = stack != null ? stack : this;
    }

    Error.prototype.toString = function() {
      return "" + this.constructor.name + ": " + this.exp + " >>> " + this.message;
    };

    return Error;

  })();

  VarLookupError = (function() {
    function VarLookupError(vari) {
      this.vari = vari;
    }

    return VarLookupError;

  })();

  exports.TypeError = TypeError = (function(_super) {
    __extends(TypeError, _super);

    function TypeError() {
      _ref = TypeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TypeError;

  })(Error);

  exports.ArgumentError = ArgumentError = (function(_super) {
    __extends(ArgumentError, _super);

    function ArgumentError() {
      _ref1 = ArgumentError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ArgumentError;

  })(Error);

  exports.ArityError = ArityError = (function(_super) {
    __extends(ArityError, _super);

    function ArityError() {
      _ref2 = ArityError.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return ArityError;

  })(Error);

}).call(this);

/*
//@ sourceMappingURL=core.map
*/
