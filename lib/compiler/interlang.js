// Generated by CoffeeScript 1.6.2
(function() {
  var Apply, Assign, AugmentAssign, Begin, BinaryOperation, Break, Clamda, Continue, Deref, DoWhile, Element, Env, ExpressionList, For, ForIn, ForOf, Fun, IO, IdCont, If, InternalLocalVar, InternalNonlocalVar, InternalVar, JSFun, LabelStatement, Lamda, LocalDecl, MAX_EXTEND_CODE_SIZE, New, NonlocalDecl, NotImplement, Print, RecursiveClamda, Return, Symbol, Throw, TopBegin, Try, UnaryOperation, UserLamda, UserLocalVar, UserNonlocalVar, UserVar, Var, VirtualOperation, While, applySideEffect, augmentAssign, augmentOperators, begin, binary, boolize, codeSize, core, expressionToCode, expsEffect, hasOwnProperty, il, insertReturn, isAtomic, isDeclaration, isEmpty, isJsified, isStatement, isValue, jsify, optimize, pure, replace, setJsified, sideEffect, solve, toString, unary, varattr, vari, vop, vop2, _, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require("underscore");

  _ref = core = require("./core"), Env = _ref.Env, solve = _ref.solve;

  il = exports;

  exports.NotImplement = NotImplement = (function(_super) {
    __extends(NotImplement, _super);

    function NotImplement(exp, message, stack) {
      this.exp = exp;
      this.message = message != null ? message : '';
      this.stack = stack != null ? stack : this;
    }

    NotImplement.prototype.toString = function() {
      return "" + this.name + " >>> " + this.exp + " " + this.message;
    };

    return NotImplement;

  })(Error);

  toString = function(o) {
    return (o != null ? typeof o.toString === "function" ? o.toString() : void 0 : void 0) || o;
  };

  expressionToCode = function(compiler, exp) {
    if (exp instanceof Var || _.isString(exp) || _.isNumber(exp) || _.isArray(exp) || exp instanceof VirtualOperation && (exp.name === 'attr' || exp.name === 'index')) {
      return compiler.toCode(exp);
    } else {
      return "(" + (compiler.toCode(exp)) + ")";
    }
  };

  Element = (function() {
    function Element() {
      this.name = this.toString();
    }

    Element.prototype.call = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Apply(this, args);
    };

    Element.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    Element.prototype.toCode = function(compiler) {
      throw new NotImplement(this, "toCode");
    };

    Element.prototype.isValue = function() {
      return false;
    };

    Object.defineProperty(Element.prototype, '$', {
      get: function() {
        return this.constructor;
      }
    });

    return Element;

  })();

  Var = (function(_super) {
    __extends(Var, _super);

    function Var(name, suffix) {
      this.name = name;
      this.suffix = suffix != null ? suffix : '';
    }

    Var.prototype.toString = function() {
      return this.name + this.suffix;
    };

    Var.prototype.isValue = function() {
      return this.isConst;
    };

    return Var;

  })(Element);

  UserVar = (function(_super) {
    __extends(UserVar, _super);

    function UserVar() {
      _ref1 = UserVar.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return UserVar;

  })(Var);

  UserLocalVar = (function(_super) {
    __extends(UserLocalVar, _super);

    function UserLocalVar() {
      _ref2 = UserLocalVar.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return UserLocalVar;

  })(UserVar);

  UserNonlocalVar = (function(_super) {
    __extends(UserNonlocalVar, _super);

    function UserNonlocalVar() {
      _ref3 = UserNonlocalVar.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return UserNonlocalVar;

  })(UserVar);

  InternalVar = (function(_super) {
    __extends(InternalVar, _super);

    function InternalVar() {
      _ref4 = InternalVar.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    return InternalVar;

  })(Var);

  InternalLocalVar = (function(_super) {
    __extends(InternalLocalVar, _super);

    function InternalLocalVar() {
      _ref5 = InternalLocalVar.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    return InternalLocalVar;

  })(InternalVar);

  InternalNonlocalVar = (function(_super) {
    __extends(InternalNonlocalVar, _super);

    function InternalNonlocalVar() {
      _ref6 = InternalNonlocalVar.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    return InternalNonlocalVar;

  })(InternalVar);

  Symbol = (function(_super) {
    __extends(Symbol, _super);

    function Symbol() {
      _ref7 = Symbol.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    return Symbol;

  })(Var);

  LocalDecl = (function(_super) {
    __extends(LocalDecl, _super);

    function LocalDecl(vars) {
      this.vars = vars;
      LocalDecl.__super__.constructor.apply(this, arguments);
    }

    LocalDecl.prototype.toString = function() {
      return "localDecl(" + this.vars;
    };

    LocalDecl.prototype.isDeclaration = function() {
      return true;
    };

    return LocalDecl;

  })(Element);

  NonlocalDecl = (function(_super) {
    __extends(NonlocalDecl, _super);

    function NonlocalDecl() {
      _ref8 = NonlocalDecl.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    NonlocalDecl.prototype.toString = function() {
      return "nonlocalDecl(" + this.vars;
    };

    return NonlocalDecl;

  })(LocalDecl);

  Assign = (function(_super) {
    __extends(Assign, _super);

    function Assign(left, exp) {
      this.left = left;
      this.exp = exp;
      Assign.__super__.constructor.apply(this, arguments);
      this.dependency = [];
    }

    Assign.prototype.toString = function() {
      return "" + (toString(this.left)) + " = " + (toString(this.exp));
    };

    Assign.prototype.remove = function() {
      return this._removed = true;
    };

    Assign.prototype.dont_remove = function() {
      return this._removed = false;
    };

    Assign.prototype.removed = function() {
      var item, _i, _len, _ref9;

      if (this._removed === true) {
        return true;
      } else if (this._removed === false) {
        return false;
      } else {
        _ref9 = this.dependency;
        for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
          item = _ref9[_i];
          if (item.removed() === false) {
            return false;
          }
        }
        return true;
      }
    };

    return Assign;

  })(Element);

  AugmentAssign = (function(_super) {
    __extends(AugmentAssign, _super);

    function AugmentAssign() {
      _ref9 = AugmentAssign.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    AugmentAssign.prototype.toString = function() {
      return "" + (toString(this.left)) + " " + this.operator + " " + (toString(this.exp));
    };

    return AugmentAssign;

  })(Assign);

  Return = (function(_super) {
    __extends(Return, _super);

    function Return(value) {
      this.value = value;
      Return.__super__.constructor.apply(this, arguments);
    }

    Return.prototype.toString = function() {
      return "return(" + (toString(this.value)) + ")";
    };

    return Return;

  })(Element);

  New = (function(_super) {
    __extends(New, _super);

    function New() {
      _ref10 = New.__super__.constructor.apply(this, arguments);
      return _ref10;
    }

    New.prototype.toString = function() {
      return "new(" + (toString(this.value)) + ")";
    };

    return New;

  })(Return);

  Throw = (function(_super) {
    __extends(Throw, _super);

    function Throw() {
      _ref11 = Throw.__super__.constructor.apply(this, arguments);
      return _ref11;
    }

    Throw.prototype.toString = function() {
      return "throw(" + (toString(this.value)) + ")";
    };

    return Throw;

  })(Return);

  Begin = (function(_super) {
    __extends(Begin, _super);

    function Begin(exps) {
      this.exps = exps;
      Begin.__super__.constructor.apply(this, arguments);
    }

    Begin.prototype.toString = function() {
      var e;

      return "begin(" + (((function() {
        var _i, _len, _ref12, _results;

        _ref12 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref12.length; _i < _len; _i++) {
          e = _ref12[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    return Begin;

  })(Element);

  ExpressionList = (function(_super) {
    __extends(ExpressionList, _super);

    function ExpressionList(exps) {
      this.exps = exps;
      ExpressionList.__super__.constructor.apply(this, arguments);
    }

    ExpressionList.prototype.toString = function() {
      var e;

      return "exprlist(" + (((function() {
        var _i, _len, _ref12, _results;

        _ref12 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref12.length; _i < _len; _i++) {
          e = _ref12[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    return ExpressionList;

  })(Begin);

  TopBegin = (function(_super) {
    __extends(TopBegin, _super);

    function TopBegin() {
      _ref12 = TopBegin.__super__.constructor.apply(this, arguments);
      return _ref12;
    }

    TopBegin.prototype.toString = function() {
      var e;

      return "topbegin(" + (((function() {
        var _i, _len, _ref13, _results;

        _ref13 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref13.length; _i < _len; _i++) {
          e = _ref13[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    return TopBegin;

  })(Begin);

  Print = (function(_super) {
    __extends(Print, _super);

    function Print() {
      _ref13 = Print.__super__.constructor.apply(this, arguments);
      return _ref13;
    }

    Print.prototype.toString = function() {
      var e;

      return "print(" + (((function() {
        var _i, _len, _ref14, _results;

        _ref14 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
          e = _ref14[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    return Print;

  })(Begin);

  Lamda = (function(_super) {
    __extends(Lamda, _super);

    function Lamda(params, body) {
      this.params = params;
      this.body = body;
      Lamda.__super__.constructor.apply(this, arguments);
    }

    Lamda.prototype.toString = function() {
      var e;

      return "(" + (((function() {
        var _i, _len, _ref14, _results;

        _ref14 = this.params;
        _results = [];
        for (_i = 0, _len = _ref14.length; _i < _len; _i++) {
          e = _ref14[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(', ')) + " -> " + (toString(this.body)) + ")";
    };

    Lamda.prototype.call = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Apply(this, args);
    };

    Lamda.prototype.isValue = function() {
      return true;
    };

    Lamda.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    return Lamda;

  })(Element);

  UserLamda = (function(_super) {
    __extends(UserLamda, _super);

    function UserLamda() {
      _ref14 = UserLamda.__super__.constructor.apply(this, arguments);
      return _ref14;
    }

    return UserLamda;

  })(Lamda);

  Clamda = (function(_super) {
    __extends(Clamda, _super);

    function Clamda(v, body) {
      this.v = v;
      this.body = body;
      this.name = this.toString();
    }

    Clamda.prototype.toString = function() {
      return "(" + (toString(this.v)) + " -> " + (toString(this.body)) + ")";
    };

    Clamda.prototype.call = function(value) {
      var result;

      result = replace(this.body, this.v.toString(), value);
      if (result.constructor === TopBegin) {
        result.constructor = Begin;
      }
      return result;
    };

    return Clamda;

  })(Lamda);

  RecursiveClamda = (function(_super) {
    __extends(RecursiveClamda, _super);

    function RecursiveClamda() {
      _ref15 = RecursiveClamda.__super__.constructor.apply(this, arguments);
      return _ref15;
    }

    RecursiveClamda.prototype.call = function(value) {
      return new CApply(this, value);
    };

    return RecursiveClamda;

  })(Clamda);

  IdCont = (function(_super) {
    __extends(IdCont, _super);

    function IdCont() {
      _ref16 = IdCont.__super__.constructor.apply(this, arguments);
      return _ref16;
    }

    return IdCont;

  })(Clamda);

  JSFun = (function(_super) {
    __extends(JSFun, _super);

    function JSFun(fun) {
      this.fun = fun;
      JSFun.__super__.constructor.apply(this, arguments);
    }

    JSFun.prototype.toString = function() {
      return "jsfun(" + this.fun + ")";
    };

    JSFun.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    return JSFun;

  })(Element);

  exports.VirtualOperation = VirtualOperation = (function(_super) {
    __extends(VirtualOperation, _super);

    function VirtualOperation(args) {
      this.args = args;
      VirtualOperation.__super__.constructor.apply(this, arguments);
    }

    VirtualOperation.prototype.toString = function() {
      var arg;

      return "vop_" + this._name + "(" + (((function() {
        var _i, _len, _ref17, _results;

        _ref17 = this.args;
        _results = [];
        for (_i = 0, _len = _ref17.length; _i < _len; _i++) {
          arg = _ref17[_i];
          _results.push(toString(arg));
        }
        return _results;
      }).call(this)).join(', ')) + ")";
    };

    return VirtualOperation;

  })(Element);

  BinaryOperation = (function(_super) {
    __extends(BinaryOperation, _super);

    function BinaryOperation() {
      _ref17 = BinaryOperation.__super__.constructor.apply(this, arguments);
      return _ref17;
    }

    BinaryOperation.prototype.toString = function() {
      return "" + (toString(this.args[0])) + this.symbol + (toString(this.args[1]));
    };

    BinaryOperation.prototype._effect = false;

    return BinaryOperation;

  })(VirtualOperation);

  UnaryOperation = (function(_super) {
    __extends(UnaryOperation, _super);

    function UnaryOperation() {
      _ref18 = UnaryOperation.__super__.constructor.apply(this, arguments);
      return _ref18;
    }

    UnaryOperation.prototype.toString = function() {
      return "" + this.symbol + (toString(this.args[0]));
    };

    UnaryOperation.prototype._effect = false;

    return UnaryOperation;

  })(BinaryOperation);

  Fun = (function(_super) {
    __extends(Fun, _super);

    function Fun(func) {
      this.func = func;
      Fun.__super__.constructor.apply(this, arguments);
    }

    Fun.prototype.toString = function() {
      return "fun(" + this.func + ")";
    };

    Fun.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    return Fun;

  })(Element);

  Apply = (function(_super) {
    __extends(Apply, _super);

    function Apply(caller, args) {
      this.caller = caller;
      this.args = args;
      Apply.__super__.constructor.apply(this, arguments);
    }

    Apply.prototype.toString = function() {
      var arg;

      return "(" + (toString(this.caller)) + ")(" + (((function() {
        var _i, _len, _ref19, _results;

        _ref19 = this.args;
        _results = [];
        for (_i = 0, _len = _ref19.length; _i < _len; _i++) {
          arg = _ref19[_i];
          _results.push(toString(arg));
        }
        return _results;
      }).call(this)).join(', ')) + ")";
    };

    return Apply;

  })(Element);

  Deref = (function(_super) {
    __extends(Deref, _super);

    function Deref(exp) {
      this.exp = exp;
      Deref.__super__.constructor.apply(this, arguments);
    }

    Deref.prototype.toString = function() {
      return "deref(" + (toString(this.exp)) + ")";
    };

    return Deref;

  })(Element);

  If = (function(_super) {
    __extends(If, _super);

    function If(test, then_, else_) {
      this.test = test;
      this.then_ = then_;
      this.else_ = else_;
      If.__super__.constructor.apply(this, arguments);
    }

    If.prototype.toString = function() {
      return "if(" + (toString(this.test)) + ", " + (toString(this.then_)) + ", " + (toString(this.else_)) + ")";
    };

    return If;

  })(Element);

  LabelStatement = (function(_super) {
    __extends(LabelStatement, _super);

    function LabelStatement(label, statement) {
      this.label = label;
      this.statement = statement;
      LabelStatement.__super__.constructor.apply(this, arguments);
    }

    LabelStatement.prototype.toString = function() {
      return "" + (toString(this.label)) + ": " + (toString(this.statement));
    };

    return LabelStatement;

  })(Element);

  While = (function(_super) {
    __extends(While, _super);

    function While(test, body) {
      this.test = test;
      this.body = body;
      While.__super__.constructor.apply(this, arguments);
    }

    While.prototype.toString = function() {
      return "while(" + (toString(this.test)) + ", " + (toString(this.body)) + ")";
    };

    return While;

  })(Element);

  DoWhile = (function(_super) {
    __extends(DoWhile, _super);

    function DoWhile(test, body) {
      this.test = test;
      this.body = body;
      DoWhile.__super__.constructor.apply(this, arguments);
    }

    DoWhile.prototype.toString = function() {
      return "dowhile(" + (toString(this.test)) + ", " + (toString(this.body)) + ")";
    };

    return DoWhile;

  })(While);

  For = (function(_super) {
    __extends(For, _super);

    function For(init, test, step, body) {
      this.init = init;
      this.test = test;
      this.step = step;
      this.body = body;
      For.__super__.constructor.apply(this, arguments);
    }

    For.prototype.toString = function() {
      return "for(" + (toString(this.test)) + ", " + (toString(this.body)) + ")";
    };

    return For;

  })(Element);

  ForIn = (function(_super) {
    __extends(ForIn, _super);

    function ForIn(vari, container, body) {
      this.vari = vari;
      this.container = container;
      this.body = body;
      ForIn.__super__.constructor.apply(this, arguments);
    }

    ForIn.prototype.toString = function() {
      return "forin(" + (toString(this.vari)) + ", " + (toString(this.container)) + ", " + (toString(this.body)) + ")";
    };

    return ForIn;

  })(Element);

  ForOf = (function(_super) {
    __extends(ForOf, _super);

    function ForOf(vari, container, body) {
      this.vari = vari;
      this.container = container;
      this.body = body;
      ForOf.__super__.constructor.apply(this, arguments);
    }

    ForOf.prototype.toString = function() {
      return "forof(" + (toString(this.vari)) + ", " + (toString(this.container)) + ", " + (toString(this.body)) + ")";
    };

    return ForOf;

  })(Element);

  Break = (function(_super) {
    __extends(Break, _super);

    function Break(label) {
      this.label = label;
      Break.__super__.constructor.apply(this, arguments);
    }

    Break.prototype.toString = function() {
      return "break " + (toString(this.label));
    };

    return Break;

  })(Element);

  Continue = (function(_super) {
    __extends(Continue, _super);

    function Continue() {
      _ref19 = Continue.__super__.constructor.apply(this, arguments);
      return _ref19;
    }

    Continue.prototype.toString = function() {
      return "continue " + (toString(this.label));
    };

    return Continue;

  })(Break);

  Try = (function(_super) {
    __extends(Try, _super);

    function Try(test, catches, final) {
      this.test = test;
      this.catches = catches;
      this.final = final;
      Try.__super__.constructor.apply(this, arguments);
    }

    Try.prototype.toString = function() {
      return "try(" + (toString(this.test)) + ", " + (toString(this.catches)) + ", " + (toString(this.final)) + ")";
    };

    return Try;

  })(Element);

  replace = function(exp, param, value) {
    var exp_replace;

    exp_replace = exp != null ? exp.replace : void 0;
    if (exp_replace) {
      return exp_replace.call(exp, param, value);
    } else {
      return exp;
    }
  };

  Var.prototype.replace = function(param, value) {
    if (this.toString() === param) {
      return value;
    } else {
      return this;
    }
  };

  Assign.prototype.replace = function(param, value) {
    return new this.constructor(this.left, replace(this.exp, param, value));
  };

  If.prototype.replace = function(param, value) {
    return new If(replace(this.test, param, value), replace(this.then_, param, value), replace(this.else_, param, value));
  };

  LabelStatement.prototype.replace = function(param, value) {
    return new LabelStatement(this.label, replace(this.statement, param, value));
  };

  While.prototype.replace = function(param, value) {
    return new While(replace(this.test, param, value), replace(this.body, param, value));
  };

  For.prototype.replace = function(param, value) {
    return new For(replace(this.init, param, value), replace(this.test, param, value), replace(this.step, param, value), replace(this.body, param, value));
  };

  ForIn.prototype.replace = function(param, value) {
    return new ForIn(replace(this.vari, param, value), replace(this.container, param, value), replace(this.body, param, value));
  };

  Break.prototype.replace = function(param, value) {
    return this;
  };

  Try.prototype.replace = function(param, value) {
    var catches, clause;

    catches = (function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.catches;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        clause = _ref20[_i];
        _results.push([replace(clause[0], param, value), replace(clause[1], param, value)]);
      }
      return _results;
    }).call(this);
    return new Try(replace(this.test, param, value), replace(catches, param, value), replace(this.final, param, value));
  };

  Return.prototype.replace = function(param, value) {
    return new this.constructor(replace(this.value, param, value));
  };

  Lamda.prototype.replace = function(param, value) {
    return this;
  };

  Clamda.prototype.replace = function(param, value) {
    return this;
  };

  IdCont.prototype.replace = function(param, value) {
    return this;
  };

  Apply.prototype.replace = function(param, value) {
    var a;

    return new Apply(replace(this.caller, param, value), (function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.args;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        a = _ref20[_i];
        _results.push(replace(a, param, value));
      }
      return _results;
    }).call(this));
  };

  VirtualOperation.prototype.replace = function(param, value) {
    var a;

    return new this.constructor((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.args;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        a = _ref20[_i];
        _results.push(replace(a, param, value));
      }
      return _results;
    }).call(this));
  };

  Begin.prototype.replace = function(param, value) {
    var exp;

    return new this.constructor((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.exps;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        exp = _ref20[_i];
        _results.push(replace(exp, param, value));
      }
      return _results;
    }).call(this));
  };

  Deref.prototype.replace = function(param, value) {
    return new Deref(value.replace(this.exp, param));
  };

  JSFun.prototype.replace = function(param, value) {
    return new JSFun(replace(this.fun, param, value));
  };

  optimize = function(exp, env, compiler) {
    var exp_optimize;

    exp_optimize = exp != null ? exp.optimize : void 0;
    if (exp_optimize) {
      return exp_optimize.call(exp, env, compiler);
    } else {
      return exp;
    }
  };

  Var.prototype.optimize = function(env, compiler) {
    var content, envExp, outerEnv;

    if (this.isRecursive) {
      return this;
    }
    outerEnv = env.outer;
    if (outerEnv) {
      envExp = outerEnv.lookup(this);
      if (envExp instanceof Assign) {
        envExp._removed = false;
      }
    }
    content = env.lookup(this);
    if (content instanceof Assign) {
      if (this.isRecursive) {
        return this;
      } else {
        return content.exp;
      }
    } else if (_.isArray(content)) {
      return this;
    } else {
      return content;
    }
  };

  Symbol.prototype.optimize = function(env, compiler) {
    return this;
  };

  Assign.prototype.optimize = function(env, compiler) {
    var a, assign, exp, left, locals, _ref20, _ref21, _ref22, _ref23;

    left = this.left;
    if (left instanceof VirtualOperation) {
      left = new left.constructor((function() {
        var _i, _len, _ref20, _results;

        _ref20 = left.args;
        _results = [];
        for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
          a = _ref20[_i];
          _results.push(compiler.optimize(a, env));
        }
        return _results;
      })());
    } else {
      if (left.isConst) {
        if (left.haveAssigned) {
          throw Error(this, "should not assign to const more than once.");
        } else {
          left.haveAssigned = true;
        }
      }
      if (left instanceof UserLocalVar) {
        locals = (_ref20 = env.userlamda) != null ? _ref20.locals : void 0;
        if (locals) {
          if (locals[left] != null) {
            locals[left]++;
          } else {
            locals[left] = 1;
          }
        }
      } else if (left instanceof UserNonlocalVar) {
        if ((_ref21 = env.userlamda) != null) {
          _ref21.nonlocals[left] = left;
        }
        this._removed = false;
      } else if (left instanceof InternalLocalVar) {
        if ((_ref22 = env.lamda) != null) {
          _ref22.locals[left] = left;
        }
      } else if (left instanceof InternalNonlocalVar) {
        if ((_ref23 = env.lamda) != null) {
          _ref23.nonlocals[left] = left;
        }
      }
    }
    exp = compiler.optimize(this.exp, env);
    assign = new this.constructor(left, exp);
    if (isValue(exp)) {
      if (exp instanceof Lamda && left.isRecursive) {
        env.bindings[left] = left;
        assign._removed = false;
      } else if (!isAtomic(exp)) {
        env.bindings[left] = left;
        assign._removed = false;
      } else if (left instanceof VirtualOperation) {
        assign._removed = false;
      } else {
        env.bindings[left] = assign;
      }
    } else {
      env.bindings[left] = left;
      assign._removed = false;
    }
    return assign;
  };

  LocalDecl.prototype.optimize = function(env, compiler) {
    var vari, _i, _len, _ref20;

    _ref20 = this.vars;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      vari = _ref20[_i];
      if (vari instanceof UserVar) {
        env.userlamda.locals[vari] = vari;
      } else {
        env.lamda.locals[vari] = vari;
      }
    }
    return null;
  };

  NonlocalDecl.prototype.optimize = function(env, compiler) {
    var vari, _i, _len, _ref20;

    _ref20 = this.vars;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      vari = _ref20[_i];
      if (vari instanceof UserVar) {
        env.userlamda.nonlocals[vari] = vari;
      } else {
        env.lamda.nonlocals[vari] = vari;
      }
    }
    return null;
  };

  If.prototype.optimize = function(env, compiler) {
    var else_, test, test_bool, then_;

    test = optimize(this.test, env, compiler);
    test_bool = boolize(test);
    if (test_bool === true) {
      then_ = optimize(this.then_, env, compiler);
      if (then_ instanceof If && then_.test === test) {
        then_ = then_.then_;
      }
      return then_;
    } else if (test_bool === false) {
      else_ = optimize(this.else_, env, compiler);
      if (else_ instanceof If && else_.test === test) {
        else_ = else_.else_;
      }
      return else_;
    } else {
      then_ = optimize(this.then_, env, compiler);
      else_ = optimize(this.else_, env, compiler);
      if (then_ instanceof If && then_.test === test) {
        then_ = then_.then_;
      }
      if (else_ instanceof If && else_.test === test) {
        else_ = else_.else_;
      }
      return new If(test, then_, else_);
    }
  };

  LabelStatement.prototype.optimize = function(env, compiler) {
    return new LabelStatement(this.label, optimize(this.statement, env, compiler));
  };

  While.prototype.optimize = function(env, compiler) {
    var test;

    test = optimize(this.test, env, compiler);
    return new While(test, this.body);
  };

  For.prototype.optimize = function(env, compiler) {
    var body, init, step, test;

    init = optimize(this.init, env, compiler);
    test = optimize(this.test, env, compiler);
    step = optimize(this.step, env, compiler);
    body = optimize(this.body, env, compiler);
    return new For(init, test, step, body);
  };

  ForIn.prototype.optimize = function(env, compiler) {
    var test;

    return new ForIn(optimize(this.vari, env, compiler), test = optimize(container, env, compiler), optimize(this.body, env, compiler));
  };

  Break.prototype.optimize = function(env, compiler) {
    return this;
  };

  Try.prototype.optimize = function(env, compiler) {
    var test;

    test = optimize(this.test, env, compiler);
    return new Try(test, this.catches, this.final);
  };

  Return.prototype.optimize = function(env, compiler) {
    env.lamda.haveReturn = true;
    return new Return(compiler.optimize(this.value, env));
  };

  Throw.prototype.optimize = function(env, compiler) {
    return new Throw(compiler.optimize(this.value, env));
  };

  New.prototype.optimize = function(env, compiler) {
    return new New(compiler.optimize(this.value, env));
  };

  Lamda.prototype.optimize = function(env, compiler) {
    var bindings, body, envBindings, k, p, v, _i, _len, _ref20;

    if (this._optimized) {
      return this;
    }
    envBindings = env.bindings;
    for (k in envBindings) {
      v = envBindings[k];
      if (hasOwnProperty.call(envBindings, k) && v instanceof Assign) {
        v._removed = false;
      }
    }
    bindings = {};
    _ref20 = this.params;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      p = _ref20[_i];
      bindings[p] = p;
    }
    this.locals = {};
    this.nonlocals = {};
    env = env.extendBindings(bindings, this);
    body = compiler.optimize(this.body, env);
    this.body = jsify(body, compiler, env);
    this._jsified = true;
    this._optimized = true;
    return this;
  };

  UserLamda.prototype.optimize = function(env, compiler) {
    var bindings, body, p, _i, _len, _ref20;

    if (this._optimized) {
      return this;
    }
    bindings = {};
    _ref20 = this.params;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      p = _ref20[_i];
      bindings[p] = p;
    }
    this.locals = {};
    this.nonlocals = {};
    env = env.extendBindings(bindings, this, this);
    body = compiler.optimize(this.body, env);
    this.body = jsify(body, compiler, env);
    this._jsified = true;
    this._optimized = true;
    return this;
  };

  Clamda.prototype.optimize = function(env, compiler) {
    var bindings, body, envBindings, k, v;

    if (this._optimized) {
      return this;
    }
    envBindings = env.bindings;
    for (k in envBindings) {
      v = envBindings[k];
      if (hasOwnProperty.call(envBindings, k) && v instanceof Assign) {
        v._removed = false;
      }
    }
    bindings = {};
    bindings[this.v] = this.v;
    this.locals = {};
    this.nonlocals = {};
    env = env.extendBindings(bindings, this);
    body = compiler.optimize(this.body, env);
    this.body = jsify(body, compiler, env);
    this._jsified = true;
    this._optimized = true;
    return this;
  };

  IdCont.prototype.optimize = function(env, compiler) {
    return this;
  };

  Apply.prototype.optimize = function(env, compiler) {
    var a, caller;

    caller = compiler.optimize(this.caller, env);
    return (typeof caller.optimizeApply === "function" ? caller.optimizeApply(this.args, env, compiler) : void 0) || new Apply(caller, (function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.args;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        a = _ref20[_i];
        _results.push(compiler.optimize(a, env));
      }
      return _results;
    }).call(this));
  };

  VirtualOperation.prototype.optimize = function(env, compiler) {
    var a, args, _i, _isValue, _len;

    args = (function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.args;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        a = _ref20[_i];
        _results.push(compiler.optimize(a, env));
      }
      return _results;
    }).call(this);
    _isValue = true;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      if (!isValue(a)) {
        _isValue = false;
        break;
      }
    }
    if (_isValue && this.func) {
      return this.func.apply(null, args);
    } else {
      return new this.constructor(args);
    }
  };

  Begin.prototype.optimize = function(env, compiler) {
    var e, exp, exps, result, waitPop, _i, _len, _ref20;

    result = [];
    waitPop = false;
    _ref20 = this.exps;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      exp = _ref20[_i];
      e = compiler.optimize(exp, env);
      if (isDeclaration(e)) {
        continue;
      }
      if (waitPop) {
        result.pop();
      }
      if (e instanceof Begin) {
        exps = e.exps;
        result = result.concat(exps);
        waitPop = sideEffect(result[result.length - 1]) === il.PURE;
      } else {
        result.push(e);
        waitPop = sideEffect(e) === il.PURE;
      }
    }
    if (result.length > 1) {
      return new this.constructor(result);
    } else {
      return result[0];
    }
  };

  Deref.prototype.optimize = function(env, compiler) {
    var exp;

    exp = this.exp;
    if (_.isString(exp)) {
      return exp;
    } else if (_.isNumber(exp)) {
      return exp;
    } else {
      return new Deref(compiler.optimize(exp, env));
    }
  };

  JSFun.prototype.optimize = function(env, compiler) {
    return new JSFun(compiler.optimize(this.fun, env));
  };

  Lamda.prototype.optimizeApply = function(args, env, compiler) {
    var body, exps, i, p;

    exps = (function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.params;
      _results = [];
      for (i = _i = 0, _len = _ref20.length; _i < _len; i = ++_i) {
        p = _ref20[i];
        _results.push(il.assign(p, args[i]));
      }
      return _results;
    }).call(this);
    exps.push(this.body);
    body = compiler.optimize(il.topbegin.apply(il, exps), env);
    if (!isStatement(body)) {
      return body;
    } else {
      return new Apply(new Lamda([], body), []);
    }
  };

  Clamda.prototype.optimizeApply = function(args, env, compiler) {
    return il.begin(il.assign(this.v, args[0]), this.body).optimize(env, compiler);
  };

  RecursiveClamda.prototype.optimizeApply = function(args, env, compiler) {
    return il.begin(il.assign(this.v, args[0]), this.body).optimize(env, compiler);
  };

  IdCont.prototype.optimizeApply = function(args, env, compiler) {
    return compiler.optimize(args[0], env);
  };

  JSFun.prototype.optimizeApply = function(args, env, compiler) {
    var a, f, t;

    args = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        a = args[_i];
        _results.push(compiler.optimize(a, env));
      }
      return _results;
    })();
    f = this.fun;
    t = typeof f;
    if (t === 'function') {
      return new Apply(f, args);
    } else if (t === 'string') {
      return new Apply(il.fun(f), args);
    } else {
      return f.apply(args).optimize(env, compiler);
    }
  };

  MAX_EXTEND_CODE_SIZE = 10;

  hasOwnProperty = Object.prototype.hasOwnProperty;

  isEmpty = function(obj) {
    var key;

    for (key in obj) {
      if (hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };

  codeSize = function(exp) {
    var exp_codeSize;

    exp_codeSize = exp != null ? exp.codeSize : void 0;
    if (exp_codeSize) {
      return exp_codeSize.call(exp);
    } else {
      return 1;
    }
  };

  Var.prototype.codeSize = function() {
    return 1;
  };

  Return.prototype.codeSize = function() {
    return codeSize(this.value) + 1;
  };

  If.prototype.codeSize = function() {
    return codeSize(this.test) + codeSize(this.then_) + codeSize(this.else_) + 1;
  };

  LabelStatement.prototype.codeSize = function() {
    return codeSize(this.statement);
  };

  For.prototype.codeSize = function() {
    return codeSize(this.init) + codeSize(this.test) + codeSize(this.step) + codeSize(this.body) + 2;
  };

  ForIn.prototype.codeSize = function() {
    return codeSize(this.vari) + codeSize(this.container) + codeSize(this.body) + 2;
  };

  While.prototype.codeSize = function() {
    return codeSize(this.test) + codeSize(this.body) + 2;
  };

  Break.prototype.codeSize = function() {
    return 1;
  };

  Try.prototype.codeSize = function() {
    return codeSize(this.test) + codeSize(this.catches) + codeSize(this.final) + 2;
  };

  Begin.prototype.codeSize = function() {
    return _.reduce(this.exps, (function(memo, e) {
      return memo + codeSize(e);
    }), 0);
  };

  VirtualOperation.prototype.codeSize = function() {
    return 1;
  };

  Lamda.prototype.codeSize = function() {
    return codeSize(this.body) + 2;
  };

  Clamda.prototype.codeSize = function() {
    return codeSize(this.body) + 1;
  };

  Apply.prototype.codeSize = function() {
    return _.reduce(this.args, (function(memo, e) {
      return memo + codeSize(e);
    }), codeSize(this.caller));
  };

  boolize = function(exp) {
    var exp_boolize;

    exp_boolize = exp != null ? exp.boolize : void 0;
    if (exp_boolize) {
      return exp_boolize.call(exp);
    } else {
      return !!exp;
    }
  };

  Var.prototype.boolize = function() {
    return void 0;
  };

  Return.prototype.boolize = function() {
    return boolize(this.value);
  };

  If.prototype.boolize = function() {
    var b;

    b = boolize(this.test);
    if (b === void 0) {
      void 0;
    }
    if (b === true) {
      return boolize(this.then_);
    } else {
      return boolize(this.else_);
    }
  };

  LabelStatement.prototype.boolize = function() {
    return boolize(this.statement);
  };

  For.prototype.boolize = function() {
    return void 0;
  };

  ForIn.prototype.boolize = function() {
    return void 0;
  };

  While.prototype.boolize = function() {
    return void 0;
  };

  Try.prototype.boolize = function() {
    return void 0;
  };

  Break.prototype.boolize = function() {
    return void 0;
  };

  Begin.prototype.boolize = function() {
    var exps;

    exps = this.exps;
    return boolize(exps[exps.length - 1]);
  };

  VirtualOperation.prototype.boolize = function() {
    var a, _i, _len, _ref20, _ref21;

    _ref20 = this.args;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      a = _ref20[_i];
      if (boolize(a) === void 0) {
        return void 0;
      }
    }
    return !!((_ref21 = this.func) != null ? _ref21.apply(null, this.args) : void 0) || void 0;
  };

  Lamda.prototype.boolize = function() {
    return true;
  };

  Clamda.prototype.boolize = function() {
    return true;
  };

  Apply.prototype.boolize = function() {
    var a, caller, _i, _len, _ref20, _ref21;

    caller = this.caller;
    if (caller instanceof Lamda || caller instanceof Clamda) {
      return boolize(caller.body);
    }
    if (caller instanceof Var) {
      return void 0;
    }
    _ref20 = this.args;
    for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
      a = _ref20[_i];
      if (boolize(a) === void 0) {
        return void 0;
      }
    }
    return !!((_ref21 = caller.func) != null ? _ref21.apply(null, this.args) : void 0) || void 0;
  };

  isDeclaration = function(exp) {
    var exp_isDeclaration;

    exp_isDeclaration = exp != null ? exp.isDeclaration : void 0;
    if (exp_isDeclaration) {
      return exp_isDeclaration.call(exp);
    } else {
      return false;
    }
  };

  isValue = function(exp) {
    var exp_isValue;

    exp_isValue = exp != null ? exp.isValue : void 0;
    if (exp_isValue) {
      return exp_isValue.call(exp);
    } else {
      return true;
    }
  };

  isAtomic = function(exp) {
    return !_.isObject(exp);
  };

  il.PURE = 0;

  il.EFFECT = 1;

  il.IO = 2;

  il.pure = pure = function(exp) {
    exp._effect = il.PURE;
    return exp;
  };

  il.effect = function(exp) {
    exp._effect = il.EFFECT;
    return exp;
  };

  il.io = function(exp) {
    exp._effect = il.IO;
    return exp;
  };

  sideEffect = function(exp) {
    var exp_sideEffect;

    exp_sideEffect = exp != null ? exp.sideEffect : void 0;
    if (exp_sideEffect) {
      return exp_sideEffect.call(exp);
    } else {
      return il.PURE;
    }
  };

  expsEffect = function(exps) {
    var e, eff, effect, _i, _len;

    effect = il.PURE;
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      eff = sideEffect(e);
      if (eff === il.IO) {
        return il.IO;
      }
      if (eff === il.EFFECT) {
        effect = eff;
      }
    }
    return effect;
  };

  Element.prototype.sideEffect = function() {
    return il.IO;
  };

  Var.prototype.sideEffect = function() {
    return il.PURE;
  };

  NonlocalDecl.prototype.sideEffect = function() {
    return il.PURE;
  };

  Assign.prototype.sideEffect = function() {
    return il.EFFECT;
  };

  Return.prototype.sideEffect = function() {
    return sideEffect(this.value);
  };

  Throw.prototype.sideEffect = function() {
    return il.IO;
  };

  New.prototype.sideEffect = function() {
    return sideEffect(this.value);
  };

  If.prototype.sideEffect = function() {
    return expsEffect([this.test, this.then_, this.else_]);
  };

  LabelStatement.prototype.sideEffect = function() {
    return sideEffect(this.statement);
  };

  For.prototype.sideEffect = function() {
    return expsEffect([this.init, this.test, this.step, this.body]);
  };

  ForIn.prototype.sideEffect = function() {
    return expsEffect([this.container, this.body]);
  };

  While.prototype.sideEffect = function() {
    return expsEffect([this.test, this.body]);
  };

  Break.prototype.sideEffect = function() {
    return il.EFFECT;
  };

  Try.prototype.sideEffect = function() {
    return expsEffect([this.test, this.catches, this.final]);
  };

  Begin.prototype.sideEffect = function() {
    return expsEffect(this.exps);
  };

  Lamda.prototype.sideEffect = function() {
    return il.PURE;
  };

  JSFun.prototype.sideEffect = function() {
    return il.PURE;
  };

  Fun.prototype.sideEffect = function() {
    return il.PURE;
  };

  Apply.prototype.sideEffect = function() {
    return Math.max(applySideEffect(this.caller), expsEffect(this.args));
  };

  VirtualOperation.prototype.sideEffect = function() {
    return Math.max(this._effect, expsEffect(this.args));
  };

  applySideEffect = function(exp) {
    var exp_applySideEffect;

    exp_applySideEffect = exp != null ? exp.applySideEffect : void 0;
    if (exp_applySideEffect) {
      return exp_applySideEffect.call(exp);
    } else {
      return il.IO;
    }
  };

  Element.prototype.applySideEffect = function() {
    throw new NotImplement(this, 'applySideEffect');
  };

  Var.prototype.applySideEffect = function() {
    return il.IO;
  };

  Apply.prototype.applySideEffect = function() {
    return il.IO;
  };

  VirtualOperation.prototype.applySideEffect = function() {
    return il.IO;
  };

  Fun.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return il.IO;
    }
  };

  JSFun.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return il.IO;
    }
  };

  Lamda.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return sideEffect(this.body);
    }
  };

  Clamda.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return sideEffect(this.body);
    }
  };

  IO = function(exp) {
    var exp_IO;

    exp_IO = exp != null ? exp.IO : void 0;
    if (exp_IO) {
      return exp_IO.call(exp);
    } else {
      return false;
    }
  };

  setJsified = function(exp) {
    if (exp != null) {
      exp._jsified = true;
    }
    return exp;
  };

  isJsified = function(exp) {
    return (exp != null ? exp._jsified : void 0) || false;
  };

  jsify = function(exp, compiler, env) {
    var exp_jsify;

    if (isJsified(exp)) {
      return exp;
    }
    exp_jsify = exp != null ? exp.jsify : void 0;
    if (exp_jsify) {
      return exp_jsify.call(exp, compiler, env);
    } else {
      return exp;
    }
  };

  Assign.prototype.jsify = function(compiler, env) {
    this.exp = jsify(this.exp, compiler, env);
    return this;
  };

  Return.prototype.jsify = function(compiler, env) {
    return new this.constructor(jsify(this.value, compiler, env));
  };

  If.prototype.jsify = function(compiler, env) {
    return new If(jsify(this.test, compiler, env), jsify(this.then_, compiler, env), jsify(this.else_, compiler, env));
  };

  LabelStatement.prototype.jsify = function(compiler, env) {
    return new LabelStatement(this.label, jsify(this.statement, compiler, env));
  };

  While.prototype.jsify = function(compiler, env) {
    return new While(jsify(this.test, compiler, env), jsify(this.body, compiler, env));
  };

  For.prototype.jsify = function(compiler, env) {
    return new For(jsify(this.init, compiler, env), jsify(this.test, compiler, env), jsify(this.step, compiler, env), jsify(this.body, compiler, env));
  };

  ForIn.prototype.jsify = function(compiler, env) {
    return new ForIn(jsify(this.vari, compiler, env), jsify(this.container, compiler, env), jsify(this.body, compiler, env));
  };

  Break.prototype.jsify = function(compiler, env) {
    return this;
  };

  Try.prototype.jsify = function(compiler, env) {
    return new Try(jsify(this.test, compiler, env), jsify(this.catches, compiler, env), jsify(this.final, compiler, env));
  };

  Begin.prototype.jsify = function(compiler, env) {
    var e, exps, length, result, waitPop, _i, _len;

    exps = this.exps;
    length = exps.length;
    if (length === 0 || length === 1) {
      throw new Error("begin should have at least one exp");
    }
    result = [];
    waitPop = false;
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      if (e instanceof Assign && e.removed()) {
        continue;
      }
      if (waitPop) {
        result.pop();
      }
      e = jsify(e, compiler, env);
      if (e instanceof Begin) {
        result = result.concat(e.exps);
        waitPop = sideEffect(result[result.length - 1]) === il.PURE;
      } else if (e instanceof New) {
        result.push(e);
        waitPop = sideEffect(e) === il.PURE;
      } else if (e instanceof Throw) {
        result.push(e);
        break;
      } else if (e instanceof Return) {
        throw new Error(e);
      } else {
        result.push(e);
        waitPop = sideEffect(e) === il.PURE;
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return new this.constructor(result);
    }
  };

  Lamda.prototype.jsify = function(compiler, env) {
    if (!this._jsifyied) {
      this.body = jsify(this.body, compiler, env);
      this._jsifyied = true;
    }
    return this;
  };

  Apply.prototype.jsify = function(compiler, env) {
    var a, body, caller;

    caller = this.caller;
    if (caller instanceof Lamda && caller.params.length === 0) {
      body = jsify(caller.body, compiler, env);
      if (!isStatement(body)) {
        return body;
      } else {
        return new Apply(new caller.constructor([], body), []);
      }
    } else {
      return new this.constructor(jsify(this.caller, compiler, env), (function() {
        var _i, _len, _ref20, _results;

        _ref20 = this.args;
        _results = [];
        for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
          a = _ref20[_i];
          _results.push(jsify(a, compiler, env));
        }
        return _results;
      }).call(this));
    }
  };

  VirtualOperation.prototype.jsify = function(compiler, env) {
    var a;

    return new this.constructor((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.args;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        a = _ref20[_i];
        _results.push(jsify(a, compiler, env));
      }
      return _results;
    }).call(this));
  };

  il.insertReturn = insertReturn = function(exp) {
    var exp_insertReturn;

    exp_insertReturn = exp != null ? exp.insertReturn : void 0;
    if (exp_insertReturn) {
      return exp_insertReturn.call(exp);
    } else {
      return new Return(exp);
    }
  };

  Assign.prototype.insertReturn = function() {
    return il.begin(this, il["return"](this.left));
  };

  Return.prototype.insertReturn = function() {
    return this;
  };

  New.prototype.insertReturn = function() {
    return new Return(this);
  };

  If.prototype.insertReturn = function() {
    if (this.isStatement()) {
      return new If(this.test, insertReturn(this.then_), insertReturn(this.else_));
    } else {
      return new Return(this);
    }
  };

  LabelStatement.prototype.insertReturn = function() {
    return new LabelStatement(this.label, insertReturn(this.statement));
  };

  While.prototype.insertReturn = function() {
    return new Begin(new While(this.test, insertReturn(this.body)), new Return());
  };

  Break.prototype.insertReturn = function() {
    return this;
  };

  Try.prototype.insertReturn = function() {
    return new Try(this.test, insertReturn(this.catches), insertReturn(this.final));
  };

  Begin.prototype.insertReturn = function() {
    var exps, last, length;

    exps = this.exps;
    length = exps.length;
    last = insertReturn(exps[length - 1]);
    return new this.constructor(__slice.call(exps.slice(0, length - 1)).concat([last]));
  };

  Lamda.prototype.toCode = function(compiler) {
    var a, body, k, locals, locals1, nonlocals;

    compiler.parent = this;
    locals = [];
    nonlocals = this.nonlocals;
    locals1 = this.locals;
    for (k in locals1) {
      if (!hasOwnProperty.call(nonlocals, k) && __indexOf.call(this.params, k) < 0) {
        locals.push(il.symbol(k));
      }
    }
    body = this.body;
    if (locals.length > 0) {
      body = il.topbegin(il.vardecl.apply(il, locals), this.body);
    }
    body = insertReturn(body);
    if (body instanceof Begin) {
      body.constructor = TopBegin;
    }
    return "function(" + (((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.params;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        a = _ref20[_i];
        _results.push(a.toString());
      }
      return _results;
    }).call(this)).join(', ')) + "){" + (compiler.toCode(body)) + "}";
  };

  Clamda.prototype.toCode = function(compiler) {
    var body, k, locals, locals1, nonlocals;

    compiler.parent = this;
    locals = [];
    nonlocals = this.nonlocals;
    locals1 = this.locals;
    for (k in locals1) {
      if (!hasOwnProperty.call(nonlocals, k) && k !== this.v) {
        locals.push(il.symbol(k));
      }
    }
    body = this.body;
    if (locals.length > 0) {
      body = il.topbegin(il.vardecl.apply(il, locals), body);
    }
    body = insertReturn(body);
    return "function(" + (this.v.toString()) + "){" + (compiler.toCode(body)) + "}";
  };

  Fun.prototype.toCode = function(compiler) {
    return this.func.toString();
  };

  Return.prototype.toCode = function(compiler) {
    return "return " + (compiler.toCode(this.value)) + ";";
  };

  Throw.prototype.toCode = function(compiler) {
    return "throw " + (compiler.toCode(this.value)) + ";";
  };

  New.prototype.toCode = function(compiler) {
    return "new " + (compiler.toCode(this.value));
  };

  Var.prototype.toCode = function(compiler) {
    return this.toString();
  };

  NonlocalDecl.prototype.toCode = function(compiler) {
    return '';
  };

  Assign.prototype.toCode = function(compiler) {
    var args, args0, args1, exp, left, symbol;

    exp = this.exp;
    left = compiler.toCode(this.left);
    if (exp instanceof BinaryOperation) {
      args = exp.args;
      args0 = compiler.toCode(args[0]);
      args1 = compiler.toCode(args[1]);
      if (left === args0) {
        symbol = exp.symbol;
        switch (symbol) {
          case '+':
            if (args1 === '1') {
              return "++" + left;
            } else {
              return "" + left + " += " + args1;
            }
            break;
          case '-':
            if (args1 === '1') {
              return "--" + left;
            } else {
              return "" + left + " -= " + args1;
            }
            break;
          case '*':
          case '/':
          case '%':
          case '|':
          case '&':
          case '^':
          case '||':
          case '&&':
          case '<<':
          case '>>':
            return "" + left + " " + symbol + "= " + args1;
          default:
            return "" + left + " = " + args0 + " " + symbol + " " + args1;
        }
      } else {
        return "" + left + " = " + args0 + " " + symbol + " " + args1;
      }
    } else {
      return "" + left + " = " + (compiler.toCode(exp));
    }
  };

  AugmentAssign.prototype.toCode = function(compiler) {
    return "" + (compiler.toCode(this.left)) + " " + this.operator + " " + (compiler.toCode(this.exp));
  };

  If.prototype.toCode = function(compiler) {
    var else_;

    compiler.parent = this;
    else_ = this.else_;
    if (this.isStatement()) {
      if (else_ === void 0) {
        return "if (" + (compiler.toCode(this.test)) + ") " + (compiler.toCode(this.then_));
      } else {
        return "if (" + (compiler.toCode(this.test)) + ") " + (compiler.toCode(this.then_)) + " else " + (compiler.toCode(this.else_));
      }
    } else {
      return "(" + (compiler.toCode(this.test)) + ") ? (" + (compiler.toCode(this.then_)) + ") : (" + (compiler.toCode(this.else_)) + ")";
    }
  };

  LabelStatement.prototype.toCode = function(compiler) {
    return "" + (compiler.toCode(this.then_)) + ":" + (compiler.toCode(this.statement));
  };

  For.prototype.toCode = function(compiler) {
    return "for (" + (compiler.toCode(this.init)) + ";" + (compiler.toCode(this.test)) + ";" + (compiler.toCode(this.step)) + ") " + (compiler.toCode(this.body));
  };

  ForIn.prototype.toCode = function(compiler) {
    return "for (" + (compiler.toCode(this.vari)) + " in " + (compiler.toCode(this.container)) + ") " + (compiler.toCode(this.body));
  };

  ForOf.prototype.toCode = function(compiler) {
    return "for (" + (compiler.toCode(this.vari)) + " of " + (compiler.toCode(this.container)) + ") " + (compiler.toCode(this.body));
  };

  While.prototype.toCode = function(compiler) {
    return "while (" + (compiler.toCode(this.test)) + ") " + (compiler.toCode(this.body));
  };

  DoWhile.prototype.toCode = function(compiler) {
    return "do " + (compiler.toCode(this.body)) + " while(" + (compiler.toCode(this.test)) + ") ";
  };

  Try.prototype.toCode = function(compiler) {
    return "try " + (compiler.toCode(this.test)) + " " + (compiler.toCode(this.catches)) + " finally " + (compiler.toCode(this.final));
  };

  Break.prototype.toCode = function(compiler) {
    if (this.label) {
      return "break " + (compiler.toCode(this.label));
    } else {
      return "break";
    }
  };

  Continue.prototype.toCode = function(compiler) {
    if (this.label) {
      return "continue " + (compiler.toCode(this.label));
    } else {
      return "continue";
    }
  };

  Apply.prototype.toCode = function(compiler) {
    var arg;

    return "" + (expressionToCode(compiler, this.caller)) + "(" + (((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.args;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        arg = _ref20[_i];
        _results.push(compiler.toCode(arg));
      }
      return _results;
    }).call(this)).join(', ')) + ")";
  };

  Begin.prototype.toCode = function(compiler) {
    var exp;

    compiler.parent = this;
    return "{" + (((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.exps;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        exp = _ref20[_i];
        _results.push(compiler.toCode(exp));
      }
      return _results;
    }).call(this)).join('; ')) + "}";
  };

  ExpressionList.prototype.toCode = function(compiler) {
    var exp;

    compiler.parent = this;
    return "" + (((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.exps;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        exp = _ref20[_i];
        _results.push(compiler.toCode(exp));
      }
      return _results;
    }).call(this)).join(','));
  };

  TopBegin.prototype.toCode = function(compiler) {
    var exp;

    compiler.parent = this;
    return "" + (((function() {
      var _i, _len, _ref20, _results;

      _ref20 = this.exps;
      _results = [];
      for (_i = 0, _len = _ref20.length; _i < _len; _i++) {
        exp = _ref20[_i];
        _results.push(compiler.toCode(exp));
      }
      return _results;
    }).call(this)).join('; '));
  };

  Deref.prototype.toCode = function(compiler) {
    return "solver.trail.deref(" + (compiler.toCode(this.exp)) + ")";
  };

  JSFun.prototype.toCode = function(compiler) {
    if (_.isString(this.fun)) {
      return this.fun;
    } else {
      return compiler.toCode(this.fun);
    }
  };

  isStatement = function(exp) {
    var exp_isStatement;

    exp_isStatement = exp != null ? exp.isStatement : void 0;
    if (exp_isStatement) {
      return exp_isStatement.call(exp);
    } else {
      return false;
    }
  };

  If.prototype.isStatement = function() {
    return isStatement(this.then_) || isStatement(this.else_);
  };

  LabelStatement.prototype.isStatement = function() {
    return true;
  };

  While.prototype.isStatement = function() {
    return true;
  };

  Try.prototype.isStatement = function() {
    return true;
  };

  Begin.prototype.isStatement = function() {
    return true;
  };

  ExpressionList.prototype.isStatement = function() {
    return true;
  };

  Return.prototype.isStatement = function() {
    return true;
  };

  New.prototype.isStatement = function() {
    return false;
  };

  Assign.prototype.isStatement = function() {
    return true;
  };

  vari = function(klass, name) {
    return new klass(name);
  };

  il.userlocal = function(name) {
    return new UserLocalVar(name);
  };

  il.usernonlocal = function(name) {
    return new UserNonlocalVar(name);
  };

  il.internallocal = function(name) {
    return new InternalLocalVar(name);
  };

  il.internalnonlocal = function(name) {
    return new InternalNonlocalVar(name);
  };

  il.symbol = function(name) {
    return new Symbol(name);
  };

  varattr = function(klass, name) {
    var i, length, names, result, _i;

    if (name == null) {
      return new klass(name);
    }
    if (name instanceof Var) {
      name = name.name;
    }
    names = name.split('.');
    length = names.length;
    result = new klass(names[0]);
    for (i = _i = 1; 1 <= length ? _i < length : _i > length; i = 1 <= length ? ++_i : --_i) {
      result = il.attr(result, il.symbol(names[i]));
    }
    return result;
  };

  il.usernonlocalattr = function(name) {
    return varattr(UserNonlocalVar, name);
  };

  il.assign = function(left, exp) {
    return new Assign(left, exp);
  };

  il.userlocalassign = function(left, exp) {
    if (left instanceof Var) {
      left = left.name;
    }
    return new Assign(il.userlocal(left), exp);
  };

  il.usernonlocalassign = function(left, exp) {
    if (left instanceof Var) {
      left = left.name;
    }
    return new Assign(il.usernonlocal(left), exp);
  };

  il.internallocalassign = function(left, exp) {
    if (left instanceof Var) {
      left = left.name;
    }
    return new Assign(il.internallocal(left), exp);
  };

  il.internalnonlocalassign = function(left, exp) {
    if (left instanceof Var) {
      left = left.name;
    }
    return new Assign(il.internalnonlocal(left), exp);
  };

  il.if_ = function(test, then_, else_) {
    return new If(test, then_, else_);
  };

  il.deref = function(exp) {
    return new Deref(exp);
  };

  begin = function() {
    var e, exps, klass, length, result, _i, _len;

    klass = arguments[0], exps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    length = exps.length;
    if (length === 0) {
      throw new Error("begin should have at least one exp");
    }
    result = [];
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      if (e instanceof Begin) {
        result = result.concat(e.exps);
      } else {
        result.push(e);
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return new klass(result);
    }
  };

  il.begin = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return begin.apply(null, [Begin].concat(__slice.call(exps)));
  };

  il.topbegin = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return begin.apply(null, [TopBegin].concat(__slice.call(exps)));
  };

  il.print = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new Print(exps);
  };

  il["return"] = function(value) {
    return new Return(value);
  };

  il["throw"] = function(value) {
    return new Throw(value);
  };

  il["new"] = function(value) {
    return new New(value);
  };

  il.lamda = function() {
    var body, params;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new Lamda(params, il.topbegin.apply(il, body));
  };

  il.userlamda = function() {
    var body, params;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new UserLamda(params, il.topbegin.apply(il, body));
  };

  il.clamda = function() {
    var body, v;

    v = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new Clamda(v, il.topbegin.apply(il, body));
  };

  il.recclamda = function() {
    var body, v;

    v = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new RecursiveClamda(v, il.topbegin.apply(il, body));
  };

  il.clamdabody = function(v, body) {
    return new ClamdaBody(v, body);
  };

  il.code = function(string) {
    return new Code(string);
  };

  il.jsfun = function(fun) {
    return new JSFun(fun);
  };

  binary = function(symbol, func, effect) {
    var Binary, _ref20;

    if (effect == null) {
      effect = il.PURE;
    }
    Binary = (function(_super) {
      __extends(Binary, _super);

      function Binary() {
        _ref20 = Binary.__super__.constructor.apply(this, arguments);
        return _ref20;
      }

      Binary.prototype.symbol = symbol;

      Binary.prototype.toCode = function(compiler) {
        var args;

        args = this.args;
        return "" + (expressionToCode(compiler, args[0])) + " " + symbol + " " + (expressionToCode(compiler, args[1]));
      };

      Binary.prototype.func = func;

      Binary.prototype._effect = effect;

      return Binary;

    })(BinaryOperation);
    return function(x, y) {
      return new Binary([x, y]);
    };
  };

  unary = function(symbol, func, effect) {
    var Unary, _ref20;

    if (effect == null) {
      effect = il.PURE;
    }
    Unary = (function(_super) {
      __extends(Unary, _super);

      function Unary() {
        _ref20 = Unary.__super__.constructor.apply(this, arguments);
        return _ref20;
      }

      Unary.prototype.symbol = symbol;

      Unary.prototype.func = func;

      Unary.prototype._effect = effect;

      Unary.prototype.toCode = function(compiler) {
        return "" + symbol + (expressionToCode(compiler, this.args[0]));
      };

      return Unary;

    })(UnaryOperation);
    return function(x) {
      return new Unary([x]);
    };
  };

  il.eq = binary("===", function(x, y) {
    return x === y;
  });

  il.ne = binary("!==", function(x, y) {
    return x !== y;
  });

  il.lt = binary("<", function(x, y) {
    return x < y;
  });

  il.le = binary("<=", function(x, y) {
    return x <= y;
  });

  il.gt = binary(">", function(x, y) {
    return x > y;
  });

  il.ge = binary(">=", function(x, y) {
    return x >= y;
  });

  il.add = binary("+", function(x, y) {
    return x + y;
  });

  il.sub = binary("-", function(x, y) {
    return x - y;
  });

  il.mul = binary("*", function(x, y) {
    return x * y;
  });

  il.div = binary("/", function(x, y) {
    return x / y;
  });

  il.mod = binary("%", function(x, y) {
    return x % y;
  });

  il.and_ = binary("&&", function(x, y) {
    return x && y;
  });

  il.or_ = binary("||", function(x, y) {
    return x || y;
  });

  il.bitand = binary("&", function(x, y) {
    return x & y;
  });

  il.bitor = binary("|", function(x, y) {
    return x | y;
  });

  il.bitxor = binary("^", function(x, y) {
    return x ^ y;
  });

  il.lshift = binary("<<", function(x, y) {
    return x << y;
  });

  il.rshift = binary(">>", function(x, y) {
    return x >> y;
  });

  augmentAssign = function(operator, func) {
    var AugAssign, _ref20;

    AugAssign = (function(_super) {
      __extends(AugAssign, _super);

      function AugAssign() {
        _ref20 = AugAssign.__super__.constructor.apply(this, arguments);
        return _ref20;
      }

      AugAssign.prototype.operator = operator;

      AugAssign.prototype.func = func;

      return AugAssign;

    })(AugmentAssign);
    return function(vari, exp) {
      return new AugAssign(vari, exp);
    };
  };

  il.addassign = augmentAssign("+=", function(x, y) {
    return x + y;
  });

  il.subassign = augmentAssign("-=", function(x, y) {
    return x - y;
  });

  il.mulassign = augmentAssign("*=", function(x, y) {
    return x * y;
  });

  il.divassign = augmentAssign("/=", function(x, y) {
    return x / y;
  });

  il.modassign = augmentAssign("%=", function(x, y) {
    return x % y;
  });

  il.andassign = augmentAssign("&&=", function(x, y) {
    return x && y;
  });

  il.orassign = augmentAssign("||=", function(x, y) {
    return x || y;
  });

  il.bitandassign = augmentAssign("&=", function(x, y) {
    return x & y;
  });

  il.bitorassign = augmentAssign("|=", function(x, y) {
    return x | y;
  });

  il.bitxorassign = augmentAssign("^=", function(x, y) {
    return x ^ y;
  });

  il.lshiftassign = augmentAssign("<<=", function(x, y) {
    return x << y;
  });

  il.rshiftassign = augmentAssign(">>=", function(x, y) {
    return x >> y;
  });

  il.listassign = function() {
    var exp, i, lefts, _i;

    lefts = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), exp = arguments[_i++];
    return il.begin.apply(il, (function() {
      var _j, _ref20, _results;

      _results = [];
      for (i = _j = 0, _ref20 = lefts.length; 0 <= _ref20 ? _j < _ref20 : _j > _ref20; i = 0 <= _ref20 ? ++_j : --_j) {
        _results.push(il.assign(lefts[i], il.index(exp, i)));
      }
      return _results;
    })());
  };

  il.not_ = unary("!", function(x) {
    return !x;
  });

  il.neg = unary("-", function(x) {
    return -x;
  });

  il.bitnot = unary("~", function(x) {
    return ~x;
  });

  il.inc = il.effect(unary("++"), (function(x) {
    return x + 1;
  }), il.EFFECT);

  il.dec = il.effect(unary("--"), (function(x) {
    return x - 1;
  }), il.EFFECT);

  vop = function(name, toCode, _effect) {
    var Vop, _ref20;

    if (_effect == null) {
      _effect = il.EFFECT;
    }
    Vop = (function(_super) {
      __extends(Vop, _super);

      function Vop() {
        _ref20 = Vop.__super__.constructor.apply(this, arguments);
        return _ref20;
      }

      Vop.prototype.toCode = toCode;

      Vop.prototype._effect = _effect;

      Vop.prototype._name = name;

      return Vop;

    })(VirtualOperation);
    return function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Vop(args);
    };
  };

  vop2 = function(name, toCode, _effect) {
    var Vop, _ref20;

    if (_effect == null) {
      _effect = il.EFFECT;
    }
    Vop = (function(_super) {
      __extends(Vop, _super);

      function Vop() {
        _ref20 = Vop.__super__.constructor.apply(this, arguments);
        return _ref20;
      }

      Vop.prototype.toCode = toCode;

      Vop.prototype._effect = _effect;

      Vop.prototype._name = name;

      Vop.prototype.isStatement = function() {
        return true;
      };

      return Vop;

    })(VirtualOperation);
    return function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Vop(args);
    };
  };

  il.attr = vop('attr', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "." + (compiler.toCode(args[1]));
  }), il.PURE);

  il.nonlocal = function(vars) {
    return new NonlocalDecl(vars);
  };

  il.local = function() {
    var vars;

    vars = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new LocalDecl(vars);
  };

  il.vardecl = vop('vardecl', function(compiler) {
    var args, e;

    args = this.args;
    return "var " + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        e = args[_i];
        _results.push(compiler.toCode(e));
      }
      return _results;
    })()).join(', '));
  });

  il.array = vop('array', function(compiler) {
    var args, e;

    args = this.args;
    return "[" + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        e = args[_i];
        _results.push(compiler.toCode(e));
      }
      return _results;
    })()).join(', ')) + "]";
  });

  il.suffixinc = vop('suffixdec', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "++";
  });

  il.suffixdec = vop('suffixdec', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "--";
  });

  il.catches = il.usernonlocalattr('solver.catches');

  il.pushCatch = vop('pushCatch', function(compiler) {
    var args;

    args = this.args;
    return "solver.pushCatch(" + (expressionToCode(compiler, args[0])) + ", " + (expressionToCode(compiler, args[1])) + ")";
  });

  il.popCatch = vop('popCatch', function(compiler) {
    var args;

    args = this.args;
    return "solver.popCatch(" + (expressionToCode(compiler, args[0])) + ")";
  });

  il.findCatch = vop('findCatch', (function(compiler) {
    var args;

    args = this.args;
    return "solver.findCatch(" + (expressionToCode(compiler, args[0])) + ")";
  }), il.PURE);

  il.fake = vop('fake', function(compiler) {
    var args;

    args = this.args;
    return "solver.fake(" + (compiler.toCode(args[0])) + ")";
  }).apply([]);

  il.restore = vop('restore', function(compiler) {
    var args;

    args = this.args;
    return "solver.restore(" + (compiler.toCode(args[0])) + ")";
  });

  il.getvalue = vop('getvalue', (function(compiler) {
    var args;

    args = this.args;
    return "solver.trail.getvalue(" + (compiler.toCode(args[0])) + ")";
  }), il.PURE);

  il.list = vop('list', (function(compiler) {
    var a, args;

    args = this.args;
    return "[" + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        a = args[_i];
        _results.push(compiler.toCode(a));
      }
      return _results;
    })()).join(', ')) + "]";
  }), il.PURE);

  il.length = vop('length', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".length";
  }), il.PURE);

  il.index = vop('index', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "[" + (compiler.toCode(args[1])) + "]";
  }), il.PURE);

  il.slice = vop('slice', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".slice(" + (compiler.toCode(args[1])) + ", " + (compiler.toCode(args[2])) + ")";
  }), il.PURE);

  il.push = vop('push', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".push(" + (compiler.toCode(args[1])) + ")";
  });

  il.pop = vop('pop', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".pop()";
  });

  il.concat = vop('concat', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".concat(" + (compiler.toCode(args[1])) + ")";
  }), il.PURE);

  il["instanceof"] = vop('instanceof', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + " instanceof " + (expressionToCode(compiler, args[1]));
  }), il.PURE);

  il.run = vop('run', function(compiler) {
    var args;

    args = this.args;
    return "solver.run(" + (compiler.toCode(args[0])) + ")";
  });

  il.evalexpr = vop('evalexpr', function(compiler) {
    var args;

    args = this.args;
    return "solve(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  });

  il.require = vop('require', function(compiler) {
    var args;

    args = this.args;
    return "require(" + (compiler.toCode(args[0])) + ")";
  });

  il.newLogicVar = vop('newLogicVar', (function(compiler) {
    var args;

    args = this.args;
    return "new Var(" + (compiler.toCode(args[0])) + ")";
  }), il.PURE);

  il.newDummyVar = vop('newDummyVar', (function(compiler) {
    var args;

    args = this.args;
    return "new DummyVar(" + (compiler.toCode(args[0])) + ")";
  }), il.PURE);

  il.unify = vop('unify', function(compiler) {
    var args;

    args = this.args;
    return "solver.trail.unify(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  });

  il.bind = vop('bind', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".bind(" + (compiler.toCode(args[1])) + ", solver.trail)";
  });

  il.solver = il.usernonlocal('solver');

  il.undotrail = vop('undotrail', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".undo()";
  });

  il.failcont = il.usernonlocalattr('solver.failcont');

  il.setfailcont = function(cont) {
    return il.assign(il.failcont, cont);
  };

  il.setcutcont = function(cont) {
    return il.assign(il.cutcont, cont);
  };

  il.appendFailcont = vop('appendFailcont', function(compiler) {
    var args;

    args = this.args;
    return "solver.appendFailcont(" + (compiler.toCode(args[0])) + ")";
  });

  il.cutcont = il.usernonlocalattr('solver.cutcont');

  il.state = il.usernonlocalattr('solver.state');

  il.setstate = function(state) {
    return il.assign(il.state, state);
  };

  il.trail = il.usernonlocalattr('solver.trail');

  il.newTrail = vop('newTrail', function(compiler) {
    var args;

    args = this.args;
    return "new Trail()";
  })();

  il.settrail = function(trail) {
    return il.assign(il.trail, trail);
  };

  il.char = vop('char', (function(compiler) {
    var args;

    args = this.args;
    return "parser.char(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.followChars = vop('followChars', (function(compiler) {
    var args;

    args = this.args;
    return "parser.followChars(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.notFollowChars = vop('notFollowChars', (function(compiler) {
    var args;

    args = this.args;
    return "parser.notFollowChars(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.charWhen = vop('charWhen', (function(compiler) {
    var args;

    args = this.args;
    return "parser.charWhen(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.spaces = vop('spaces', (function(compiler) {
    var args;

    args = this.args;
    return "parser.spaces(" + (compiler.toCode(args[0])) + ")";
  }), il.EFFECT);

  il.spaces0 = vop('spaces0', (function(compiler) {
    var args;

    args = this.args;
    return "parser.spaces0(" + (compiler.toCode(args[0])) + ")";
  }), il.EFFECT);

  il.stringWhile = vop('stringWhile', (function(compiler) {
    var args;

    args = this.args;
    return "parser.stringWhile(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.stringWhile0 = vop('stringWhile0', (function(compiler) {
    var args;

    args = this.args;
    return "parser.stringWhile0(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.number = vop('number', (function(compiler) {
    var args;

    args = this.args;
    return "parser.number(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.literal = vop('literal', (function(compiler) {
    var args;

    args = this.args;
    return "parser.literal(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.followLiteral = vop('followLiteral', (function(compiler) {
    var args;

    args = this.args;
    return "parser.followLiteral(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.notFollowLiteral = vop('notFollowLiteral', (function(compiler) {
    var args;

    args = this.args;
    return "parser.notFollowLiteral(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.quoteString = vop('quoteString', (function(compiler) {
    var args;

    args = this.args;
    return "parser.quoteString(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.fun = function(f) {
    return new Fun(f);
  };

  il.let_ = function() {
    var bindings, body, i, params, values, _i, _ref20;

    bindings = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    params = [];
    values = [];
    for (i = _i = 0, _ref20 = bindings.length; _i < _ref20; i = _i += 2) {
      params.push(bindings[i]);
      values.push(bindings[i + 1]);
    }
    return new Apply(il.lamda.apply(il, [params].concat(__slice.call(body))), values);
  };

  il.iff = function() {
    var clauses, else_, length, _i;

    clauses = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), else_ = arguments[_i++];
    length = clauses.length;
    if (length === 2) {
      return il.if_(clauses[0], clauses[1], else_);
    } else {
      return il.if_(clauses[0], clauses[1], il.iff.apply(il, __slice.call(clauses.slice(2, length)).concat([else_])));
    }
  };

  il.label = function(label, statement) {
    return new LabelStatement(label, statement);
  };

  il.while_ = function() {
    var body, test;

    test = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new While(test, il.begin.apply(il, body));
  };

  il.dowhile = function() {
    var body, test, _i;

    body = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), test = arguments[_i++];
    return new DoWhile(test, il.begin.apply(il, body));
  };

  il.for_ = function(init, test, step, body) {
    return new For(test, il.begin.apply(il, body));
  };

  il.forin = function() {
    var body, container, vari;

    vari = arguments[0], container = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return new ForIn(vari, container, il.begin.apply(il, body));
  };

  il.forof = function() {
    var body, container, vari;

    vari = arguments[0], container = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return new ForOf(vari, container, il.begin.apply(il, body));
  };

  il.try_ = function(test, catches, final) {
    return new Try(test, catches, final);
  };

  il.break_ = function(label) {
    return new Break(label);
  };

  il.continue_ = function(label) {
    return new Continue(label);
  };

  il.idcont = (function() {
    var v;

    v = il.internallocal('v');
    return new IdCont(v, v);
  })();

  il.excludes = ['evalexpr', 'failcont', 'run', 'getvalue', 'fake', 'findCatch', 'popCatch', 'pushCatch', 'protect', 'suffixinc', 'suffixdec', 'dec', 'inc', 'unify', 'bind', 'undotrail', 'newTrail', 'newLogicVar', 'char', 'followChars', 'notFollowChars', 'charWhen', 'stringWhile', 'stringWhile0', 'number', 'literal', 'followLiteral', 'quoteString'];

  augmentOperators = {
    add: il.addassign,
    sub: il.subassign,
    mul: il.mulassign,
    div: il.divassign,
    mod: il.modassign,
    'and_': il.andassign,
    'or_': il.orassign,
    bitand: il.bitandassign,
    bitor: il.bitorassign,
    bitxor: il.bitxorassign,
    lshift: il.lshiftassign,
    rshift: il.rshiftassign
  };

}).call(this);

/*
//@ sourceMappingURL=interlang.map
*/
