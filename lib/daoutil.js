// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, StateMachine, Trail, TypeError, Var, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  exports.binaryOperator = function(solver, cont) {
    var c, c1, length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        solver.state = [text, pos + 1];
        return cont('vop_add');
      case '-':
        solver.state = [text, pos + 1];
        return cont('vop_sub');
      case '*':
        solver.state = [text, pos + 1];
        return cont('vop_mul');
      case '/':
        solver.state = [text, pos + 1];
        return cont('vop_div');
      case '%':
        solver.state = [text, pos + 1];
        return cont('vop_mod');
      case '=':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_eq');
        } else {
          return solver.failcont(pos);
        }
        break;
      case '!':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_ne');
        } else {
          return solver.failcont(pos);
        }
        break;
      case '>':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_ge');
        } else if (c1 === '>') {
          solver.state = [text, pos + 2];
          return cont('vop_rshift');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_gt');
        }
        break;
      case '<':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_le');
        } else if (c1 === '<') {
          solver.state = [text, pos + 2];
          return cont('vop_lshift');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_lt');
        }
    }
  };

  exports.unaryOperator = function(solver, cont) {
    var c, c1, length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_inc');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_pos');
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_dec');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_neg');
        }
        break;
      case '!':
        solver.state = [text, pos + 1];
        return cont('vop_not');
      case '~':
        solver.state = [text, pos + 1];
        return cont('vop_bitnot');
      default:
        return solver.failcont(pos);
    }
  };

  exports.suffixOperator = function(solver, cont) {
    var c, c1, length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_inc');
        } else {
          return solver.failcont(pos);
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_dec');
        } else {
          return solver.failcont(pos);
        }
        break;
      default:
        return solver.failcont(pos);
    }
  };

  exports.program = function(solver, cont) {
    var length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return cont(null);
    } else {
      return programBody(solver, cont);
    }
  };

  exports.programBody = function(solver, cont) {
    var exps, pos, stmt, text, _ref1;

    exps = [];
    while (1) {
      stmt = statement(solver, cont);
      if (stmt[0] === sexpression.COMMENT) {
        continue;
      }
      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      if (pos === text.length) {
        break;
      }
    }
    if (exps.length === 0) {
      return null;
    } else {
      exps.unshift(sexpression.BEGIN);
      return exps;
    }
  };

  exports.statement = function(solver, cont) {
    var token;

    solver.token = token = readStartToken(solver, cont);
    switch (token) {
      case RETURN:
        return returnStatement(solver, cont);
      case PASS:
        return passStatement(solver, cont);
      case BLOCKCOMMENT:
        return blockComment(solver, cont);
      case LINECOMMENT:
        return lineComment(solver, cont);
      default:
        return expression(solver, cont);
    }
  };

  StateMachine = (function() {
    var add, constructor, match;

    function StateMachine() {}

    constructor = function(words) {
      var w, _i, _len, _results;

      if (words == null) {
        words = [];
      }
      this.index = 0;
      this.dict = {};
      this.dict[0] = {};
      _results = [];
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        w = words[_i];
        _results.push(this.add(w));
      }
      return _results;
    };

    add = function(word) {
      var c, length, newState, state, _i, _len, _ref1;

      length = word.length;
      _ref1 = word.slice(0, length - 1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        if (__indexOf.call(this.dict[state], c) >= 0) {
          state = Math.abs(this.dict[state][c]);
        } else {
          newState = this.index++;
          this.dict[state][c] = newState;
          this.dict[newState] = {};
          state = newState;
        }
      }
      c = word[-1];
      if (__indexOf.call(this.dict[state], c) >= 0) {
        if (this.dict[state][c] > 0) {
          return this.dict[state][c] = -this.dict[state][c];
        }
      } else {
        newState = this.new_state++;
        this.dict[state][c] = -newState;
        return this.dict[newState] = {};
      }
    };

    match = function(string) {
      var c, i, result, state, _i, _len;

      result = 0;
      state = 0;
      for (i = _i = 0, _len = string.length; _i < _len; i = ++_i) {
        c = string[i];
        state = this.dict[state][c];
        if (state === null) {
          return result;
        }
        if (state < 0) {
          result = i + 1;
          state = -state;
        }
      }
    };

    return StateMachine;

  })();

}).call(this);

/*
//@ sourceMappingURL=daoutil.map
*/
