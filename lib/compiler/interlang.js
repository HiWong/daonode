// Generated by CoffeeScript 1.6.2
(function() {
  var Apply, Assign, AugmentAssign, Begin, BinaryOperation, BlockLamda, BlockVar, Break, Clamda, Continue, Deref, DoWhile, DummyVar, Element, Env, ExpressionList, For, ForIn, ForOf, Fun, IO, IdCont, If, InternalVar, JSFun, LabelStatement, Lamda, LocalDecl, LogicVar, MAX_EXTEND_CODE_SIZE, New, NonlocalDecl, NotImplement, OptimizableRecuisiveLamda, Print, RecursiveClamda, Return, Symbol, TailRecuisiveLamda, Throw, Trail, Try, UnaryOperation, UserLamda, UserVar, Var, VirtualOperation, While, applySideEffect, augmentAssign, augmentOperators, binary, boolize, codeSize, convertBlockLamdaBody, convertOptRecursive, convertOptResursiveCall, convertTailRecursive, convertTailResursiveCall, core, expressionToCode, expsEffect, getConvertParameters, hasCallOf, hasOwnProperty, il, insertReturn, isAtomic, isDeclaration, isEmpty, isJsified, isParam, isStatement, isValue, jsify, optimize, postOptimize, pure, replace, setJsified, sideEffect, solve, solvecore, toString, unary, useConvertParams, varattr, vari, vop, vop2, _, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require("underscore");

  _ref = core = require("./core"), Env = _ref.Env, solve = _ref.solve;

  solvecore = require("./solve");

  Trail = solvecore.Trail;

  LogicVar = solvecore.Var;

  DummyVar = solvecore.DummyVar;

  il = exports;

  exports.NotImplement = NotImplement = (function(_super) {
    __extends(NotImplement, _super);

    function NotImplement(exp, message, stack) {
      this.exp = exp;
      this.message = message != null ? message : '';
      this.stack = stack != null ? stack : this;
    }

    NotImplement.prototype.toString = function() {
      return "" + this.name + " >>> " + this.exp + " " + this.message;
    };

    return NotImplement;

  })(Error);

  toString = function(o) {
    return (o != null ? typeof o.toString === "function" ? o.toString() : void 0 : void 0) || o;
  };

  Element = (function() {
    function Element() {
      this.name = this.toString();
    }

    Element.prototype.call = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Apply(this, args);
    };

    Element.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    Element.prototype.toCode = function(compiler) {
      throw new NotImplement(this, "toCode");
    };

    Element.prototype.isValue = function() {
      return false;
    };

    Object.defineProperty(Element.prototype, '$', {
      get: function() {
        return this.constructor;
      }
    });

    return Element;

  })();

  Var = (function(_super) {
    __extends(Var, _super);

    function Var(name, suffix) {
      this.name = name;
      this.suffix = suffix != null ? suffix : '';
    }

    Var.prototype.toString = function() {
      return this.name + this.suffix;
    };

    return Var;

  })(Element);

  UserVar = (function(_super) {
    __extends(UserVar, _super);

    function UserVar() {
      _ref1 = UserVar.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return UserVar;

  })(Var);

  InternalVar = (function(_super) {
    __extends(InternalVar, _super);

    function InternalVar() {
      _ref2 = InternalVar.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return InternalVar;

  })(Var);

  BlockVar = (function(_super) {
    __extends(BlockVar, _super);

    function BlockVar(name, suffix) {
      this.name = name;
      this.suffix = suffix != null ? suffix : '';
      BlockVar.__super__.constructor.apply(this, arguments);
      this.convertable = true;
    }

    return BlockVar;

  })(InternalVar);

  Symbol = (function(_super) {
    __extends(Symbol, _super);

    function Symbol() {
      _ref3 = Symbol.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return Symbol;

  })(Var);

  LocalDecl = (function(_super) {
    __extends(LocalDecl, _super);

    function LocalDecl(vars) {
      this.vars = vars;
      LocalDecl.__super__.constructor.apply(this, arguments);
    }

    LocalDecl.prototype.toString = function() {
      return "localDecl(" + this.vars;
    };

    LocalDecl.prototype.isDeclaration = function() {
      return true;
    };

    return LocalDecl;

  })(Element);

  NonlocalDecl = (function(_super) {
    __extends(NonlocalDecl, _super);

    function NonlocalDecl() {
      _ref4 = NonlocalDecl.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    NonlocalDecl.prototype.toString = function() {
      return "nonlocalDecl(" + this.vars;
    };

    return NonlocalDecl;

  })(LocalDecl);

  Assign = (function(_super) {
    __extends(Assign, _super);

    function Assign(left, exp) {
      this.left = left;
      this.exp = exp;
      Assign.__super__.constructor.apply(this, arguments);
      this.dependency = [];
    }

    Assign.prototype.toString = function() {
      return "" + (toString(this.left)) + " = " + (toString(this.exp));
    };

    Assign.prototype.remove = function() {
      return this._removed = true;
    };

    Assign.prototype.dont_remove = function() {
      return this._removed = false;
    };

    Assign.prototype.removed = function() {
      var item, _i, _len, _ref5;

      if (this._removed === true) {
        return true;
      } else if (this._removed === false) {
        return false;
      } else {
        _ref5 = this.dependency;
        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
          item = _ref5[_i];
          if (item.removed() === false) {
            return false;
          }
        }
        return true;
      }
    };

    return Assign;

  })(Element);

  AugmentAssign = (function(_super) {
    __extends(AugmentAssign, _super);

    function AugmentAssign() {
      _ref5 = AugmentAssign.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    AugmentAssign.prototype.toString = function() {
      return "" + (toString(this.left)) + " " + this.operator + " " + (toString(this.exp));
    };

    return AugmentAssign;

  })(Assign);

  New = (function(_super) {
    __extends(New, _super);

    function New(value) {
      this.value = value;
      New.__super__.constructor.apply(this, arguments);
    }

    New.prototype.toString = function() {
      return "" + this.keyword + " " + (toString(this.value));
    };

    New.prototype.keyword = 'new';

    return New;

  })(Element);

  Return = (function(_super) {
    __extends(Return, _super);

    function Return() {
      _ref6 = Return.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    Return.prototype.keyword = 'return';

    return Return;

  })(New);

  Throw = (function(_super) {
    __extends(Throw, _super);

    function Throw() {
      _ref7 = Throw.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    Throw.prototype.keyword = 'throw';

    return Throw;

  })(Return);

  Begin = (function(_super) {
    __extends(Begin, _super);

    function Begin(exps) {
      this.exps = exps;
      Begin.__super__.constructor.apply(this, arguments);
    }

    Begin.prototype.toString = function() {
      var e;

      return "begin(" + (((function() {
        var _i, _len, _ref8, _results;

        _ref8 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref8.length; _i < _len; _i++) {
          e = _ref8[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    Begin.prototype.separator = ';';

    return Begin;

  })(Element);

  ExpressionList = (function(_super) {
    __extends(ExpressionList, _super);

    function ExpressionList(exps) {
      this.exps = exps;
      ExpressionList.__super__.constructor.apply(this, arguments);
    }

    ExpressionList.prototype.toString = function() {
      var e;

      return "exprlist(" + (((function() {
        var _i, _len, _ref8, _results;

        _ref8 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref8.length; _i < _len; _i++) {
          e = _ref8[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    ExpressionList.prototype.separator = ',';

    return ExpressionList;

  })(Begin);

  Print = (function(_super) {
    __extends(Print, _super);

    function Print() {
      _ref8 = Print.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    Print.prototype.toString = function() {
      var e;

      return "print(" + (((function() {
        var _i, _len, _ref9, _results;

        _ref9 = this.exps;
        _results = [];
        for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
          e = _ref9[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(',')) + ")";
    };

    return Print;

  })(Begin);

  Lamda = (function(_super) {
    __extends(Lamda, _super);

    function Lamda(params, body) {
      this.params = params;
      this.body = body;
      Lamda.__super__.constructor.apply(this, arguments);
    }

    Lamda.prototype.toString = function() {
      var e;

      return "(" + (((function() {
        var _i, _len, _ref9, _results;

        _ref9 = this.params;
        _results = [];
        for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
          e = _ref9[_i];
          _results.push(toString(e));
        }
        return _results;
      }).call(this)).join(', ')) + " -> " + (toString(this.body)) + ")";
    };

    Lamda.prototype.call = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Apply(this, args);
    };

    Lamda.prototype.isValue = function() {
      return true;
    };

    Lamda.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    return Lamda;

  })(Element);

  il.UserLamda = UserLamda = (function(_super) {
    __extends(UserLamda, _super);

    function UserLamda() {
      _ref9 = UserLamda.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    return UserLamda;

  })(Lamda);

  BlockLamda = (function(_super) {
    __extends(BlockLamda, _super);

    function BlockLamda() {
      _ref10 = BlockLamda.__super__.constructor.apply(this, arguments);
      return _ref10;
    }

    return BlockLamda;

  })(Lamda);

  OptimizableRecuisiveLamda = (function(_super) {
    __extends(OptimizableRecuisiveLamda, _super);

    function OptimizableRecuisiveLamda() {
      _ref11 = OptimizableRecuisiveLamda.__super__.constructor.apply(this, arguments);
      return _ref11;
    }

    return OptimizableRecuisiveLamda;

  })(Lamda);

  TailRecuisiveLamda = (function(_super) {
    __extends(TailRecuisiveLamda, _super);

    function TailRecuisiveLamda() {
      _ref12 = TailRecuisiveLamda.__super__.constructor.apply(this, arguments);
      return _ref12;
    }

    return TailRecuisiveLamda;

  })(Lamda);

  Clamda = (function(_super) {
    __extends(Clamda, _super);

    function Clamda(v, body) {
      this.v = v;
      this.body = body;
      this.name = this.toString();
      this.params = [v];
    }

    Clamda.prototype.toString = function() {
      return "(" + (toString(this.v)) + " -> " + (toString(this.body)) + ")";
    };

    Clamda.prototype.call = function(value) {
      var result;

      result = replace(this.body, this.v.toString(), value);
      if (result.constructor === Begin) {
        result.constructor = Begin;
      }
      return result;
    };

    return Clamda;

  })(Lamda);

  RecursiveClamda = (function(_super) {
    __extends(RecursiveClamda, _super);

    function RecursiveClamda() {
      _ref13 = RecursiveClamda.__super__.constructor.apply(this, arguments);
      return _ref13;
    }

    RecursiveClamda.prototype.call = function(value) {
      return new CApply(this, value);
    };

    return RecursiveClamda;

  })(Clamda);

  IdCont = (function(_super) {
    __extends(IdCont, _super);

    function IdCont() {
      _ref14 = IdCont.__super__.constructor.apply(this, arguments);
      return _ref14;
    }

    return IdCont;

  })(Clamda);

  JSFun = (function(_super) {
    __extends(JSFun, _super);

    function JSFun(fun) {
      this.fun = fun;
      JSFun.__super__.constructor.apply(this, arguments);
    }

    JSFun.prototype.toString = function() {
      return "jsfun(" + this.fun + ")";
    };

    JSFun.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    return JSFun;

  })(Element);

  exports.VirtualOperation = VirtualOperation = (function(_super) {
    __extends(VirtualOperation, _super);

    function VirtualOperation(args) {
      this.args = args;
      VirtualOperation.__super__.constructor.apply(this, arguments);
    }

    VirtualOperation.prototype.toString = function() {
      var arg;

      return "vop_" + this._name + "(" + (((function() {
        var _i, _len, _ref15, _results;

        _ref15 = this.args;
        _results = [];
        for (_i = 0, _len = _ref15.length; _i < _len; _i++) {
          arg = _ref15[_i];
          _results.push(toString(arg));
        }
        return _results;
      }).call(this)).join(', ')) + ")";
    };

    return VirtualOperation;

  })(Element);

  BinaryOperation = (function(_super) {
    __extends(BinaryOperation, _super);

    function BinaryOperation() {
      _ref15 = BinaryOperation.__super__.constructor.apply(this, arguments);
      return _ref15;
    }

    BinaryOperation.prototype.toString = function() {
      return "" + (toString(this.args[0])) + this.symbol + (toString(this.args[1]));
    };

    BinaryOperation.prototype.toCode = function(compiler) {
      var args;

      args = this.args;
      return "" + (expressionToCode(compiler, args[0])) + " " + this.symbol + " " + (expressionToCode(compiler, args[1]));
    };

    BinaryOperation.prototype._effect = false;

    return BinaryOperation;

  })(VirtualOperation);

  UnaryOperation = (function(_super) {
    __extends(UnaryOperation, _super);

    function UnaryOperation() {
      _ref16 = UnaryOperation.__super__.constructor.apply(this, arguments);
      return _ref16;
    }

    UnaryOperation.prototype.toString = function() {
      return "" + this.symbol + (toString(this.args[0]));
    };

    UnaryOperation.prototype.toCode = function(compiler) {
      return "" + this.symbol + (expressionToCode(compiler, this.args[0]));
    };

    UnaryOperation.prototype._effect = false;

    return UnaryOperation;

  })(BinaryOperation);

  Fun = (function(_super) {
    __extends(Fun, _super);

    function Fun(func) {
      this.func = func;
      Fun.__super__.constructor.apply(this, arguments);
    }

    Fun.prototype.toString = function() {
      return "fun(" + this.func + ")";
    };

    Fun.prototype.apply = function(args) {
      return new Apply(this, args);
    };

    return Fun;

  })(Element);

  Apply = (function(_super) {
    __extends(Apply, _super);

    function Apply(caller, args) {
      this.caller = caller;
      this.args = args;
      Apply.__super__.constructor.apply(this, arguments);
    }

    Apply.prototype.toString = function() {
      var arg;

      return "(" + (toString(this.caller)) + ")(" + (((function() {
        var _i, _len, _ref17, _results;

        _ref17 = this.args;
        _results = [];
        for (_i = 0, _len = _ref17.length; _i < _len; _i++) {
          arg = _ref17[_i];
          _results.push(toString(arg));
        }
        return _results;
      }).call(this)).join(', ')) + ")";
    };

    return Apply;

  })(Element);

  Deref = (function(_super) {
    __extends(Deref, _super);

    function Deref(exp) {
      this.exp = exp;
      Deref.__super__.constructor.apply(this, arguments);
    }

    Deref.prototype.toString = function() {
      return "deref(" + (toString(this.exp)) + ")";
    };

    return Deref;

  })(Element);

  If = (function(_super) {
    __extends(If, _super);

    function If(test, then_, else_) {
      this.test = test;
      this.then_ = then_;
      this.else_ = else_;
      If.__super__.constructor.apply(this, arguments);
    }

    If.prototype.toString = function() {
      return "if(" + (toString(this.test)) + ", " + (toString(this.then_)) + ", " + (toString(this.else_)) + ")";
    };

    return If;

  })(Element);

  LabelStatement = (function(_super) {
    __extends(LabelStatement, _super);

    function LabelStatement(label, statement) {
      this.label = label;
      this.statement = statement;
      LabelStatement.__super__.constructor.apply(this, arguments);
    }

    LabelStatement.prototype.toString = function() {
      return "" + (toString(this.label)) + ": " + (toString(this.statement));
    };

    return LabelStatement;

  })(Element);

  While = (function(_super) {
    __extends(While, _super);

    function While(test, body) {
      this.test = test;
      this.body = body;
      While.__super__.constructor.apply(this, arguments);
    }

    While.prototype.toString = function() {
      return "while(" + (toString(this.test)) + ", " + (toString(this.body)) + ")";
    };

    return While;

  })(Element);

  DoWhile = (function(_super) {
    __extends(DoWhile, _super);

    function DoWhile(test, body) {
      this.test = test;
      this.body = body;
      DoWhile.__super__.constructor.apply(this, arguments);
    }

    DoWhile.prototype.toString = function() {
      return "dowhile(" + (toString(this.test)) + ", " + (toString(this.body)) + ")";
    };

    return DoWhile;

  })(While);

  For = (function(_super) {
    __extends(For, _super);

    function For(init, test, step, body) {
      this.init = init;
      this.test = test;
      this.step = step;
      this.body = body;
      For.__super__.constructor.apply(this, arguments);
    }

    For.prototype.toString = function() {
      return "for(" + (toString(this.test)) + ", " + (toString(this.body)) + ")";
    };

    return For;

  })(Element);

  ForIn = (function(_super) {
    __extends(ForIn, _super);

    function ForIn(vari, container, body) {
      this.vari = vari;
      this.container = container;
      this.body = body;
      ForIn.__super__.constructor.apply(this, arguments);
    }

    ForIn.prototype.toString = function() {
      return "forin(" + (toString(this.vari)) + ", " + (toString(this.container)) + ", " + (toString(this.body)) + ")";
    };

    return ForIn;

  })(Element);

  ForOf = (function(_super) {
    __extends(ForOf, _super);

    function ForOf(vari, container, body) {
      this.vari = vari;
      this.container = container;
      this.body = body;
      ForOf.__super__.constructor.apply(this, arguments);
    }

    ForOf.prototype.toString = function() {
      return "forof(" + (toString(this.vari)) + ", " + (toString(this.container)) + ", " + (toString(this.body)) + ")";
    };

    return ForOf;

  })(Element);

  Break = (function(_super) {
    __extends(Break, _super);

    function Break(label) {
      this.label = label;
      Break.__super__.constructor.apply(this, arguments);
    }

    Break.prototype.toString = function() {
      return "break " + (toString(this.label));
    };

    return Break;

  })(Element);

  Continue = (function(_super) {
    __extends(Continue, _super);

    function Continue() {
      _ref17 = Continue.__super__.constructor.apply(this, arguments);
      return _ref17;
    }

    Continue.prototype.toString = function() {
      return "continue " + (toString(this.label));
    };

    return Continue;

  })(Break);

  Try = (function(_super) {
    __extends(Try, _super);

    function Try(test, catches, final) {
      this.test = test;
      this.catches = catches;
      this.final = final;
      Try.__super__.constructor.apply(this, arguments);
    }

    Try.prototype.toString = function() {
      return "try(" + (toString(this.test)) + ", " + (toString(this.catches)) + ", " + (toString(this.final)) + ")";
    };

    return Try;

  })(Element);

  replace = function(exp, param, value) {
    var exp_replace;

    exp_replace = exp != null ? exp.replace : void 0;
    if (exp_replace) {
      return exp_replace.call(exp, param, value);
    } else {
      return exp;
    }
  };

  Var.prototype.replace = function(param, value) {
    if (this.toString() === param) {
      return value;
    } else {
      return this;
    }
  };

  Assign.prototype.replace = function(param, value) {
    var assign;

    assign = new this.constructor(this.left, replace(this.exp, param, value));
    if (this.isParamAssign) {
      assign.isParamAssign = true;
    }
    if (this.root) {
      assign.root = this.root;
    } else {
      assign.root = this;
    }
    return assign;
  };

  If.prototype.replace = function(param, value) {
    return new If(replace(this.test, param, value), replace(this.then_, param, value), replace(this.else_, param, value));
  };

  LabelStatement.prototype.replace = function(param, value) {
    return new LabelStatement(this.label, replace(this.statement, param, value));
  };

  While.prototype.replace = function(param, value) {
    return new While(replace(this.test, param, value), replace(this.body, param, value));
  };

  For.prototype.replace = function(param, value) {
    return new For(replace(this.init, param, value), replace(this.test, param, value), replace(this.step, param, value), replace(this.body, param, value));
  };

  ForIn.prototype.replace = function(param, value) {
    return new ForIn(replace(this.vari, param, value), replace(this.container, param, value), replace(this.body, param, value));
  };

  Break.prototype.replace = function(param, value) {
    return this;
  };

  Try.prototype.replace = function(param, value) {
    var catches, clause;

    catches = (function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.catches;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        clause = _ref18[_i];
        _results.push([replace(clause[0], param, value), replace(clause[1], param, value)]);
      }
      return _results;
    }).call(this);
    return new Try(replace(this.test, param, value), replace(catches, param, value), replace(this.final, param, value));
  };

  New.prototype.replace = function(param, value) {
    return new this.constructor(replace(this.value, param, value));
  };

  Lamda.prototype.replace = function(param, value) {
    return this;
  };

  Clamda.prototype.replace = function(param, value) {
    return this;
  };

  IdCont.prototype.replace = function(param, value) {
    return this;
  };

  Apply.prototype.replace = function(param, value) {
    var a;

    return new Apply(replace(this.caller, param, value), (function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(replace(a, param, value));
      }
      return _results;
    }).call(this));
  };

  VirtualOperation.prototype.replace = function(param, value) {
    var a;

    return new this.constructor((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(replace(a, param, value));
      }
      return _results;
    }).call(this));
  };

  Begin.prototype.replace = function(param, value) {
    var exp;

    return new this.constructor((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.exps;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        exp = _ref18[_i];
        _results.push(replace(exp, param, value));
      }
      return _results;
    }).call(this));
  };

  Deref.prototype.replace = function(param, value) {
    return new Deref(value.replace(this.exp, param));
  };

  JSFun.prototype.replace = function(param, value) {
    return new JSFun(replace(this.fun, param, value));
  };

  optimize = function(exp, env, compiler) {
    var exp_optimize;

    exp_optimize = exp != null ? exp.optimize : void 0;
    if (exp_optimize) {
      return exp_optimize.call(exp, env, compiler);
    } else {
      return exp;
    }
  };

  isParam = function(vari, lamda) {
    var param, _i, _len, _ref18;

    if (lamda instanceof Clamda) {
      return vari.toString() === lamda.v.toString();
    } else {
      _ref18 = lamda.params;
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        param = _ref18[_i];
        if (this.toString() === param.toString()) {
          return true;
        }
      }
      return false;
    }
  };

  Var.prototype.optimize = function(env, compiler) {
    var content, envExp, lamda, outerEnv;

    lamda = env.lamda;
    if (!isParam(this, lamda)) {
      lamda.vars[this] = this;
    }
    if (this.isRecursive) {
      return this;
    }
    outerEnv = env.outer;
    if (outerEnv) {
      envExp = outerEnv.lookup(this);
      if (envExp instanceof Assign) {
        envExp._removed = false;
      }
    }
    content = env.lookup(this);
    if (content instanceof Assign) {
      if (this.isRecursive) {
        return this;
      } else {
        return content.exp;
      }
    } else if (_.isArray(content)) {
      return this;
    } else {
      return content;
    }
  };

  Symbol.prototype.optimize = function(env, compiler) {
    return this;
  };

  Assign.prototype.optimize = function(env, compiler) {
    var a, assign, exp, lamda, left, root, userlamda;

    lamda = env.lamda;
    left = this.left;
    if (left instanceof VirtualOperation) {
      left = new left.constructor((function() {
        var _i, _len, _ref18, _results;

        _ref18 = left.args;
        _results = [];
        for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
          a = _ref18[_i];
          _results.push(compiler.optimize(a, env));
        }
        return _results;
      })());
    } else {
      if (left.isConst && left.assigned) {
        if (this.root) {
          root = this.root;
        } else {
          root = this;
        }
        if (left.assigned !== root) {
          throw new Error(this, "should not assign to const more than once.");
        }
      }
      if (left instanceof UserVar) {
        userlamda = env.userlamda;
        if (userlamda && !isParam(left, userlamda)) {
          userlamda.locals[left] = left;
        }
      } else {
        if (!isParam(left, lamda)) {
          lamda.locals[left] = left;
          if (left instanceof BlockVar) {
            left.lamda = lamda;
          }
        }
      }
    }
    exp = compiler.optimize(this.exp, env);
    assign = new this.constructor(left, exp);
    assign.root = root;
    if (this.isParamAssign) {
      assign.isParamAssign = true;
    }
    left.assigned = assign.root;
    if (isValue(exp)) {
      if (exp instanceof Lamda && left.isRecursive) {
        env.bindings[left] = left;
        assign._removed = false;
      } else if (!isAtomic(exp)) {
        env.bindings[left] = left;
        assign._removed = false;
      } else if (left instanceof VirtualOperation) {
        assign._removed = false;
      } else {
        env.bindings[left] = assign;
      }
    } else if (exp instanceof Var && exp.isConst) {
      env.bindings[left] = assign;
      assign._removed = false;
    } else {
      env.bindings[left] = left;
      assign._removed = false;
    }
    return assign;
  };

  LocalDecl.prototype.optimize = function(env, compiler) {
    var vari, _i, _len, _ref18;

    _ref18 = this.vars;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      vari = _ref18[_i];
      if (vari instanceof UserVar) {
        env.userlamda.locals[vari] = vari;
      } else {
        env.lamda.locals[vari] = vari;
      }
    }
    return this;
  };

  NonlocalDecl.prototype.optimize = function(env, compiler) {
    var vari, _i, _len, _ref18;

    _ref18 = this.vars;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      vari = _ref18[_i];
      if (vari instanceof UserVar) {
        env.userlamda.nonlocals[vari] = vari;
      } else {
        env.lamda.nonlocals[vari] = vari;
      }
    }
    return this;
  };

  If.prototype.optimize = function(env, compiler) {
    var else_, test, test_bool, then_;

    test = optimize(this.test, env, compiler);
    test_bool = boolize(test);
    if (test_bool === true) {
      then_ = optimize(this.then_, env, compiler);
      if (then_ instanceof If && then_.test === test) {
        then_ = then_.then_;
      }
      return then_;
    } else if (test_bool === false) {
      else_ = optimize(this.else_, env, compiler);
      if (else_ instanceof If && else_.test === test) {
        else_ = else_.else_;
      }
      return else_;
    } else {
      then_ = optimize(this.then_, env, compiler);
      else_ = optimize(this.else_, env, compiler);
      if (then_ instanceof If && then_.test === test) {
        then_ = then_.then_;
      }
      if (else_ instanceof If && else_.test === test) {
        else_ = else_.else_;
      }
      return new If(test, then_, else_);
    }
  };

  LabelStatement.prototype.optimize = function(env, compiler) {
    return new LabelStatement(this.label, optimize(this.statement, env, compiler));
  };

  While.prototype.optimize = function(env, compiler) {
    var test;

    test = optimize(this.test, env, compiler);
    return new While(test, this.body);
  };

  For.prototype.optimize = function(env, compiler) {
    var body, init, step, test;

    init = optimize(this.init, env, compiler);
    test = optimize(this.test, env, compiler);
    step = optimize(this.step, env, compiler);
    body = optimize(this.body, env, compiler);
    return new For(init, test, step, body);
  };

  ForIn.prototype.optimize = function(env, compiler) {
    var test;

    return new ForIn(optimize(this.vari, env, compiler), test = optimize(container, env, compiler), optimize(this.body, env, compiler));
  };

  Break.prototype.optimize = function(env, compiler) {
    return this;
  };

  Try.prototype.optimize = function(env, compiler) {
    var test;

    test = optimize(this.test, env, compiler);
    return new Try(test, this.catches, this.final);
  };

  New.prototype.optimize = function(env, compiler) {
    return new this.constructor(compiler.optimize(this.value, env));
  };

  Lamda.prototype.optimize = function(env, compiler) {
    var bindings, body, envValue, k, locals, newEnv, nonlocals, p, parentBindings, parentLamda, parentVars, v, vars, _i, _len, _ref18;

    parentLamda = env.lamda;
    parentBindings = env.bindings;
    if (this._optimized && !this.isTransparent) {
      if (parentLamda) {
        vars = this.vars;
        for (k in vars) {
          v = vars[k];
          if (hasOwnProperty.call(vars, k)) {
            envValue = parentBindings[k];
            if (envValue instanceof Assign) {
              envValue._removed = false;
            }
          }
        }
      }
      return this;
    }
    bindings = {};
    _ref18 = this.params;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      p = _ref18[_i];
      bindings[p] = p;
    }
    this.locals = locals = {};
    this.nonlocals = nonlocals = {};
    this.vars = vars = {};
    if (this.isTransparent) {
      newEnv = newEnv = env.extendBindings(null, this);
    } else {
      newEnv = env.extendBindings(bindings, this);
    }
    body = compiler.optimize(this.body, newEnv);
    for (k in vars) {
      v = vars[k];
      if (hasOwnProperty.call(vars, k) && hasOwnProperty.call(locals, k)) {
        delete vars[k];
      }
    }
    for (k in nonlocals) {
      v = nonlocals[k];
      if (hasOwnProperty.call(nonlocals, k)) {
        vars[k] = v;
      }
    }
    if (!this.isTransparent && parentLamda) {
      parentVars = parentLamda.vars;
      for (k in vars) {
        v = vars[k];
        if (hasOwnProperty.call(vars, k)) {
          if (!isParam(v, parentLamda)) {
            parentVars[k] = v;
          }
          envValue = parentBindings[k];
          if (envValue instanceof Assign) {
            envValue._removed = false;
          }
        }
      }
    }
    this.body = postOptimize(body, compiler, newEnv);
    this._optimized = true;
    return this;
  };

  IdCont.prototype.optimize = function(env, compiler) {
    return this;
  };

  Apply.prototype.optimize = function(env, compiler) {
    var a, caller, optimizeApply;

    caller = compiler.optimize(this.caller, env);
    optimizeApply = caller.optimizeApply;
    if (optimizeApply) {
      return optimizeApply.call(caller, this.args, env, compiler);
    } else {
      if (caller instanceof BlockVar && env.lamda !== caller.lamda && !(env.lamda instanceof BlockLamda)) {
        caller.convertable = false;
      }
      return new Apply(caller, (function() {
        var _i, _len, _ref18, _results;

        _ref18 = this.args;
        _results = [];
        for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
          a = _ref18[_i];
          _results.push(compiler.optimize(a, env));
        }
        return _results;
      }).call(this));
    }
  };

  VirtualOperation.prototype.optimize = function(env, compiler) {
    var a, args, _i, _isValue, _len;

    args = (function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(compiler.optimize(a, env));
      }
      return _results;
    }).call(this);
    _isValue = true;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      if (!isValue(a)) {
        _isValue = false;
        break;
      }
    }
    if (_isValue && this.func) {
      return this.func.apply(null, args);
    } else {
      return new this.constructor(args);
    }
  };

  Begin.prototype.optimize = function(env, compiler) {
    var e, exp, result, _i, _len, _ref18;

    result = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      exp = _ref18[_i];
      e = compiler.optimize(exp, env);
      if (e instanceof Begin) {
        result = result.concat(e.exps);
      } else {
        result.push(e);
      }
      if (e instanceof Throw || e instanceof Return) {
        break;
      }
    }
    if (result.length > 1) {
      return new this.constructor(result);
    } else {
      return result[0];
    }
  };

  Deref.prototype.optimize = function(env, compiler) {
    var exp;

    exp = this.exp;
    if (_.isString(exp)) {
      return exp;
    } else if (_.isNumber(exp)) {
      return exp;
    } else {
      return new Deref(compiler.optimize(exp, env));
    }
  };

  JSFun.prototype.optimize = function(env, compiler) {
    return new JSFun(compiler.optimize(this.fun, env));
  };

  Lamda.prototype.optimizeApply = function(args, env, compiler) {
    var body, exps, i, lamda, p;

    exps = (function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.params;
      _results = [];
      for (i = _i = 0, _len = _ref18.length; _i < _len; i = ++_i) {
        p = _ref18[i];
        _results.push(il.paramassign(p, args[i]));
      }
      return _results;
    }).call(this);
    exps.push(this.body);
    body = compiler.optimize(il.begin.apply(il, exps), env);
    body = postOptimize(body, compiler, env);
    if (!isStatement(body)) {
      return body;
    } else {
      lamda = new this.constructor([], body);
      lamda._optimized = true;
      return new Apply(lamda, []);
    }
  };

  Clamda.prototype.optimizeApply = function(args, env, compiler) {
    return il.begin(il.paramassign(this.v, args[0]), this.body).optimize(env, compiler);
  };

  RecursiveClamda.prototype.optimizeApply = function(args, env, compiler) {
    return il.begin(il.paramassign(this.v, args[0]), this.body).optimize(env, compiler);
  };

  IdCont.prototype.optimizeApply = function(args, env, compiler) {
    return compiler.optimize(args[0], env);
  };

  JSFun.prototype.optimizeApply = function(args, env, compiler) {
    var a, f, t;

    args = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        a = args[_i];
        _results.push(compiler.optimize(a, env));
      }
      return _results;
    })();
    f = this.fun;
    t = typeof f;
    if (t === 'function') {
      return new Apply(f, args);
    } else if (t === 'string') {
      return new Apply(il.fun(f), args);
    } else {
      return f.apply(args).optimize(env, compiler);
    }
  };

  MAX_EXTEND_CODE_SIZE = 10;

  hasOwnProperty = Object.prototype.hasOwnProperty;

  isEmpty = function(obj) {
    var key;

    for (key in obj) {
      if (hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };

  codeSize = function(exp) {
    var exp_codeSize;

    exp_codeSize = exp != null ? exp.codeSize : void 0;
    if (exp_codeSize) {
      return exp_codeSize.call(exp);
    } else {
      return 1;
    }
  };

  Var.prototype.codeSize = function() {
    return 1;
  };

  New.prototype.codeSize = function() {
    return codeSize(this.value) + 1;
  };

  If.prototype.codeSize = function() {
    return codeSize(this.test) + codeSize(this.then_) + codeSize(this.else_) + 1;
  };

  LabelStatement.prototype.codeSize = function() {
    return codeSize(this.statement);
  };

  For.prototype.codeSize = function() {
    return codeSize(this.init) + codeSize(this.test) + codeSize(this.step) + codeSize(this.body) + 2;
  };

  ForIn.prototype.codeSize = function() {
    return codeSize(this.vari) + codeSize(this.container) + codeSize(this.body) + 2;
  };

  While.prototype.codeSize = function() {
    return codeSize(this.test) + codeSize(this.body) + 2;
  };

  Break.prototype.codeSize = function() {
    return 1;
  };

  Try.prototype.codeSize = function() {
    return codeSize(this.test) + codeSize(this.catches) + codeSize(this.final) + 2;
  };

  Begin.prototype.codeSize = function() {
    return _.reduce(this.exps, (function(memo, e) {
      return memo + codeSize(e);
    }), 0);
  };

  VirtualOperation.prototype.codeSize = function() {
    return 1;
  };

  Lamda.prototype.codeSize = function() {
    return codeSize(this.body) + 2;
  };

  Clamda.prototype.codeSize = function() {
    return codeSize(this.body) + 1;
  };

  Apply.prototype.codeSize = function() {
    return _.reduce(this.args, (function(memo, e) {
      return memo + codeSize(e);
    }), codeSize(this.caller));
  };

  boolize = function(exp) {
    var exp_boolize;

    exp_boolize = exp != null ? exp.boolize : void 0;
    if (exp_boolize) {
      return exp_boolize.call(exp);
    } else {
      return !!exp;
    }
  };

  Var.prototype.boolize = function() {
    return void 0;
  };

  If.prototype.boolize = function() {
    var b;

    b = boolize(this.test);
    if (b === void 0) {
      void 0;
    }
    if (b === true) {
      return boolize(this.then_);
    } else {
      return boolize(this.else_);
    }
  };

  LabelStatement.prototype.boolize = function() {
    return boolize(this.statement);
  };

  For.prototype.boolize = function() {
    return void 0;
  };

  ForIn.prototype.boolize = function() {
    return void 0;
  };

  While.prototype.boolize = function() {
    return void 0;
  };

  Try.prototype.boolize = function() {
    return void 0;
  };

  Break.prototype.boolize = function() {
    return void 0;
  };

  Begin.prototype.boolize = function() {
    var exps;

    exps = this.exps;
    return boolize(exps[exps.length - 1]);
  };

  VirtualOperation.prototype.boolize = function() {
    var a, _i, _len, _ref18, _ref19;

    _ref18 = this.args;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      a = _ref18[_i];
      if (boolize(a) === void 0) {
        return void 0;
      }
    }
    return !!((_ref19 = this.func) != null ? _ref19.apply(null, this.args) : void 0) || void 0;
  };

  Lamda.prototype.boolize = function() {
    return true;
  };

  Clamda.prototype.boolize = function() {
    return true;
  };

  Apply.prototype.boolize = function() {
    var a, caller, _i, _len, _ref18, _ref19;

    caller = this.caller;
    if (caller instanceof Lamda || caller instanceof Clamda) {
      return boolize(caller.body);
    }
    if (caller instanceof Var) {
      return void 0;
    }
    _ref18 = this.args;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      a = _ref18[_i];
      if (boolize(a) === void 0) {
        return void 0;
      }
    }
    return !!((_ref19 = caller.func) != null ? _ref19.apply(null, this.args) : void 0) || void 0;
  };

  isDeclaration = function(exp) {
    var exp_isDeclaration;

    exp_isDeclaration = exp != null ? exp.isDeclaration : void 0;
    if (exp_isDeclaration) {
      return exp_isDeclaration.call(exp);
    } else {
      return false;
    }
  };

  isValue = function(exp) {
    var exp_isValue;

    exp_isValue = exp != null ? exp.isValue : void 0;
    if (exp_isValue) {
      return exp_isValue.call(exp);
    } else {
      return true;
    }
  };

  isAtomic = function(exp) {
    return !_.isObject(exp);
  };

  il.PURE = 0;

  il.EFFECT = 1;

  il.IO = 2;

  il.pure = pure = function(exp) {
    exp._effect = il.PURE;
    return exp;
  };

  il.effect = function(exp) {
    exp._effect = il.EFFECT;
    return exp;
  };

  il.io = function(exp) {
    exp._effect = il.IO;
    return exp;
  };

  sideEffect = function(exp) {
    var exp_sideEffect;

    exp_sideEffect = exp != null ? exp.sideEffect : void 0;
    if (exp_sideEffect) {
      return exp_sideEffect.call(exp);
    } else {
      return il.PURE;
    }
  };

  expsEffect = function(exps) {
    var e, eff, effect, _i, _len;

    effect = il.PURE;
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      eff = sideEffect(e);
      if (eff === il.IO) {
        return il.IO;
      }
      if (eff === il.EFFECT) {
        effect = eff;
      }
    }
    return effect;
  };

  Element.prototype.sideEffect = function() {
    return il.IO;
  };

  Var.prototype.sideEffect = function() {
    return il.PURE;
  };

  NonlocalDecl.prototype.sideEffect = function() {
    return il.PURE;
  };

  Assign.prototype.sideEffect = function() {
    return il.EFFECT;
  };

  New.prototype.sideEffect = function() {
    return sideEffect(this.value);
  };

  Throw.prototype.sideEffect = function() {
    return il.IO;
  };

  New.prototype.sideEffect = function() {
    return sideEffect(this.value);
  };

  If.prototype.sideEffect = function() {
    return expsEffect([this.test, this.then_, this.else_]);
  };

  LabelStatement.prototype.sideEffect = function() {
    return sideEffect(this.statement);
  };

  For.prototype.sideEffect = function() {
    return expsEffect([this.init, this.test, this.step, this.body]);
  };

  ForIn.prototype.sideEffect = function() {
    return expsEffect([this.container, this.body]);
  };

  While.prototype.sideEffect = function() {
    return expsEffect([this.test, this.body]);
  };

  Break.prototype.sideEffect = function() {
    return il.EFFECT;
  };

  Try.prototype.sideEffect = function() {
    return expsEffect([this.test, this.catches, this.final]);
  };

  Begin.prototype.sideEffect = function() {
    return expsEffect(this.exps);
  };

  Lamda.prototype.sideEffect = function() {
    return il.PURE;
  };

  JSFun.prototype.sideEffect = function() {
    return il.PURE;
  };

  Fun.prototype.sideEffect = function() {
    return il.PURE;
  };

  Apply.prototype.sideEffect = function() {
    return Math.max(applySideEffect(this.caller), expsEffect(this.args));
  };

  VirtualOperation.prototype.sideEffect = function() {
    return Math.max(this._effect, expsEffect(this.args));
  };

  applySideEffect = function(exp) {
    var exp_applySideEffect;

    exp_applySideEffect = exp != null ? exp.applySideEffect : void 0;
    if (exp_applySideEffect) {
      return exp_applySideEffect.call(exp);
    } else {
      return il.IO;
    }
  };

  Element.prototype.applySideEffect = function() {
    throw new NotImplement(this, 'applySideEffect');
  };

  Var.prototype.applySideEffect = function() {
    return il.IO;
  };

  Apply.prototype.applySideEffect = function() {
    return il.IO;
  };

  VirtualOperation.prototype.applySideEffect = function() {
    return il.IO;
  };

  Fun.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return il.IO;
    }
  };

  JSFun.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return il.IO;
    }
  };

  Lamda.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return sideEffect(this.body);
    }
  };

  Clamda.prototype.applySideEffect = function() {
    if (this._effect != null) {
      return this._effect;
    } else {
      return sideEffect(this.body);
    }
  };

  IO = function(exp) {
    var exp_IO;

    exp_IO = exp != null ? exp.IO : void 0;
    if (exp_IO) {
      return exp_IO.call(exp);
    } else {
      return false;
    }
  };

  postOptimize = function(exp, compiler, env) {
    var exp_postOptimize;

    exp_postOptimize = exp != null ? exp.postOptimize : void 0;
    if (exp_postOptimize) {
      return exp_postOptimize.call(exp, compiler, env);
    } else {
      return exp;
    }
  };

  Assign.prototype.postOptimize = function(compiler, env) {
    return this;
  };

  If.prototype.postOptimize = function(compiler, env) {
    return new If(this.test, postOptimize(this.then_, compiler, env), postOptimize(this.else_, compiler, env));
  };

  LabelStatement.prototype.postOptimize = function(compiler, env) {
    return this;
  };

  While.prototype.postOptimize = function(compiler, env) {
    return new While(this.test, postOptimize(this.body, compiler, env));
  };

  For.prototype.postOptimize = function(compiler, env) {
    return new For(postOptimize(this.init, compiler, env), postOptimize(this.test, compiler, env), postOptimize(this.step, compiler, env), postOptimize(this.body, compiler, env));
  };

  ForIn.prototype.postOptimize = function(compiler, env) {
    return new ForIn(this.vari, this.container, postOptimize(this.body, compiler, env));
  };

  Break.prototype.postOptimize = function(compiler, env) {
    return this;
  };

  Try.prototype.postOptimize = function(compiler, env) {
    return new Try(postOptimize(this.test, compiler, env), postOptimize(this.catches, compiler, env), postOptimize(this.final, compiler, env));
  };

  Begin.prototype.postOptimize = function(compiler, env) {
    var e, exps, length, result, waitPop, _i, _len;

    exps = this.exps;
    length = exps.length;
    if (length === 0 || length === 1) {
      throw new Error("begin should have at least one exp");
    }
    result = [];
    waitPop = false;
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      if (e instanceof Assign && e.removed()) {
        continue;
      }
      if (waitPop) {
        result.pop();
      }
      e = postOptimize(e, compiler, env);
      if (e instanceof Begin) {
        result = result.concat(e.exps);
        waitPop = sideEffect(result[result.length - 1]) === il.PURE;
      } else if (e instanceof Throw) {
        result.push(e);
        break;
      } else if (e instanceof Return) {
        throw new Error(e);
      } else {
        result.push(e);
        waitPop = sideEffect(e) === il.PURE;
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return new this.constructor(result);
    }
  };

  Lamda.prototype.postOptimize = function(compiler, env) {
    return this;
  };

  Apply.prototype.postOptimize = function(compiler, env) {
    return this;
  };

  VirtualOperation.prototype.postOptimize = function(compiler, env) {
    return this;
  };

  setJsified = function(exp) {
    if (exp != null) {
      exp._jsified = true;
    }
    return exp;
  };

  isJsified = function(exp) {
    return (exp != null ? exp._jsified : void 0) || false;
  };

  jsify = function(exp, compiler, env) {
    var exp_jsify;

    if (isJsified(exp)) {
      return exp;
    }
    exp_jsify = exp != null ? exp.jsify : void 0;
    if (exp_jsify) {
      return exp_jsify.call(exp, compiler, env);
    } else {
      return exp;
    }
  };

  Assign.prototype.jsify = function(compiler, env) {
    var body, exp, exps, i, left, length, params, result, tempParams, _i, _j;

    if (this._jsified) {
      return this;
    }
    left = this.left;
    exp = jsify(this.exp, compiler, env);
    if (left instanceof BlockVar && left.convertable) {
      return il.label(left, il.while_(1, convertBlockLamdaBody(exp.body, left)));
    } else {
      if (exp instanceof OptimizableRecuisiveLamda) {
        params = exp.params;
        length = params.length;
        exp.vari = left;
        if (length > 1) {
          exp.tempParams = tempParams = (function() {
            var _i, _results;

            _results = [];
            for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
              _results.push(params[i]);
            }
            return _results;
          })();
          getConvertParameters(exp.body, compiler, exp);
          body = convertOptRecursive(exp.body, exp);
          exps = [body];
          for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
            if (tempParams[i] !== params[i]) {
              exps.push(il.assign(params[i], tempParams[i]));
            }
          }
          body = il.begin.apply(il, exps);
        } else {
          body = convertOptRecursive(exp.body, exp);
        }
        exp.body = il.begin(exp.init, il.while_(1, body));
      }
      if (exp instanceof TailRecuisiveLamda) {
        params = exp.params;
        length = params.length;
        exp.vari = left;
        if (length > 1) {
          exp.tempParams = tempParams = (function() {
            var _j, _results;

            _results = [];
            for (i = _j = 0; 0 <= length ? _j < length : _j > length; i = 0 <= length ? ++_j : --_j) {
              _results.push(params[i]);
            }
            return _results;
          })();
          getConvertParameters(exp.body, compiler, exp);
          body = convertTailRecursive(exp.body, exp);
          exps = [body];
          for (i = _j = 0; 0 <= length ? _j < length : _j > length; i = 0 <= length ? ++_j : --_j) {
            if (tempParams[i] !== params[i]) {
              exps.push(il.assign(params[i], tempParams[i]));
            }
          }
          body = il.begin.apply(il, exps);
        } else {
          body = convertTailRecursive(exp.body, exp);
        }
        exp.body = il.while_(1, body);
      }
    }
    result = new Assign(left, exp);
    if (this.root) {
      result.root = this.root;
    } else {
      result.root = this;
    }
    result._jsified = true;
    return result;
  };

  New.prototype.jsify = function(compiler, env) {
    return new this.constructor(jsify(this.value, compiler, env));
  };

  If.prototype.jsify = function(compiler, env) {
    return new If(jsify(this.test, compiler, env), jsify(this.then_, compiler, env), jsify(this.else_, compiler, env));
  };

  LabelStatement.prototype.jsify = function(compiler, env) {
    return new LabelStatement(this.label, jsify(this.statement, compiler, env));
  };

  While.prototype.jsify = function(compiler, env) {
    return new While(jsify(this.test, compiler, env), jsify(this.body, compiler, env));
  };

  For.prototype.jsify = function(compiler, env) {
    return new For(jsify(this.init, compiler, env), jsify(this.test, compiler, env), jsify(this.step, compiler, env), jsify(this.body, compiler, env));
  };

  ForIn.prototype.jsify = function(compiler, env) {
    return new ForIn(jsify(this.vari, compiler, env), jsify(this.container, compiler, env), jsify(this.body, compiler, env));
  };

  Break.prototype.jsify = function(compiler, env) {
    return this;
  };

  Try.prototype.jsify = function(compiler, env) {
    return new Try(jsify(this.test, compiler, env), jsify(this.catches, compiler, env), jsify(this.final, compiler, env));
  };

  Begin.prototype.jsify = function(compiler, env) {
    var e, exps, length, result, waitPop, _i, _len;

    exps = this.exps;
    length = exps.length;
    if (length === 0 || length === 1) {
      throw new Error("begin should have at least one exp");
    }
    result = [];
    waitPop = false;
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      if (waitPop) {
        result.pop();
      }
      e = jsify(e, compiler, env);
      if (e instanceof Begin) {
        result = result.concat(e.exps);
        waitPop = sideEffect(result[result.length - 1]) === il.PURE;
      } else if (e instanceof LocalDecl) {
        continue;
      } else if (e instanceof New) {
        result.push(e);
        waitPop = sideEffect(e) === il.PURE;
      } else if (e instanceof Throw) {
        result.push(e);
        break;
      } else if (e instanceof Return) {
        throw new Error(e);
      } else {
        result.push(e);
        waitPop = sideEffect(e) === il.PURE;
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return new this.constructor(result);
    }
  };

  Lamda.prototype.jsify = function(compiler, env) {
    var body, lamda;

    if (!this._jsifyied) {
      lamda = env.lamda;
      env.lamda = this;
      body = jsify(this.body, compiler, env);
      env.lamda = lamda;
      this.body = insertReturn(body);
      this._jsifyied = true;
    }
    return this;
  };

  Apply.prototype.jsify = function(compiler, env) {
    var a, body, caller;

    caller = this.caller;
    if (caller instanceof Lamda && caller.params.length === 0) {
      body = jsify(caller.body, compiler, env);
      if (!isStatement(body)) {
        return body;
      } else {
        return new Apply(new caller.constructor([], insertReturn(body)), []);
      }
    } else {
      if (caller instanceof BlockVar && caller.convertable && caller.lamda === env.lamda) {
        return caller;
      } else {
        return new this.constructor(jsify(this.caller, compiler, env), (function() {
          var _i, _len, _ref18, _results;

          _ref18 = this.args;
          _results = [];
          for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
            a = _ref18[_i];
            _results.push(jsify(a, compiler, env));
          }
          return _results;
        }).call(this));
      }
    }
  };

  VirtualOperation.prototype.jsify = function(compiler, env) {
    var a;

    return new this.constructor((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(jsify(a, compiler, env));
      }
      return _results;
    }).call(this));
  };

  convertBlockLamdaBody = function(exp, blockvar) {
    var exp_convertBlockLamdaBody;

    exp_convertBlockLamdaBody = exp != null ? exp.convertBlockLamdaBody : void 0;
    if (exp_convertBlockLamdaBody) {
      return exp_convertBlockLamdaBody.call(exp, blockvar);
    } else {
      return exp;
    }
  };

  Assign.prototype.convertBlockLamdaBody = function(blockvar) {
    return this;
  };

  If.prototype.convertBlockLamdaBody = function(blockvar) {
    return new If(this.test, convertBlockLamdaBody(this.then_, blockvar), convertBlockLamdaBody(this.else_, blockvar));
  };

  LabelStatement.prototype.convertBlockLamdaBody = function(blockvar) {
    return new LabelStatement(this.label, convertBlockLamdaBody(this.statement, blockvar));
  };

  While.prototype.convertBlockLamdaBody = function(blockvar) {
    return new While(this.test, convertBlockLamdaBody(this.body, blockvar));
  };

  Break.prototype.convertBlockLamdaBody = function(blockvar) {
    return this;
  };

  Try.prototype.convertBlockLamdaBody = function(blockvar) {
    return new Try(convertBlockLamdaBody(this.test, blockvar), convertBlockLamdaBody(this.catches, blockvar), convertBlockLamdaBody(this.final, blockvar));
  };

  Begin.prototype.convertBlockLamdaBody = function(blockvar) {
    var e, exps, _i, _len, _ref18;

    exps = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      e = _ref18[_i];
      exps.push(convertBlockLamdaBody(e, blockvar));
    }
    return new this.constructor(exps);
  };

  Throw.prototype.convertBlockLamdaBody = function(blockvar) {
    return this;
  };

  Return.prototype.convertBlockLamdaBody = function(blockvar) {
    var value;

    value = this.value;
    if (value instanceof Apply && value.caller === blockvar) {
      return il.continue_(blockvar);
    } else if (value instanceof BlockVar) {
      return this;
    } else {
      return new Begin([il.assign(blockvar, this.value), il.break_(blockvar)]);
    }
  };

  Lamda.prototype.convertBlockLamdaBody = function(blockvar) {
    this.body = convertBlockLamdaBody(this.body, blockvar);
    return this;
  };

  Apply.prototype.convertBlockLamdaBody = function(blockvar) {
    return this;
  };

  convertOptRecursive = function(exp, lamda) {
    var exp_convertOptRecursive;

    exp_convertOptRecursive = exp != null ? exp.convertOptRecursive : void 0;
    if (exp_convertOptRecursive) {
      return exp_convertOptRecursive.call(exp, lamda);
    } else {
      return exp;
    }
  };

  Assign.prototype.convertOptRecursive = function(lamda) {
    return this;
  };

  If.prototype.convertOptRecursive = function(lamda) {
    return new If(this.test, convertOptRecursive(this.then_, lamda), convertOptRecursive(this.else_, lamda));
  };

  LabelStatement.prototype.convertOptRecursive = function(lamda) {
    return new LabelStatement(this.label, convertOptRecursive(this.statement, lamda));
  };

  While.prototype.convertOptRecursive = function(lamda) {
    return new While(this.test, convertOptRecursive(this.body, lamda));
  };

  Break.prototype.convertOptRecursive = function(lamda) {
    return this;
  };

  Try.prototype.convertOptRecursive = function(lamda) {
    return new Try(convertOptRecursive(this.test, lamda), convertOptRecursive(this.catches, lamda), convertOptRecursive(this.final, lamda));
  };

  Begin.prototype.convertOptRecursive = function(lamda) {
    var e, exps, _i, _len, _ref18;

    exps = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      e = _ref18[_i];
      exps.push(convertOptRecursive(e, lamda));
    }
    return new this.constructor(exps);
  };

  Throw.prototype.convertOptRecursive = function(lamda) {
    return this;
  };

  Return.prototype.convertOptRecursive = function(lamda) {
    var else_, result, steps, then_, value;

    value = this.value;
    if (value instanceof If) {
      then_ = insertReturn(value.then_);
      then_ = convertOptRecursive(then_, lamda);
      else_ = insertReturn(value.else_);
      else_ = convertOptRecursive(else_, lamda);
      return new If(value.test, then_, else_);
    } else if (hasCallOf(value, lamda.vari)) {
      steps = [];
      result = convertOptResursiveCall(value, lamda, steps);
      if (result === lamda.vari) {
        return il.begin.apply(il, steps);
      } else {
        return il.begin(il.assign(lamda.vari, result), steps);
      }
    } else {
      lamda.init = il.assign(lamda.vari, value);
      return new Return(lamda.vari);
    }
  };

  Lamda.prototype.convertOptRecursive = function(lamda) {
    return this;
  };

  Apply.prototype.convertOptRecursive = function(lamda) {
    return this;
  };

  convertOptResursiveCall = function(exp, lamda, steps) {
    var exp_convertOptResursiveCall;

    exp_convertOptResursiveCall = exp != null ? exp.convertOptResursiveCall : void 0;
    if (exp_convertOptResursiveCall) {
      return exp_convertOptResursiveCall.call(exp, lamda, steps);
    } else {
      return false;
    }
  };

  Assign.prototype.convertOptResursiveCall = function(lamda, steps) {
    return new Assign(this.left, convertOptResursiveCall(this.exp, lamda, steps));
  };

  If.prototype.convertOptResursiveCall = function(lamda, steps) {
    return new If(this.test, convertOptResursiveCall(this.then_, lamda, steps), convertOptResursiveCall(this.else_, lamda, steps));
  };

  LabelStatement.prototype.convertOptResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  While.prototype.convertOptResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Break.prototype.convertOptResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Try.prototype.convertOptResursiveCall = function(lamda, steps) {
    return new Try(convertOptResursiveCall(this.test, lamda, steps), convertOptResursiveCall(this.catches, lamda, steps), convertOptResursiveCall(this.final, lamda, steps));
  };

  Begin.prototype.convertOptResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  ExpressionList.prototype.convertOptResursiveCall = function(lamda, steps) {
    var e, exps, _i, _len, _ref18;

    exps = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      e = _ref18[_i];
      exps.push(convertOptResursiveCall(e, lamda, steps));
    }
    return new this.constructor(exps);
  };

  Throw.prototype.convertOptResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Return.prototype.convertOptResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Lamda.prototype.convertOptResursiveCall = function(lamdavar) {
    throw new Error(this);
  };

  Apply.prototype.convertOptResursiveCall = function(lamda, steps) {
    var a, args, i, param, params, _i, _ref18;

    if (this.caller === lamda.vari) {
      params = lamda.params;
      args = this.args;
      for (i = _i = 0, _ref18 = args.length; 0 <= _ref18 ? _i < _ref18 : _i > _ref18; i = 0 <= _ref18 ? ++_i : --_i) {
        a = args[i];
        param = params[i];
        if (a.toString() !== param) {
          steps.push(new Assign(param, a));
        }
      }
      return lamda.vari;
    } else {
      return new Apply((function() {
        var _j, _len, _ref19, _results;

        _ref19 = this.args;
        _results = [];
        for (_j = 0, _len = _ref19.length; _j < _len; _j++) {
          a = _ref19[_j];
          _results.push(convertOptResursiveCall(a, lamda, steps));
        }
        return _results;
      }).call(this));
    }
  };

  VirtualOperation.prototype.convertOptResursiveCall = function(lamda, steps) {
    var a;

    return new this.constructor((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(convertOptResursiveCall(a, lamda, steps));
      }
      return _results;
    }).call(this));
  };

  convertTailRecursive = function(exp, lamda) {
    var exp_convertTailRecursive;

    exp_convertTailRecursive = exp != null ? exp.convertTailRecursive : void 0;
    if (exp_convertTailRecursive) {
      return exp_convertTailRecursive.call(exp, lamda);
    } else {
      return exp;
    }
  };

  Assign.prototype.convertTailRecursive = function(lamda) {
    return this;
  };

  If.prototype.convertTailRecursive = function(lamda) {
    return new If(this.test, convertTailRecursive(this.then_, lamda), convertTailRecursive(this.else_, lamda));
  };

  LabelStatement.prototype.convertTailRecursive = function(lamda) {
    return new LabelStatement(this.label, convertTailRecursive(this.statement, lamda));
  };

  While.prototype.convertTailRecursive = function(lamda) {
    return new While(this.test, convertTailRecursive(this.body, lamda));
  };

  Break.prototype.convertTailRecursive = function(lamda) {
    return this;
  };

  Try.prototype.convertTailRecursive = function(lamda) {
    return new Try(convertTailRecursive(this.test, lamda), convertTailRecursive(this.catches, lamda), convertTailRecursive(this.final, lamda));
  };

  Begin.prototype.convertTailRecursive = function(lamda) {
    var e, exps, _i, _len, _ref18;

    exps = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      e = _ref18[_i];
      exps.push(convertTailRecursive(e, lamda));
    }
    return new this.constructor(exps);
  };

  Throw.prototype.convertTailRecursive = function(lamda) {
    return this;
  };

  Return.prototype.convertTailRecursive = function(lamda) {
    var else_, result, steps, then_, value;

    value = this.value;
    if (value instanceof If) {
      then_ = insertReturn(value.then_);
      then_ = convertTailRecursive(then_, lamda);
      else_ = insertReturn(value.else_);
      else_ = convertTailRecursive(else_, lamda);
      return new If(value.test, then_, else_);
    } else if (hasCallOf(value, lamda.vari)) {
      steps = [];
      result = convertTailResursiveCall(value, lamda, steps);
      if (result === lamda.vari) {
        return il.begin.apply(il, steps);
      } else {
        return il.begin(il.assign(lamda.vari, result), steps);
      }
    } else {
      return this;
    }
  };

  Lamda.prototype.convertTailRecursive = function(lamda) {
    return this;
  };

  Apply.prototype.convertTailRecursive = function(lamda) {
    return this;
  };

  convertTailResursiveCall = function(exp, lamda, steps) {
    var exp_convertTailResursiveCall;

    exp_convertTailResursiveCall = exp != null ? exp.convertTailResursiveCall : void 0;
    if (exp_convertTailResursiveCall) {
      return exp_convertTailResursiveCall.call(exp, lamda, steps);
    } else {
      return false;
    }
  };

  Assign.prototype.convertTailResursiveCall = function(lamda, steps) {
    return new Assign(this.left, convertTailResursiveCall(this.exp, lamda, steps));
  };

  If.prototype.convertTailResursiveCall = function(lamda, steps) {
    return new If(this.test, convertTailResursiveCall(this.then_, lamda, steps), convertTailResursiveCall(this.else_, lamda, steps));
  };

  LabelStatement.prototype.convertTailResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  While.prototype.convertTailResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Break.prototype.convertTailResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Try.prototype.convertTailResursiveCall = function(lamda, steps) {
    return new Try(convertTailResursiveCall(this.test, lamda, steps), convertTailResursiveCall(this.catches, lamda, steps), convertTailResursiveCall(this.final, lamda, steps));
  };

  Begin.prototype.convertTailResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  ExpressionList.prototype.convertTailResursiveCall = function(lamda, steps) {
    var e, exps, _i, _len, _ref18;

    exps = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      e = _ref18[_i];
      exps.push(convertTailResursiveCall(e, lamda, steps));
    }
    return new this.constructor(exps);
  };

  Throw.prototype.convertTailResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Return.prototype.convertTailResursiveCall = function(lamda, steps) {
    throw new Error(this);
  };

  Lamda.prototype.convertTailResursiveCall = function(lamdavar) {
    throw new Error(this);
  };

  Apply.prototype.convertTailResursiveCall = function(lamda, steps) {
    var a, args, i, param, params, _i, _ref18;

    if (this.caller === lamda.vari) {
      params = lamda.tempParams;
      args = this.args;
      for (i = _i = 0, _ref18 = args.length; 0 <= _ref18 ? _i < _ref18 : _i > _ref18; i = 0 <= _ref18 ? ++_i : --_i) {
        a = args[i];
        param = params[i];
        if (a.toString() !== param) {
          steps.push(new Assign(param, a));
        }
      }
      return lamda.vari;
    } else {
      return new Apply((function() {
        var _j, _len, _ref19, _results;

        _ref19 = this.args;
        _results = [];
        for (_j = 0, _len = _ref19.length; _j < _len; _j++) {
          a = _ref19[_j];
          _results.push(convertTailResursiveCall(a, lamda, steps));
        }
        return _results;
      }).call(this));
    }
  };

  VirtualOperation.prototype.convertTailResursiveCall = function(lamda, steps) {
    var a;

    return new this.constructor((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(convertTailResursiveCall(a, lamda, steps));
      }
      return _results;
    }).call(this));
  };

  getConvertParameters = function(exp, compiler, lamda) {
    var exp_getConvertParameters;

    exp_getConvertParameters = exp != null ? exp.getConvertParameters : void 0;
    if (exp_getConvertParameters) {
      return exp_getConvertParameters.call(exp, compiler, lamda);
    }
  };

  Assign.prototype.getConvertParameters = function(compiler, lamda) {
    return getConvertParameters(this.exp, compiler, lamda);
  };

  If.prototype.getConvertParameters = function(compiler, lamda) {
    getConvertParameters(this.then_, compiler, lamda);
    return getConvertParameters(this.else_, compiler, lamda);
  };

  LabelStatement.prototype.getConvertParameters = function(compiler, lamda) {
    return getConvertParameters(this.body, compiler, lamda);
  };

  While.prototype.getConvertParameters = function(compiler, lamda) {
    getConvertParameters(this.test, compiler, lamda);
    return getConvertParameters(this.body, compiler, lamda);
  };

  Break.prototype.getConvertParameters = function(compiler, lamda) {
    return this;
  };

  Try.prototype.getConvertParameters = function(compiler, lamda) {
    getConvertParameters(this.test, compiler, lamda);
    getConvertParameters(this.catches, compiler, lamda);
    return getConvertParameters(this.final, compiler, lamda);
  };

  Begin.prototype.getConvertParameters = function(compiler, lamda) {
    return getConvertParameters(e, compiler, lamda);
  };

  New.prototype.getConvertParameters = function(compiler, lamda) {
    return getConvertParameters(this.value, compiler, lamda);
  };

  Lamda.prototype.getConvertParameters = function(varivar) {};

  Apply.prototype.getConvertParameters = function(compiler, lamda) {
    var a, args, caller, i, length, params, tempParams, _i, _j, _k, _len, _ref18, _results, _results1;

    caller = this.caller;
    if (caller === lamda.vari) {
      params = lamda.params;
      tempParams = lamda.tempParams;
      length = params.length;
      args = this.args;
      for (i = _i = 1; 1 <= length ? _i < length : _i > length; i = 1 <= length ? ++_i : --_i) {
        useConvertParams(args[i], params.slice(0, i));
      }
      _results = [];
      for (i = _j = 0; 0 <= length ? _j < length : _j > length; i = 0 <= length ? ++_j : --_j) {
        if (params[i].usedConvertParam) {
          tempParams[i] = compiler.newvar(params[i]);
          _results.push(lamda.locals[tempParams[i]] = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    } else {
      getConvertParameters(caller, compiler, lamda);
      _ref18 = this.args;
      _results1 = [];
      for (_k = 0, _len = _ref18.length; _k < _len; _k++) {
        a = _ref18[_k];
        _results1.push(getConvertParameters(a, compiler, lamda));
      }
      return _results1;
    }
  };

  VirtualOperation.prototype.getConvertParameters = function(compiler, lamda) {
    var a, _i, _len, _ref18, _results;

    _ref18 = this.args;
    _results = [];
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      a = _ref18[_i];
      _results.push(getConvertParameters(a, compiler, lamda));
    }
    return _results;
  };

  useConvertParams = function(exp, vars) {
    var exp_useConvertParams;

    exp_useConvertParams = exp != null ? exp.useConvertParams : void 0;
    if (exp_useConvertParams) {
      return exp_useConvertParams.call(exp, vars);
    } else {
      return false;
    }
  };

  Assign.prototype.useConvertParams = function(vars) {
    return useConvertParams(this.exp, vars);
  };

  Var.prototype.useConvertParams = function(vars) {
    var v, _i, _len;

    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      v = vars[_i];
      if (v === this) {
        v.usedConvertParam = true;
        return;
      }
    }
  };

  If.prototype.useConvertParams = function(vars) {
    useConvertParams(this.test, vars);
    useConvertParams(this.then_, vars);
    return useConvertParams(this.else_, vars);
  };

  LabelStatement.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  While.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  Break.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  Try.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  Begin.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  ExpressionList.prototype.useConvertParams = function(vars) {
    return useConvertParams(e, vars);
  };

  Throw.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  Return.prototype.useConvertParams = function(vars) {
    throw new Error(this);
  };

  Lamda.prototype.useConvertParams = function(varivar) {};

  Apply.prototype.useConvertParams = function(vars) {
    var a, _i, _len, _ref18, _results;

    useConvertParams(this.caller, vars);
    _ref18 = this.args;
    _results = [];
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      a = _ref18[_i];
      _results.push(useConvertParams(a, vars));
    }
    return _results;
  };

  VirtualOperation.prototype.useConvertParams = function(vars) {
    var a, _i, _len, _ref18, _results;

    _ref18 = this.args;
    _results = [];
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      a = _ref18[_i];
      _results.push(useConvertParams(a, vars));
    }
    return _results;
  };

  hasCallOf = function(exp, vari) {
    var exp_hasCallOf;

    exp_hasCallOf = exp != null ? exp.hasCallOf : void 0;
    if (exp_hasCallOf) {
      return exp_hasCallOf.call(exp, vari);
    } else {
      return false;
    }
  };

  Assign.prototype.hasCallOf = function(vari) {
    return this;
  };

  If.prototype.hasCallOf = function(vari) {
    return hasCallOf(this.then_, vari) || hasCallOf(this.else_, vari);
  };

  LabelStatement.prototype.hasCallOf = function(vari) {
    throw new Error(this);
  };

  While.prototype.hasCallOf = function(vari) {
    throw new Error(this);
  };

  Break.prototype.hasCallOf = function(vari) {
    return this;
  };

  Try.prototype.hasCallOf = function(vari) {
    return new Try(hasCallOf(this.test, vari), hasCallOf(this.catches, vari), hasCallOf(this.final, vari));
  };

  Begin.prototype.hasCallOf = function(vari) {
    throw new Error(this);
  };

  ExpressionList.prototype.hasCallOf = function(vari) {
    var e, exps, _i, _len, _ref18;

    exps = [];
    _ref18 = this.exps;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      e = _ref18[_i];
      exps.push(hasCallOf(e, vari));
    }
    return new this.constructor(exps);
  };

  Throw.prototype.hasCallOf = function(vari) {
    return false;
  };

  Return.prototype.hasCallOf = function(vari) {
    throw new Error(this);
  };

  Lamda.prototype.hasCallOf = function(varivar) {
    return false;
  };

  Apply.prototype.hasCallOf = function(vari) {
    var a, _i, _len, _ref18;

    if (this.caller === vari) {
      return true;
    } else {
      _ref18 = this.args;
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        if (hasCallOf(a, vari)) {
          return true;
        }
      }
      return false;
    }
  };

  VirtualOperation.prototype.hasCallOf = function(vari) {
    var a, _i, _len, _ref18;

    _ref18 = this.args;
    for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
      a = _ref18[_i];
      if (hasCallOf(a, vari)) {
        return true;
      }
    }
    return false;
  };

  il.insertReturn = insertReturn = function(exp) {
    var exp_insertReturn;

    exp_insertReturn = exp != null ? exp.insertReturn : void 0;
    if (exp_insertReturn) {
      return exp_insertReturn.call(exp);
    } else {
      return new Return(exp);
    }
  };

  Assign.prototype.insertReturn = function() {
    return il.begin(this, il["return"](this.left));
  };

  New.prototype.insertReturn = function() {
    return new Return(this);
  };

  Throw.prototype.insertReturn = function() {
    return this;
  };

  Return.prototype.insertReturn = function() {
    return this;
  };

  If.prototype.insertReturn = function() {
    if (this.isStatement()) {
      return new If(this.test, insertReturn(this.then_), insertReturn(this.else_));
    } else {
      return new Return(this);
    }
  };

  LabelStatement.prototype.insertReturn = function() {
    return new LabelStatement(this.label, insertReturn(this.statement));
  };

  While.prototype.insertReturn = function() {
    return new Begin(new While(this.test, insertReturn(this.body)), new Return());
  };

  Break.prototype.insertReturn = function() {
    return this;
  };

  Try.prototype.insertReturn = function() {
    return new Try(this.test, insertReturn(this.catches), insertReturn(this.final));
  };

  Begin.prototype.insertReturn = function() {
    var exps, last, length;

    exps = this.exps;
    length = exps.length;
    last = insertReturn(exps[length - 1]);
    return new this.constructor(__slice.call(exps.slice(0, length - 1)).concat([last]));
  };

  Lamda.prototype.toCode = function(compiler) {
    var a, body, k, locals, locals1, nonlocals;

    locals = [];
    nonlocals = this.nonlocals;
    locals1 = this.locals;
    for (k in locals1) {
      if (!hasOwnProperty.call(nonlocals, k) && __indexOf.call(this.params, k) < 0) {
        locals.push(il.symbol(k));
      }
    }
    body = this.body;
    if (locals.length > 0) {
      body = il.begin(il.vardecl.apply(il, locals), this.body);
    }
    if (body instanceof Begin) {
      body.constructor = Begin;
    }
    return "function(" + (((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.params;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        a = _ref18[_i];
        _results.push(a.toString());
      }
      return _results;
    }).call(this)).join(', ')) + "){" + (compiler.toCode(body)) + "}";
  };

  Fun.prototype.toCode = function(compiler) {
    return this.func.toString();
  };

  New.prototype.toCode = function(compiler) {
    return "" + this.keyword + " " + (compiler.toCode(this.value));
  };

  Var.prototype.toCode = function(compiler) {
    return this.toString();
  };

  NonlocalDecl.prototype.toCode = function(compiler) {
    return '';
  };

  Assign.prototype.toCode = function(compiler) {
    var args, args0, args1, exp, left, symbol;

    exp = this.exp;
    left = compiler.toCode(this.left);
    if (exp instanceof BinaryOperation) {
      args = exp.args;
      args0 = compiler.toCode(args[0]);
      args1 = compiler.toCode(args[1]);
      if (left === args0) {
        symbol = exp.symbol;
        switch (symbol) {
          case '+':
            if (args1 === '1') {
              return "++" + left;
            } else {
              return "" + left + " += " + args1;
            }
            break;
          case '-':
            if (args1 === '1') {
              return "--" + left;
            } else {
              return "" + left + " -= " + args1;
            }
            break;
          case '*':
          case '/':
          case '%':
          case '|':
          case '&':
          case '^':
          case '||':
          case '&&':
          case '<<':
          case '>>':
            return "" + left + " " + symbol + "= " + args1;
          default:
            return "" + left + " = " + args0 + " " + symbol + " " + args1;
        }
      } else {
        return "" + left + " = " + args0 + " " + exp.symbol + " " + args1;
      }
    } else {
      return "" + left + " = " + (compiler.toCode(exp));
    }
  };

  AugmentAssign.prototype.toCode = function(compiler) {
    return "" + (compiler.toCode(this.left)) + " " + this.operator + " " + (compiler.toCode(this.exp));
  };

  If.prototype.toCode = function(compiler) {
    var elseBody, else_, thenBody, then_;

    compiler.parent = this;
    then_ = this.then_;
    else_ = this.else_;
    if (this.isStatement()) {
      if (then_ instanceof Begin) {
        thenBody = "{" + (compiler.toCode(then_)) + "}";
      } else {
        thenBody = "" + (compiler.toCode(then_)) + ";";
      }
      if (else_ === void 0) {
        return ("if (" + (compiler.toCode(this.test)) + ") ") + thenBody;
      } else {
        if (else_ instanceof Begin) {
          elseBody = "{" + (compiler.toCode(else_)) + "}";
        } else {
          elseBody = "" + (compiler.toCode(else_));
        }
        return "if (" + (compiler.toCode(this.test)) + ") " + thenBody + "else " + elseBody;
      }
    } else {
      return "(" + (compiler.toCode(this.test)) + ") ? " + (expressionToCode(compiler, this.then_)) + " : " + (expressionToCode(compiler, this.else_));
    }
  };

  LabelStatement.prototype.toCode = function(compiler) {
    return "" + (compiler.toCode(this.label)) + ":" + (compiler.toCode(this.statement));
  };

  For.prototype.toCode = function(compiler) {
    return "for (" + (compiler.toCode(this.init)) + ";" + (compiler.toCode(this.test)) + ";" + (compiler.toCode(this.step)) + "){" + (compiler.toCode(this.body)) + "}";
  };

  ForIn.prototype.toCode = function(compiler) {
    return "for (" + (compiler.toCode(this.vari)) + " in " + (compiler.toCode(this.container)) + "){" + (compiler.toCode(this.body)) + "}";
  };

  ForOf.prototype.toCode = function(compiler) {
    return "for (" + (compiler.toCode(this.vari)) + " of " + (compiler.toCode(this.container)) + "){" + (compiler.toCode(this.body)) + "}";
  };

  While.prototype.toCode = function(compiler) {
    return "while (" + (compiler.toCode(this.test)) + "){" + (compiler.toCode(this.body)) + "}";
  };

  DoWhile.prototype.toCode = function(compiler) {
    return "do{" + (compiler.toCode(this.body)) + "}while(" + (compiler.toCode(this.test)) + ") ";
  };

  Try.prototype.toCode = function(compiler) {
    return "try{ " + (compiler.toCode(this.test)) + "} " + (compiler.toCode(this.catches)) + " finally{" + (compiler.toCode(this.final)) + "}";
  };

  Break.prototype.toCode = function(compiler) {
    if (this.label) {
      return "break " + (compiler.toCode(this.label));
    } else {
      return "break";
    }
  };

  Continue.prototype.toCode = function(compiler) {
    if (this.label) {
      return "continue " + (compiler.toCode(this.label));
    } else {
      return "continue";
    }
  };

  Apply.prototype.toCode = function(compiler) {
    var arg, caller;

    caller = this.caller;
    return "" + (expressionToCode(compiler, caller)) + "(" + (((function() {
      var _i, _len, _ref18, _results;

      _ref18 = this.args;
      _results = [];
      for (_i = 0, _len = _ref18.length; _i < _len; _i++) {
        arg = _ref18[_i];
        _results.push(compiler.toCode(arg));
      }
      return _results;
    }).call(this)).join(', ')) + ")";
  };

  Begin.prototype.toCode = function(compiler) {
    var code, exps, i, length, result;

    result = '';
    exps = this.exps;
    length = exps.length;
    i = 0;
    while (i < length - 1) {
      code = compiler.toCode(exps[i++]);
      if (code === '') {
        continue;
      } else {
        result += code + this.separator;
      }
    }
    result += compiler.toCode(exps[i]);
    result += '';
    return result;
  };

  Deref.prototype.toCode = function(compiler) {
    return "solver.trail.deref(" + (compiler.toCode(this.exp)) + ")";
  };

  JSFun.prototype.toCode = function(compiler) {
    if (_.isString(this.fun)) {
      return this.fun;
    } else {
      return compiler.toCode(this.fun);
    }
  };

  Assign.prototype.needParenthesis = true;

  BinaryOperation.prototype.needParenthesis = true;

  UnaryOperation.prototype.needParenthesis = true;

  ExpressionList.prototype.needParenthesis = true;

  Lamda.prototype.needParenthesis = true;

  expressionToCode = function(compiler, exp) {
    if (!exp.needParenthesis && !(exp instanceof Function)) {
      return compiler.toCode(exp);
    } else {
      return "(" + (compiler.toCode(exp)) + ")";
    }
  };

  isStatement = function(exp) {
    var exp_isStatement;

    exp_isStatement = exp != null ? exp.isStatement : void 0;
    if (exp_isStatement) {
      return exp_isStatement.call(exp);
    } else {
      return false;
    }
  };

  If.prototype.isStatement = function() {
    return isStatement(this.then_) || isStatement(this.else_);
  };

  LabelStatement.prototype.isStatement = function() {
    return true;
  };

  While.prototype.isStatement = function() {
    return true;
  };

  For.prototype.isStatement = function() {
    return true;
  };

  ForIn.prototype.isStatement = function() {
    return true;
  };

  ForOf.prototype.isStatement = function() {
    return true;
  };

  Try.prototype.isStatement = function() {
    return true;
  };

  Begin.prototype.isStatement = function() {
    return true;
  };

  Return.prototype.isStatement = function() {
    return true;
  };

  vari = function(klass, name) {
    return new klass(name);
  };

  il.uservar = function(name) {
    return new UserVar(name);
  };

  il.internalvar = function(name) {
    var v;

    return v = new InternalVar(name);
  };

  il.internalconst = function(name) {
    var v;

    v = new InternalVar(name);
    v.isConst = true;
    return v;
  };

  il.blockvar = function(name) {
    return new BlockVar(name);
  };

  il.symbol = function(name) {
    return new Symbol(name);
  };

  varattr = function(klass, name) {
    var i, length, names, result, _i;

    if (name == null) {
      return new klass(name);
    }
    if (name instanceof Var) {
      name = name.name;
    }
    names = name.split('.');
    length = names.length;
    result = new klass(names[0]);
    for (i = _i = 1; 1 <= length ? _i < length : _i > length; i = 1 <= length ? ++_i : --_i) {
      result = il.attr(result, il.symbol(names[i]));
    }
    return result;
  };

  il.uservarattr = function(name) {
    return varattr(UserVar, name);
  };

  il.assign = function(left, exp) {
    return new Assign(left, exp);
  };

  il.paramassign = function(left, exp) {
    var assign;

    assign = new Assign(left, exp);
    assign.isParamAssign = true;
    return assign;
  };

  il.if_ = function(test, then_, else_) {
    return new If(test, then_, else_);
  };

  il.deref = function(exp) {
    return new Deref(exp);
  };

  il.begin = function() {
    var e, exps, length, result, _i, _len;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    length = exps.length;
    if (length === 0) {
      throw new Error("begin should have at least one exp");
    }
    result = [];
    for (_i = 0, _len = exps.length; _i < _len; _i++) {
      e = exps[_i];
      if (e instanceof Begin) {
        result = result.concat(e.exps);
      } else {
        result.push(e);
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return new Begin(result);
    }
  };

  il.print = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new Print(exps);
  };

  il["return"] = function(value) {
    return new Return(value);
  };

  il["throw"] = function(value) {
    return new Throw(value);
  };

  il["new"] = function(value) {
    return new New(value);
  };

  il.lamda = function() {
    var body, p, params, _i, _len;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      p.isParameter = true;
    }
    return new Lamda(params, il.begin.apply(il, body));
  };

  il.transparentlamda = function() {
    var body, p, params, result, _i, _len;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      p.isParameter = true;
    }
    result = new Lamda(params, il.begin.apply(il, body));
    result.isTransparent = true;
    return result;
  };

  il.optrec = function() {
    var body, p, params, _i, _len;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      p.isParameter = true;
    }
    return new OptimizableRecuisiveLamda(params, il.begin.apply(il, body));
  };

  il.tailrec = function() {
    var body, p, params, _i, _len;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      p.isParameter = true;
    }
    return new TailRecuisiveLamda(params, il.begin.apply(il, body));
  };

  il.userlamda = function() {
    var body, p, params, _i, _len;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      p.isParameter = true;
    }
    return new UserLamda(params, il.begin.apply(il, body));
  };

  il.transparentuserlamda = function() {
    var body, p, params, result, _i, _len;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      p.isParameter = true;
    }
    result = new UserLamda(params, il.begin.apply(il, body));
    result.isTransparent = true;
    return result;
  };

  il.blocklamda = function() {
    var body;

    body = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new BlockLamda([], il.begin.apply(il, body));
  };

  il.clamda = function() {
    var body, v;

    v = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    v.isParameter = true;
    return new Clamda(v, il.begin.apply(il, body));
  };

  il.recclamda = function() {
    var body, v;

    v = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    v.isParameter = true;
    return new RecursiveClamda(v, il.begin.apply(il, body));
  };

  il.code = function(string) {
    return new Code(string);
  };

  il.jsfun = function(fun) {
    return new JSFun(fun);
  };

  binary = function(symbol, func, effect) {
    var Binary, _ref18;

    if (effect == null) {
      effect = il.PURE;
    }
    Binary = (function(_super) {
      __extends(Binary, _super);

      function Binary() {
        _ref18 = Binary.__super__.constructor.apply(this, arguments);
        return _ref18;
      }

      Binary.prototype.symbol = symbol;

      Binary.prototype.func = func;

      Binary.prototype._effect = effect;

      return Binary;

    })(BinaryOperation);
    return function(x, y) {
      return new Binary([x, y]);
    };
  };

  unary = function(symbol, func, effect) {
    var Unary, _ref18;

    if (effect == null) {
      effect = il.PURE;
    }
    Unary = (function(_super) {
      __extends(Unary, _super);

      function Unary() {
        _ref18 = Unary.__super__.constructor.apply(this, arguments);
        return _ref18;
      }

      Unary.prototype.symbol = symbol;

      Unary.prototype.func = func;

      Unary.prototype._effect = effect;

      return Unary;

    })(UnaryOperation);
    return function(x) {
      return new Unary([x]);
    };
  };

  il.eq = binary("===", function(x, y) {
    return x === y;
  });

  il.ne = binary("!==", function(x, y) {
    return x !== y;
  });

  il.lt = binary("<", function(x, y) {
    return x < y;
  });

  il.le = binary("<=", function(x, y) {
    return x <= y;
  });

  il.gt = binary(">", function(x, y) {
    return x > y;
  });

  il.ge = binary(">=", function(x, y) {
    return x >= y;
  });

  il.add = binary("+", function(x, y) {
    return x + y;
  });

  il.sub = binary("-", function(x, y) {
    return x - y;
  });

  il.mul = binary("*", function(x, y) {
    return x * y;
  });

  il.div = binary("/", function(x, y) {
    return x / y;
  });

  il.mod = binary("%", function(x, y) {
    return x % y;
  });

  il.and_ = binary("&&", function(x, y) {
    return x && y;
  });

  il.or_ = binary("||", function(x, y) {
    return x || y;
  });

  il.bitand = binary("&", function(x, y) {
    return x & y;
  });

  il.bitor = binary("|", function(x, y) {
    return x | y;
  });

  il.bitxor = binary("^", function(x, y) {
    return x ^ y;
  });

  il.lshift = binary("<<", function(x, y) {
    return x << y;
  });

  il.rshift = binary(">>", function(x, y) {
    return x >> y;
  });

  augmentAssign = function(operator, func) {
    var AugAssign, _ref18;

    AugAssign = (function(_super) {
      __extends(AugAssign, _super);

      function AugAssign() {
        _ref18 = AugAssign.__super__.constructor.apply(this, arguments);
        return _ref18;
      }

      AugAssign.prototype.operator = operator;

      AugAssign.prototype.func = func;

      return AugAssign;

    })(AugmentAssign);
    return function(vari, exp) {
      return new AugAssign(vari, exp);
    };
  };

  il.addassign = augmentAssign("+=", function(x, y) {
    return x + y;
  });

  il.subassign = augmentAssign("-=", function(x, y) {
    return x - y;
  });

  il.mulassign = augmentAssign("*=", function(x, y) {
    return x * y;
  });

  il.divassign = augmentAssign("/=", function(x, y) {
    return x / y;
  });

  il.modassign = augmentAssign("%=", function(x, y) {
    return x % y;
  });

  il.andassign = augmentAssign("&&=", function(x, y) {
    return x && y;
  });

  il.orassign = augmentAssign("||=", function(x, y) {
    return x || y;
  });

  il.bitandassign = augmentAssign("&=", function(x, y) {
    return x & y;
  });

  il.bitorassign = augmentAssign("|=", function(x, y) {
    return x | y;
  });

  il.bitxorassign = augmentAssign("^=", function(x, y) {
    return x ^ y;
  });

  il.lshiftassign = augmentAssign("<<=", function(x, y) {
    return x << y;
  });

  il.rshiftassign = augmentAssign(">>=", function(x, y) {
    return x >> y;
  });

  il.listassign = function() {
    var exp, i, lefts, _i;

    lefts = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), exp = arguments[_i++];
    return il.begin.apply(il, (function() {
      var _j, _ref18, _results;

      _results = [];
      for (i = _j = 0, _ref18 = lefts.length; 0 <= _ref18 ? _j < _ref18 : _j > _ref18; i = 0 <= _ref18 ? ++_j : --_j) {
        _results.push(il.assign(lefts[i], il.index(exp, i)));
      }
      return _results;
    })());
  };

  il.not_ = unary("!", function(x) {
    return !x;
  });

  il.neg = unary("-", function(x) {
    return -x;
  });

  il.bitnot = unary("~", function(x) {
    return ~x;
  });

  il.inc = il.effect(unary("++"), (function(x) {
    return x + 1;
  }), il.EFFECT);

  il.dec = il.effect(unary("--"), (function(x) {
    return x - 1;
  }), il.EFFECT);

  vop = function(name, toCode, _effect) {
    var Vop, _ref18;

    if (_effect == null) {
      _effect = il.EFFECT;
    }
    Vop = (function(_super) {
      __extends(Vop, _super);

      function Vop() {
        _ref18 = Vop.__super__.constructor.apply(this, arguments);
        return _ref18;
      }

      Vop.prototype.toCode = toCode;

      Vop.prototype._effect = _effect;

      Vop.prototype._name = name;

      return Vop;

    })(VirtualOperation);
    return function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Vop(args);
    };
  };

  vop2 = function(name, toCode, _effect) {
    var Vop, _ref18;

    if (_effect == null) {
      _effect = il.EFFECT;
    }
    Vop = (function(_super) {
      __extends(Vop, _super);

      function Vop() {
        _ref18 = Vop.__super__.constructor.apply(this, arguments);
        return _ref18;
      }

      Vop.prototype.toCode = toCode;

      Vop.prototype._effect = _effect;

      Vop.prototype._name = name;

      Vop.prototype.isStatement = function() {
        return true;
      };

      return Vop;

    })(VirtualOperation);
    return function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new Vop(args);
    };
  };

  il.attr = vop('attr', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "." + (compiler.toCode(args[1]));
  }), il.PURE);

  il.local = function() {
    var vars;

    vars = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new LocalDecl(vars);
  };

  il.nonlocal = function() {
    var vars;

    vars = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new NonlocalDecl(vars);
  };

  il.vardecl = vop('vardecl', function(compiler) {
    var args, e;

    args = this.args;
    return "var " + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        e = args[_i];
        _results.push(compiler.toCode(e));
      }
      return _results;
    })()).join(', '));
  });

  il.array = vop('array', function(compiler) {
    var args, e;

    args = this.args;
    return "[" + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        e = args[_i];
        _results.push(compiler.toCode(e));
      }
      return _results;
    })()).join(', ')) + "]";
  });

  il.uarray = vop('uarray', function(compiler) {
    var args, e;

    args = this.args;
    return "new UArray([" + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        e = args[_i];
        _results.push(compiler.toCode(e));
      }
      return _results;
    })()).join(', ')) + "])";
  });

  il.cons = vop('cons', function(compiler) {
    var args;

    args = this.args;
    return "new Cons(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  });

  il.suffixinc = vop('suffixdec', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "++";
  });

  il.suffixdec = vop('suffixdec', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "--";
  });

  il.catches = il.uservarattr('solver.catches');

  il.pushCatch = vop('pushCatch', function(compiler) {
    var args;

    args = this.args;
    return "solver.pushCatch(" + (expressionToCode(compiler, args[0])) + ", " + (expressionToCode(compiler, args[1])) + ")";
  });

  il.popCatch = vop('popCatch', function(compiler) {
    var args;

    args = this.args;
    return "solver.popCatch(" + (expressionToCode(compiler, args[0])) + ")";
  });

  il.findCatch = vop('findCatch', (function(compiler) {
    var args;

    args = this.args;
    return "solver.findCatch(" + (expressionToCode(compiler, args[0])) + ")";
  }), il.PURE);

  il.fake = vop('fake', function(compiler) {
    var args;

    args = this.args;
    return "solver.fake(" + (compiler.toCode(args[0])) + ")";
  }).apply([]);

  il.restore = vop('restore', function(compiler) {
    var args;

    args = this.args;
    return "solver.restore(" + (compiler.toCode(args[0])) + ")";
  });

  il.getvalue = vop('getvalue', (function(compiler) {
    var args;

    args = this.args;
    return "solver.trail.getvalue(" + (compiler.toCode(args[0])) + ")";
  }), il.PURE);

  il.list = vop('list', (function(compiler) {
    var a, args;

    args = this.args;
    return "[" + (((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        a = args[_i];
        _results.push(compiler.toCode(a));
      }
      return _results;
    })()).join(', ')) + "]";
  }), il.PURE);

  il.length = vop('length', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".length";
  }), il.PURE);

  il.index = vop('index', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + "[" + (compiler.toCode(args[1])) + "]";
  }), il.PURE);

  il.slice = vop('slice', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".slice(" + (compiler.toCode(args[1])) + ", " + (compiler.toCode(args[2])) + ")";
  }), il.PURE);

  il.push = vop('push', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".push(" + (compiler.toCode(args[1])) + ")";
  });

  il.pop = vop('pop', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".pop()";
  });

  il.concat = vop('concat', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".concat(" + (compiler.toCode(args[1])) + ")";
  }), il.PURE);

  il["instanceof"] = vop('instanceof', (function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + " instanceof " + (expressionToCode(compiler, args[1]));
  }), il.PURE);

  il.run = vop('run', function(compiler) {
    var args;

    args = this.args;
    return "solver.run(" + (compiler.toCode(args[0])) + ")";
  });

  il.evalexpr = vop('evalexpr', function(compiler) {
    var args;

    args = this.args;
    return "solve(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  });

  il.require = vop('require', function(compiler) {
    var args;

    args = this.args;
    return "require(" + (compiler.toCode(args[0])) + ")";
  });

  il.newLogicVar = vop('newLogicVar', (function(compiler) {
    var args;

    args = this.args;
    return "new Var(" + (compiler.toCode(args[0])) + ")";
  }), il.PURE);

  il.newDummyVar = vop('newDummyVar', (function(compiler) {
    var args;

    args = this.args;
    return "new DummyVar(" + (compiler.toCode(args[0])) + ")";
  }), il.PURE);

  il.unify = vop('unify', function(compiler) {
    var args;

    args = this.args;
    return "solver.trail.unify(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  });

  il.bind = vop('bind', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".bind(" + (compiler.toCode(args[1])) + ", solver.trail)";
  });

  il.solver = il.uservar('solver');

  il.undotrail = vop('undotrail', function(compiler) {
    var args;

    args = this.args;
    return "" + (expressionToCode(compiler, args[0])) + ".undo()";
  });

  il.failcont = il.uservarattr('solver.failcont');

  il.setfailcont = function(cont) {
    return il.assign(il.failcont, cont);
  };

  il.setcutcont = function(cont) {
    return il.assign(il.cutcont, cont);
  };

  il.appendFailcont = vop('appendFailcont', function(compiler) {
    var args;

    args = this.args;
    return "solver.appendFailcont(" + (compiler.toCode(args[0])) + ")";
  });

  il.cutcont = il.uservarattr('solver.cutcont');

  il.state = il.uservarattr('solver.state');

  il.setstate = function(state) {
    return il.assign(il.state, state);
  };

  il.trail = il.uservarattr('solver.trail');

  il.newTrail = vop('newTrail', function(compiler) {
    var args;

    args = this.args;
    return "new Trail()";
  })();

  il.settrail = function(trail) {
    return il.assign(il.trail, trail);
  };

  il.char = vop('char', (function(compiler) {
    var args;

    args = this.args;
    return "parser.char(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.followChars = vop('followChars', (function(compiler) {
    var args;

    args = this.args;
    return "parser.followChars(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.notFollowChars = vop('notFollowChars', (function(compiler) {
    var args;

    args = this.args;
    return "parser.notFollowChars(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.charWhen = vop('charWhen', (function(compiler) {
    var args;

    args = this.args;
    return "parser.charWhen(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.spaces = vop('spaces', (function(compiler) {
    var args;

    args = this.args;
    return "parser.spaces(" + (compiler.toCode(args[0])) + ")";
  }), il.EFFECT);

  il.spaces0 = vop('spaces0', (function(compiler) {
    var args;

    args = this.args;
    return "parser.spaces0(" + (compiler.toCode(args[0])) + ")";
  }), il.EFFECT);

  il.stringWhile = vop('stringWhile', (function(compiler) {
    var args;

    args = this.args;
    return "parser.stringWhile(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.stringWhile0 = vop('stringWhile0', (function(compiler) {
    var args;

    args = this.args;
    return "parser.stringWhile0(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.number = vop('number', (function(compiler) {
    var args;

    args = this.args;
    return "parser.number(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.literal = vop('literal', (function(compiler) {
    var args;

    args = this.args;
    return "parser.literal(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.followLiteral = vop('followLiteral', (function(compiler) {
    var args;

    args = this.args;
    return "parser.followLiteral(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.notFollowLiteral = vop('notFollowLiteral', (function(compiler) {
    var args;

    args = this.args;
    return "parser.notFollowLiteral(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.quoteString = vop('quoteString', (function(compiler) {
    var args;

    args = this.args;
    return "parser.quoteString(" + (compiler.toCode(args[0])) + ", " + (compiler.toCode(args[1])) + ")";
  }), il.EFFECT);

  il.fun = function(f) {
    return new Fun(f);
  };

  il.let_ = function() {
    var bindings, body, i, params, values, _i, _ref18;

    bindings = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    params = [];
    values = [];
    for (i = _i = 0, _ref18 = bindings.length; _i < _ref18; i = _i += 2) {
      params.push(bindings[i]);
      values.push(bindings[i + 1]);
    }
    return new Apply(il.lamda.apply(il, [params].concat(__slice.call(body))), values);
  };

  il.iff = function() {
    var clauses, else_, length, _i;

    clauses = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), else_ = arguments[_i++];
    length = clauses.length;
    if (length === 2) {
      return il.if_(clauses[0], clauses[1], else_);
    } else {
      return il.if_(clauses[0], clauses[1], il.iff.apply(il, __slice.call(clauses.slice(2, length)).concat([else_])));
    }
  };

  il.label = function(label, statement) {
    return new LabelStatement(label, statement);
  };

  il.while_ = function() {
    var body, test;

    test = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new While(test, il.begin.apply(il, body));
  };

  il.dowhile = function() {
    var body, test, _i;

    body = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), test = arguments[_i++];
    return new DoWhile(test, il.begin.apply(il, body));
  };

  il.for_ = function(init, test, step, body) {
    return new For(test, il.begin.apply(il, body));
  };

  il.forin = function() {
    var body, container, vari;

    vari = arguments[0], container = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return new ForIn(vari, container, il.begin.apply(il, body));
  };

  il.forof = function() {
    var body, container, vari;

    vari = arguments[0], container = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return new ForOf(vari, container, il.begin.apply(il, body));
  };

  il.try_ = function(test, catches, final) {
    return new Try(test, catches, final);
  };

  il.break_ = function(label) {
    return new Break(label);
  };

  il.continue_ = function(label) {
    return new Continue(label);
  };

  il.idcont = (function() {
    var v;

    v = il.internalvar('v');
    return new IdCont(v, v);
  })();

  il.excludes = ['evalexpr', 'failcont', 'run', 'getvalue', 'fake', 'findCatch', 'popCatch', 'pushCatch', 'protect', 'suffixinc', 'suffixdec', 'dec', 'inc', 'unify', 'bind', 'undotrail', 'newTrail', 'newLogicVar', 'char', 'followChars', 'notFollowChars', 'charWhen', 'stringWhile', 'stringWhile0', 'number', 'literal', 'followLiteral', 'quoteString'];

  augmentOperators = {
    add: il.addassign,
    sub: il.subassign,
    mul: il.mulassign,
    div: il.divassign,
    mod: il.modassign,
    'and_': il.andassign,
    'or_': il.orassign,
    bitand: il.bitandassign,
    bitor: il.bitorassign,
    bitxor: il.bitxorassign,
    lshift: il.lshiftassign,
    rshift: il.rshiftassign
  };

}).call(this);

/*
//@ sourceMappingURL=interlang.map
*/
