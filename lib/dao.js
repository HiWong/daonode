// Generated by CoffeeScript 1.6.2
(function() {
  var $arrayLiteral, $assignExpr, $atomExpr, $attrExpr, $binaryExpr, $blockcomment, $code, $exprList, $expression, $forExpr, $ifExpr, $indexExpr, $invocationExpr, $leftValueExpr, $linecomment, $matchToEOL, $operationExpr, $parenExper, $parenExpr, $program, $programBody, $statement, $switchExpr, $throwExpr, $tryExpr, $unaryExpr, $valueExpr, andp, array, assign, begin, body, char, charComma, charConlon, charDot, charLeftBracket, charLeftParen, charRightBracket, charRightParen, charSemiConlon, compile, concat, core, daoutil, direct, eoi, eq, exp, funcall, grammar, greedyany, hasOwnProperty, headList, identifier, if_, il, jsfun, lamda, left, name, nonlocal, number, op, operator, orp, parsetext, quoteString, readToken, repl, solve, solver, string, switch_, token, tokenInfoList, tokenNames, util, value, variable, x, y, z, _ref, _ref1;

  solve = (core = require('./core')).solve;

  _ref = util = require('./util'), string = _ref.string, char = _ref.char, number = _ref.number, parsetext = _ref.parsetext, quoteString = _ref.quoteString, identifier = _ref.identifier, begin = _ref.begin, nonlocal = _ref.nonlocal, variable = _ref.variable, direct = _ref.direct, switch_ = _ref.switch_, if_ = _ref.if_, eq = _ref.eq, concat = _ref.concat, jsfun = _ref.jsfun, lamda = _ref.lamda, funcall = _ref.funcall, andp = _ref.andp, orp = _ref.orp, assign = _ref.assign, array = _ref.array, headList = _ref.headList, greedyany = _ref.greedyany, eoi = _ref.eoi;

  _ref1 = daoutil = require('./daoutil'), operator = _ref1.operator, tokenInfoList = _ref1.tokenInfoList, tokenNames = _ref1.tokenNames;

  hasOwnProperty = Object.hasOwnProperty;

  for (name in tokenNames) {
    value = tokenNames[name];
    if (hasOwnProperty.call(tokenNames, name)) {
      global[name] = value;
    }
  }

  il = require('./interlang');

  repl = function() {};

  exports.compile = compile = function(code) {
    var path, sexpr;

    sexpr = core.solve(parsetext(grammar, string(exp)));
    path = process.cwd() + '/lib/compiled.js';
    return core.compile(sexpr, path);
  };

  exports.solve = solve = function(exp) {
    var sexpr;

    return sexpr = core.solve(parsetext(grammar, string(exp)));
  };

  solver = 'solver';

  x = 'x';

  y = 'y';

  z = 'z';

  op = 'op';

  left = 'left';

  token = 'token';

  readToken = 'readToken';

  exp = 'exp';

  body = 'body';

  $program = '$program';

  $programBody = '$programBody';

  $statement = '$statement';

  $expression = '$expression';

  $exprList = '$exprList';

  $ifExpr = '$ifExpr';

  $forExpr = '$forExpr';

  $switchExpr = '$switchExpr';

  $tryExpr = '$tryExpr';

  $throwExpr = '$throwExpr';

  $assignExpr = '$assignExpr';

  $leftValueExpr = '$leftValueExpr';

  $attrExpr = '$attrExpr';

  $indexExpr = '$indexExpr';

  $operationExpr = '$operationExpr';

  $binaryExpr = '$binaryExpr';

  $unaryExpr = '$unaryExpr';

  $atomExpr = '$atomExpr';

  $parenExpr = '$parenExpr';

  $valueExpr = '$valueExpr';

  $invocationExpr = '$invocationExpr';

  $code = '$code';

  $parenExper = '$parenExper';

  $arrayLiteral = '$arrayLiteral';

  $linecomment = '$linecomment';

  $blockcomment = '$blockcomment\
';

  $matchToEOL = '$matchToEOL';

  charLeftParen = char(string('('));

  charRightParen = char(string(')'));

  charLeftBracket = char(string('['));

  charRightBracket = char(string(']'));

  charDot = char(string('.'));

  charComma = char(string(','));

  charSemiConlon = char(string(';'));

  charConlon = char(string(':'));

  grammar = begin(direct(il.begin(il.assign(il.uservar('daoutil'), il.require('./daoutil')), il.assign(il.uservar('readToken'), il.attr(il.uservar('daoutil'), il.symbol('readToken'))), il.assign(il.uservar('StateMachine'), il.attr(il.uservar('daoutil'), il.symbol('StateMachine'))), il.assign(il.uservar('tokenInfoList'), il.attr(il.uservar('daoutil'), il.symbol('tokenInfoList'))), il.assign(il.uservar('binaryOperator'), il.attr(il.uservar('daoutil'), il.symbol('binaryOperator'))), il.assign(il.uservar('unaryOperator'), il.attr(il.uservar('daoutil'), il.symbol('unaryOperator'))), il.assign(il.uservar('assignOperator'), il.attr(il.uservar('daoutil'), il.symbol('assignOperator'))), il.assign(il.uservar('suffixOperator'), il.attr(il.uservar('daoutil'), il.symbol('suffixOperator'))), il.assign(il.attr(il.uservar('solver'), il.uservar('tokenStateMachine')), il["new"](il.uservar('StateMachine').call(il.uservar('tokenInfoList')))))), assign($program, lamda([], orp(andp(eoi, null), andp(assign(body, funcall($programBody), headList('begin', body)))))), assign($statement, lamda([], assign(token, funcall(readToken)), switch_(token, [TKNRETURN], begin(assign(exp, funcall($expression)), array(util.RETURN, exp)), [TKNPASS], funcall($matchToEOL), [TKNLINECOMMENTBEGIN], funcall($blockcomment), funcall($expression)))), assign($expression, lamda([], orp(funcall($valueExpr), funcall($invocationExpr), funcall($code), funcall($operationExpr), funcall($assignExpr), funcall($ifExpr), funcall($tryExpr), funcall($forExpr), funcall($switchExpr), funcall($throwExpr)))), assign($assignExpr, lamda([], assign(left, funcall($leftValueExpr)), assign(op, funcall('assignOperator', solver)), assign(exp, funcall($expression)), if_(eq(op, util.ASSIGN), array(op, left, exp), concat(op, array(left, exp))))), assign($leftValueExpr, lamda([], orp(identifier(), funcall($attrExpr), funcall($indexExpr)))), assign($attrExpr, lamda([], andp(orp(identifier(), funcall($parenExper), funcall($arrayLiteral), quoteString()), charDot, identifier()))), assign($indexExpr, lamda([], andp(orp(identifier(), funcall($parenExpr)), charLeftBracket, funcall($expression), charRightBracket))), assign($binaryExpr, lamda([], variable(x), assign(x, funcall($unaryExpr)), orp(andp(greedyany(andp(assign(op, funcall('binaryOperator', solver)), assign(y, funcall($unaryExpr)), assign(x, array(op, x, y)))), x), x))), assign($unaryExpr, lamda([], orp(andp(assign(op, funcall('unaryOperator', solver)), assign(x, funcall($atomExpr)), array(op, x)), andp(assign(x, funcall($atomExpr)), orp(andp(assign(op, funcall('suffixOperator', solver)), array(op, x)), x))))), assign($parenExpr, lamda([], charLeftParen, assign(exp, funcall($binaryExpr)), charRightParen, exp)), assign($atomExpr, lamda([], orp(identifier(), array(util.STRING, quoteString()), number(), funcall($parenExpr)))), funcall($binaryExpr));

}).call(this);

/*
//@ sourceMappingURL=dao.map
*/
