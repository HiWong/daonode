// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, dao, debug, general, if_fun, iff_fun, macro, not_, runner, special, _,
    __slice = [].slice;

  _ = require('underscore');

  dao = require("../dao");

  general = require("./general");

  special = dao.special;

  macro = dao.macro;

  debug = dao.debug;

  exports.quote = special(1, 'quote', function(solver, cont, exp) {
    return function(v) {
      return cont(exp);
    };
  });

  exports.eval_ = special(1, 'eval', function(solver, cont, exp) {
    return solver.cont(exp, function(v) {
      return [solver.cont(v, cont), null];
    });
  });

  exports.assign = special(2, 'assign', function(solver, cont, vari, exp) {
    return solver.cont(exp, function(v) {
      if (v instanceof dao.Var) {
        new dao.TypeError(v, "do NOT assign free logic var to var");
      }
      vari.binding = v;
      return cont(v);
    });
  });

  exports.zero = special(1, 'zero', function(solver, cont, vari, exp) {
    return function(v) {
      vari.binding = 0;
      return cont(v);
    };
  });

  exports.one = special(1, 'one', function(solver, cont, vari, exp) {
    return function(v) {
      vari.binding = 1;
      return cont(v);
    };
  });

  exports.begin = special(null, 'begin', function() {
    var cont, exps, solver;

    solver = arguments[0], cont = arguments[1], exps = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.expsCont(exps, cont);
  });

  if_fun = function(solver, cont, test, then_, else_) {
    var action, else_cont, then_cont;

    then_cont = solver.cont(then_, cont);
    if (else_ != null) {
      else_cont = solver.cont(else_, cont);
      action = function(v) {
        if (v) {
          return then_cont(v);
        } else {
          return else_cont(v);
        }
      };
      return solver.cont(test, action);
    } else {
      action = function(v) {
        if (v) {
          return then_cont(null);
        } else {
          return cont(null);
        }
      };
      return solver.cont(test, action);
    }
  };

  exports.if_ = special([2, 3], 'if_', if_fun);

  iff_fun = function(solver, cont, clauses, else_) {
    var action, iff_else_cont, length, test, then_, then_cont, _ref, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new exports.TypeError(clauses);
    } else if (length === 1) {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      return if_fun(solver, cont, test, then_, else_);
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      then_cont = solver.cont(then_, cont);
      iff_else_cont = iff_fun(solver, cont, clauses.slice(1), else_);
      action = function(v) {
        if (v) {
          return [then_cont, v];
        } else {
          return [iff_else_cont, v];
        }
      };
      return solver.cont(test, action);
    }
  };

  exports.iff = special(-2, 'iff', iff_fun);

  exports.block = block = special(null, 'block', function() {
    var body, cont, continues, defaultContinues, defaultExits, exits, fun, holder, label, solver, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

    solver = arguments[0], cont = arguments[1], label = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    exits = (_ref = (_base = solver.exits)[label]) != null ? _ref : _base[label] = [];
    exits.push(cont);
    defaultExits = (_ref1 = (_base1 = solver.exits)['']) != null ? _ref1 : _base1[''] = [];
    defaultExits.push(cont);
    holder = [null];
    continues = (_ref2 = (_base2 = solver.continues)[label]) != null ? _ref2 : _base2[label] = [];
    continues.push(holder);
    defaultContinues = (_ref3 = (_base3 = solver.continues)['']) != null ? _ref3 : _base3[''] = [];
    defaultContinues.push(holder);
    holder[0] = fun = solver.expsCont(body, cont);
    exits.pop();
    if (exits.length === 0) {
      delete solver.exits[label];
    }
    continues.pop();
    if (continues.length === 0) {
      delete solver.continues[label];
    }
    defaultExits.pop();
    defaultContinues.pop();
    return fun;
  });

  exports.break_ = break_ = special([0, 1, 2], 'break_', function(solver, cont, label, value) {
    var exitCont, exits, valCont;

    if (label == null) {
      label = '';
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !_.isString(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !_.isString(label)) {
      value = label;
      label = '';
    }
    exits = solver.exits[label];
    if (!exits || exits === []) {
      throw Error(label);
    }
    exitCont = exits[exits.length - 1];
    valCont = function(v) {
      return solver.protect(exitCont)(v);
    };
    return solver.cont(value, valCont);
  });

  exports.continue_ = continue_ = special([0, 1], 'continue_', function(solver, cont, label) {
    var continueCont, continues;

    if (label == null) {
      label = '';
    }
    continues = solver.continues[label];
    if (!continues || continues === []) {
      throw Error(label);
    }
    continueCont = continues[continues.length - 1];
    return function(v) {
      return [solver.protect(continueCont[0]), v];
    };
  });

  not_ = general.not_;

  exports.loop_ = macro(null, 'loop', function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  });

  exports.while_ = macro(null, 'while_', function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  });

  exports.until_ = macro(null, 'until_', function() {
    var body, label, test, _i;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), test = arguments[_i++];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  });

  exports.catch_ = special(-1, 'catch_', function() {
    var cont, forms, solver, tag, tagCont;

    solver = arguments[0], cont = arguments[1], tag = arguments[2], forms = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    tagCont = function(v) {
      var formsCont;

      solver.pushCatch(v, cont);
      formsCont = solver.expsCont(forms, function(v2) {
        solver.popCatch(v);
        return [cont, v2];
      });
      return [formsCont, v];
    };
    return solver.cont(tag, tagCont);
  });

  exports.throw_ = special(2, 'throw_', function(solver, cont, tag, form) {
    var formCont;

    formCont = function(v) {
      return solver.cont(form, function(v2) {
        return solver.protect(solver.findCatch(v))(v2);
      })(v);
    };
    return solver.cont(tag, formCont);
  });

  exports.protect = special(-1, 'protect', function() {
    var cleanup, cleanupCont, cont, form, oldprotect, result, solver;

    solver = arguments[0], cont = arguments[1], form = arguments[2], cleanup = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    oldprotect = solver.protect;
    solver.protect = function(fun) {
      return function(v1) {
        return solver.expsCont(cleanup, function(v2) {
          solver.protect = oldprotect;
          return oldprotect(fun)(v1);
        })(v1);
      };
    };
    cleanupCont = function(v1) {
      return solver.expsCont(cleanup, function(v2) {
        solver.protect = oldprotect;
        return cont(v1);
      })(v1);
    };
    result = solver.cont(form, cleanupCont);
    return result;
  });

  runner = function(solver, cont) {
    return function(v) {
      return solver.trail.getvalue(solver.run(v, cont));
    };
  };

  exports.callcc = special(1, 'callcc', function(solver, cont, fun) {
    return function(v) {
      return cont(fun(runner(solver.clone(), cont)));
    };
  });

  exports.callfc = special(1, 'callfc', function(solver, cont, fun) {
    return function(v) {
      return cont(fun(runner(solver.clone(), solver.failcont)));
    };
  });

  exports.callcs = special(1, 'callcs', function(solver, cont, fun) {
    return function(v) {
      return cont(fun(solver.clone(), cont));
    };
  });

  exports.quasiquote = exports.qq = special(1, 'quasiquote', function(solver, cont, item) {
    return typeof solver.quasiquote === "function" ? solver.quasiquote(item, cont) : void 0;
  });

  exports.unquote = exports.uq = special(1, 'unquote', function(solver, cont, item) {
    throw "unquote: too many unquote and unquoteSlice";
  });

  exports.unquoteSlice = exports.uqs = special(1, 'unquoteSlice', function(solver, cont, item) {
    throw "unquoteSlice: too many unquote and unquoteSlice";
  });

}).call(this);

/*
//@ sourceMappingURL=lisp.map
*/
