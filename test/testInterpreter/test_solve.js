// Generated by CoffeeScript 1.6.2
(function() {
  var Trail, add, andp, any, assign, begin, block, break_, callcc, callfc, catch_, char, continue_, core, dec, dummy, eq, eval_, fun, fun2, if_, iff, inc, le, loop_, macro, may, orp, parsetext, print_, proc, protect, qq, quote, rule, settext, solve, solver, sub, succeed, throw_, tofun, until_, uq, uqs, vari, while_, xexports, _, _ref, _ref1, _ref2, _ref3, _ref4;

  _ = require("underscore");

  _ref = core = require("../../lib/interpreter/core"), Trail = _ref.Trail, solve = _ref.solve, solver = _ref.solver, fun = _ref.fun, fun2 = _ref.fun2, macro = _ref.macro, proc = _ref.proc, vari = _ref.vari, rule = _ref.rule, tofun = _ref.tofun, dummy = _ref.dummy;

  _ref1 = require("../../lib/interpreter/builtins/general"), add = _ref1.add, print_ = _ref1.print_, inc = _ref1.inc, dec = _ref1.dec, eq = _ref1.eq, le = _ref1.le, sub = _ref1.sub;

  _ref2 = require("../../lib/interpreter/builtins/logic"), andp = _ref2.andp, orp = _ref2.orp, succeed = _ref2.succeed;

  _ref3 = require("../../lib/interpreter/builtins/lisp"), quote = _ref3.quote, begin = _ref3.begin, if_ = _ref3.if_, iff = _ref3.iff, eval_ = _ref3.eval_, block = _ref3.block, break_ = _ref3.break_, continue_ = _ref3.continue_, assign = _ref3.assign, loop_ = _ref3.loop_, while_ = _ref3.while_, until_ = _ref3.until_, catch_ = _ref3.catch_, throw_ = _ref3.throw_, protect = _ref3.protect, callcc = _ref3.callcc, callfc = _ref3.callfc, qq = _ref3.qq, uq = _ref3.uq, uqs = _ref3.uqs;

  _ref4 = require("../../lib/interpreter/builtins/parser"), char = _ref4.char, parsetext = _ref4.parsetext, settext = _ref4.settext, may = _ref4.may, any = _ref4.any;

  xexports = {};

  exports.Test = {
    "test 1": function(test) {
      test.equal(solve(1), 1);
      return test.done();
    },
    "test vari": function(test) {
      var a;

      a = vari('a');
      test.equal(solve(a), a);
      return test.done();
    },
    "test print_": function(test) {
      test.equal(solve(print_('a')), null);
      return test.done();
    },
    "test builtin function": function(test) {
      var same;

      same = fun(1, function(x) {
        return x;
      });
      test.equal(solve(same(1)), 1);
      add = fun(2, function(x, y) {
        return x + y;
      });
      test.equal(solve(add(1, 2)), 3);
      return test.done();
    },
    "test var bind unify trail": function(test) {
      var trail, x;

      trail = new Trail;
      x = vari('x');
      test.equal(x.binding, x);
      x.bind(1, trail);
      test.ok(trail.unify(1, x));
      test.ok(!trail.unify(2, x));
      trail.undo();
      test.ok(trail.unify(x, 2));
      return test.done();
    },
    "test macro": function(test) {
      var orpm, same;

      same = macro(function(x) {
        return x;
      });
      orpm = macro(function(x, y) {
        return orp(x, y);
      });
      test.equal(solve(same(1)), 1);
      test.equal(solve(same(print_(1))), null);
      test.equal(solve(orpm(fail, print_(2))), null);
      return test.done();
    },
    "test macro": function(test) {
      var m;

      m = macro(0, 'a', function() {});
      m();
      return test.done();
    },
    "test proc,aka online function in dao": function(test) {
      var a;

      a = proc(0, 'a', function() {
        var i;

        i = 0;
        return add(1, 2);
      });
      test.equal(solve(begin(a(), a())), 3);
      test.equal(solve(begin(a(), add(1, 1))), 2);
      return test.done();
    },
    "test macro tofun": function(test) {
      var orpm;

      orpm = macro(2, function(x, y) {
        return orp(x, y);
      });
      test.equal(solve(orpm(print_(1), print_(2))), null);
      test.equal(solve(tofun(orpm)(print_(1), print_(2))), null);
      test.equal(solve(tofun(orpm)(quote(print_(1)), quote(print_(2)))), null);
      return test.done();
    },
    "test macro 1": function(test) {
      var m;

      m = macro(1, function(x) {
        if (x === 0) {
          return print_(x);
        } else {
          return m(x - 1);
        }
      });
      test.equal(solve(m(5)), null);
      return test.done();
    },
    "test fun2": function(test) {
      var m;

      m = fun2(1, function(x) {
        return if_(eq(x, 0), print_(x), m(sub(x, 1)));
      });
      test.equal(solve(m(5)), null);
      return test.done();
    },
    "test macro 2": function(test) {
      var m, x;

      _ = dummy('_');
      m = macro(0, function() {
        return print_(1);
      });
      x = m();
      test.equal(solve(andp(x, x)), null);
      test.equal(core.status, core.SUCCESS);
      return test.done();
    },
    "test recursive macro2": function(test) {
      var m;

      _ = dummy('_');
      m = macro(0, function() {
        return orp(andp(char(_), print_(_), m()), succeed);
      });
      test.equal(solve(andp(settext('abc'), m())), null);
      test.equal(core.status, core.SUCCESS);
      return test.done();
    },
    "test recursive macro1": function(test) {
      var m;

      m = macro(1, function(x) {
        if (x === 0) {
          return print_(x);
        } else {
          return begin(print_(x), m(x - 1));
        }
      });
      test.equal(solve(m(5)), null);
      test.equal(core.status, core.SUCCESS);
      return test.done();
    }
  };

}).call(this);

/*
//@ sourceMappingURL=test_solve.map
*/
