// Generated by CoffeeScript 1.6.2
(function() {
  var ADD, AND, ANY, ARRAY, ASSIGN, ATTR, AUGMENTASSIGN, ArgumentError, ArityError, BEGIN, BIND, BITAND, BITNOT, BITOR, BITXOR, BLOCK, BOI, BOL, BREAK, CALLCC, CALLFC, CATCH, CONS, CONTINUE, CUT, CUTABLE, Compiler, CpsEnv, DEC, DECP, DIRECT, DIV, DUMMYVAR, EFFECT, EOI, EOL, EQ, EVAL, EVALARG, Env, Error, FAIL, FINDALL, FOLLOW, FOR, FORIN, FOROF, FUNCALL, GE, GETPARSERCURSOR, GETPARSERDATA, GETPARSERSTATE, GETVALUE, GREEDYANY, GREEDYMAY, GT, IF, IFP, INC, INCP, INDEX, INSTANCEOF, IO, IS, JSFUN, JSFUNCALL, LAMDA, LAZYANY, LAZYMAY, LE, LEFTPARSERDATA, LENGTH, LIST, LOGICVAR, LSHIFT, LT, MACRO, MACROCALL, MAKEOBJECT, MAY, MOD, MUL, NE, NEG, NEXTCHAR, NONLOCAL, NOT, NOTFOLLOW, NOTP, NOTP2, NOTP3, NOTUNIFY, ONCE, OR, ORP, ORP2, ORP3, OptimizationEnv, PARALLEL, PARSE, PARSEDATA, POP, PURE, PUSH, PUSHP, QUASIQUOTE, QUOTE, REPEAT, RSHIFT, SETPARSERCURSOR, SETPARSERDATA, SETPARSERSTATE, SEXPR_HEAD_FIRST, SEXPR_HEAD_LAST, SLICE, STEP, STRING, SUB, SUBPARSERDATA, SUCCEED, SUFFIXDEC, SUFFIXDECP, SUFFIXINC, SUFFIXINCP, SWITCH, THROW, TRY, TypeError, UARRAY, UNIFY, UNIQUECONST, UNIQUEVAR, UNQUOTE, UNQUOTESLICE, UNWINDPROTECT, UOBJECT, VARIABLE, VarLookupError, beautify, compile, fs, hasOwnProperty, il, isArray, isInteger, isString, _ref, _ref1, _ref2, _ref3, _ref4,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require("fs");

  beautify = require('js-beautify').js_beautify;

  _ref = require("./util"), isInteger = _ref.isInteger, isString = _ref.isString, isArray = _ref.isArray;

  il = require("./interlang");

  _ref1 = require('./util'), QUOTE = _ref1.QUOTE, EVAL = _ref1.EVAL, STRING = _ref1.STRING, BEGIN = _ref1.BEGIN, NONLOCAL = _ref1.NONLOCAL, VARIABLE = _ref1.VARIABLE, UNIQUEVAR = _ref1.UNIQUEVAR, UNIQUECONST = _ref1.UNIQUECONST, ASSIGN = _ref1.ASSIGN, AUGMENTASSIGN = _ref1.AUGMENTASSIGN, INC = _ref1.INC, SUFFIXINC = _ref1.SUFFIXINC, DEC = _ref1.DEC, SUFFIXDEC = _ref1.SUFFIXDEC, INCP = _ref1.INCP, SUFFIXINCP = _ref1.SUFFIXINCP, DECP = _ref1.DECP, SUFFIXDECP = _ref1.SUFFIXDECP, IF = _ref1.IF, SWITCH = _ref1.SWITCH, JSFUN = _ref1.JSFUN, DIRECT = _ref1.DIRECT, PURE = _ref1.PURE, EFFECT = _ref1.EFFECT, IO = _ref1.IO, LAMDA = _ref1.LAMDA, MACRO = _ref1.MACRO, EVALARG = _ref1.EVALARG, ARRAY = _ref1.ARRAY, UARRAY = _ref1.UARRAY, MAKEOBJECT = _ref1.MAKEOBJECT, UOBJECT = _ref1.UOBJECT, CONS = _ref1.CONS, FUNCALL = _ref1.FUNCALL, MACROCALL = _ref1.MACROCALL, JSFUNCALL = _ref1.JSFUNCALL, FOR = _ref1.FOR, FORIN = _ref1.FORIN, FOROF = _ref1.FOROF, TRY = _ref1.TRY, BLOCK = _ref1.BLOCK, BREAK = _ref1.BREAK, CONTINUE = _ref1.CONTINUE, CATCH = _ref1.CATCH, THROW = _ref1.THROW, UNWINDPROTECT = _ref1.UNWINDPROTECT, CALLCC = _ref1.CALLCC, CALLFC = _ref1.CALLFC, QUASIQUOTE = _ref1.QUASIQUOTE, UNQUOTE = _ref1.UNQUOTE, UNQUOTESLICE = _ref1.UNQUOTESLICE, LOGICVAR = _ref1.LOGICVAR, DUMMYVAR = _ref1.DUMMYVAR, UNIFY = _ref1.UNIFY, NOTUNIFY = _ref1.NOTUNIFY, IS = _ref1.IS, BIND = _ref1.BIND, GETVALUE = _ref1.GETVALUE, SUCCEED = _ref1.SUCCEED, FAIL = _ref1.FAIL, PUSHP = _ref1.PUSHP, ORP = _ref1.ORP, ORP2 = _ref1.ORP2, ORP3 = _ref1.ORP3, NOTP = _ref1.NOTP, NOTP2 = _ref1.NOTP2, NOTP3 = _ref1.NOTP3, IFP = _ref1.IFP, REPEAT = _ref1.REPEAT, CUTABLE = _ref1.CUTABLE, CUT = _ref1.CUT, FINDALL = _ref1.FINDALL, ONCE = _ref1.ONCE, PARSE = _ref1.PARSE, PARSEDATA = _ref1.PARSEDATA, SETPARSERSTATE = _ref1.SETPARSERSTATE, SETPARSERDATA = _ref1.SETPARSERDATA, SETPARSERCURSOR = _ref1.SETPARSERCURSOR, GETPARSERSTATE = _ref1.GETPARSERSTATE, GETPARSERDATA = _ref1.GETPARSERDATA, GETPARSERCURSOR = _ref1.GETPARSERCURSOR, EOI = _ref1.EOI, BOI = _ref1.BOI, EOL = _ref1.EOL, BOL = _ref1.BOL, STEP = _ref1.STEP, LEFTPARSERDATA = _ref1.LEFTPARSERDATA, SUBPARSERDATA = _ref1.SUBPARSERDATA, NEXTCHAR = _ref1.NEXTCHAR, MAY = _ref1.MAY, LAZYMAY = _ref1.LAZYMAY, GREEDYMAY = _ref1.GREEDYMAY, ANY = _ref1.ANY, LAZYANY = _ref1.LAZYANY, GREEDYANY = _ref1.GREEDYANY, PARALLEL = _ref1.PARALLEL, FOLLOW = _ref1.FOLLOW, NOTFOLLOW = _ref1.NOTFOLLOW, ADD = _ref1.ADD, SUB = _ref1.SUB, MUL = _ref1.MUL, DIV = _ref1.DIV, MOD = _ref1.MOD, AND = _ref1.AND, OR = _ref1.OR, NOT = _ref1.NOT, BITAND = _ref1.BITAND, BITOR = _ref1.BITOR, BITXOR = _ref1.BITXOR, LSHIFT = _ref1.LSHIFT, RSHIFT = _ref1.RSHIFT, EQ = _ref1.EQ, NE = _ref1.NE, LE = _ref1.LE, LT = _ref1.LT, GT = _ref1.GT, GE = _ref1.GE, NEG = _ref1.NEG, BITNOT = _ref1.BITNOT, SEXPR_HEAD_FIRST = _ref1.SEXPR_HEAD_FIRST, SEXPR_HEAD_LAST = _ref1.SEXPR_HEAD_LAST, PUSH = _ref1.PUSH, LIST = _ref1.LIST, INDEX = _ref1.INDEX, ATTR = _ref1.ATTR, LENGTH = _ref1.LENGTH, SLICE = _ref1.SLICE, POP = _ref1.POP, INSTANCEOF = _ref1.INSTANCEOF;

  hasOwnProperty = Object.prototype.hasOwnProperty;

  exports.solve = function(exp, path) {
    var compiled, e;

    path = process.cwd() + '/lib/compiled.js';
    try {
      fs.unlinkSync(path);
    } catch (_error) {
      e = _error;
      null;
    }
    compile(exp, path);
    delete require.cache[require.resolve(path)];
    compiled = require(path);
    return compiled.main();
  };

  compile = function(exp, path) {
    var code, compiler, fd;

    compiler = new Compiler();
    code = compiler.compile(exp) + "\n//exports.main();";
    code = beautify(code, {
      indent_size: 2
    });
    fd = fs.openSync(path, 'w');
    fs.writeSync(fd, code);
    return fs.closeSync(fd);
  };

  exports.Compiler = Compiler = (function() {
    function Compiler() {
      this.nameToVarIndex = {};
      this.exits = {};
      this.continues = {};
      this.protect = function(cont) {
        return cont;
      };
      this.nameVarMap = {};
    }

    Compiler.prototype.compile = function(exp) {
      var done, env, exps, lamda, v;

      this.env = env = new CpsEnv(null, {});
      exp = this.alpha(exp);
      this.env = env;
      v = this.newconst('v');
      done = il.idcont();
      exps = [il.assign(il.uservar('_'), il.require('underscore')), il.assign(il.uservar('__slice'), il.attr([], il.symbol('slice'))), il.assign(il.uservar('solve'), il.attr(il.require('./core'), il.symbol('solve'))), il.assign(il.uservar('parser'), il.require('./parser')), il.assign(il.uservar('solvecore'), il.require('./solve')), il.assign(il.uservar('Solver'), il.attr(il.uservar('solvecore'), il.symbol('Solver'))), il.assign(il.uservar('Trail'), il.attr(il.uservar('solvecore'), il.symbol('Trail'))), il.assign(il.uservar('Var'), il.attr(il.uservar('solvecore'), il.symbol('Var'))), il.assign(il.uservar('DummyVar'), il.attr(il.uservar('solvecore'), il.symbol('DummyVar'))), il.assign(il.uservar('solver'), il["new"](il.symbol('Solver').call())), il.assign(il.uservar('UArray'), il.attr(il.uservar('solvecore'), il.symbol('UArray'))), il.assign(il.uservar('UObject'), il.attr(il.uservar('solvecore'), il.symbol('UObject'))), il.assign(il.uservar('Cons'), il.attr(il.uservar('solvecore'), il.symbol('Cons'))), il.assign(il.parsercursor, null), il.assign(il.catches, {}), il.assign(il.trail, il.newTrail), il.assign(il.failcont, done), il.assign(il.cutcont, il.failcont), il.userlamda([], this.cont(exp, done)).call()];
      lamda = il.userlamda.apply(il, [[]].concat(__slice.call(exps)));
      env = new OptimizationEnv(env, {});
      lamda = this.optimize(lamda, env);
      lamda = lamda.jsify(this, env);
      exp = il.assign(il.attr(il.uservar('exports'), il.symbol('main')), lamda);
      return exp.toCode(this);
    };

    Compiler.prototype.lookup = function(name) {
      var e;

      try {
        return this.env.lookup(name);
      } catch (_error) {
        e = _error;
        return name;
      }
    };

    Compiler.prototype.uservar = function(name) {
      var map, v;

      map = this.nameVarMap;
      v = map[name];
      if (v) {
        return v;
      } else {
        map[name] = v = il.uservar(name);
        return v;
      }
    };

    Compiler.prototype.userconst = function(name) {
      var map, v;

      map = this.nameVarMap;
      v = map[name];
      if (v) {
        return v;
      } else {
        map[name] = v = il.uservar(name);
        v.isConst = true;
        return v;
      }
    };

    Compiler.prototype.newvar = function(v) {
      if (isString(v)) {
        return this.env.newvar(il.internalvar(v));
      } else {
        return this.env.newvar(v);
      }
    };

    Compiler.prototype.newconst = function(v) {
      if (isString(v)) {
        return this.env.newconst(il.internalvar(v));
      } else {
        return this.env.newconst(v);
      }
    };

    Compiler.prototype.pushEnv = function() {
      return this.env = this.env.extend();
    };

    Compiler.prototype.popEnv = function() {
      return this.env = this.env.outer;
    };

    Compiler.prototype.alpha = function(exp) {
      var bindings, e, head, left, length, name, p, params, result, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

      if (isString(exp)) {
        return this.lookup(exp);
      }
      if (!isArray(exp)) {
        return exp;
      }
      length = exp.length;
      if (length === 0) {
        return exp;
      }
      if (length === 1) {
        exp;
      }
      head = exp[0];
      if (!isInteger(head)) {
        return exp;
      }
      if (head < SEXPR_HEAD_FIRST || head > SEXPR_HEAD_LAST) {
        throw new Error(exp);
      }
      switch (head) {
        case STRING:
        case DIRECT:
        case LOGICVAR:
        case DUMMYVAR:
          return exp;
        case NONLOCAL:
          result = [head];
          _ref2 = exp.slice(1);
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            name = _ref2[_i];
            result.push(this.env.alphaName(name));
          }
          return result;
        case VARIABLE:
          result = [head];
          result.push((function() {
            var _j, _len1, _ref3, _results;

            _ref3 = exp.slice(1);
            _results = [];
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              name = _ref3[_j];
              _results.push(this.env.alphaName(name));
            }
            return _results;
          }).call(this));
          return result;
        case ASSIGN:
          left = exp[1];
          if (isString(left)) {
            left = this.env.alphaName(left);
          } else {
            left = this.alpha(left);
          }
          return [head, left, this.alpha(exp[2])];
        case AUGMENTASSIGN:
          return [head, exp[1], this.alpha(exp[2]), this.alpha(exp[3])];
        case UNIQUEVAR:
        case UNIQUECONST:
          return [head, this.env.uniqueName(exp[1], exp[2])];
        case LAMDA:
          result = [head];
          this.pushEnv();
          params = exp[1];
          result.push((function() {
            var _j, _len1, _results;

            _results = [];
            for (_j = 0, _len1 = params.length; _j < _len1; _j++) {
              p = params[_j];
              _results.push(this.env.alphaName(p));
            }
            return _results;
          }).call(this));
          _ref3 = exp.slice(2);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            e = _ref3[_j];
            result.push(this.alpha(e));
          }
          this.popEnv();
          return result;
        case MACRO:
          result = [head];
          this.pushEnv();
          params = exp[1];
          result.push((function() {
            var _k, _len2, _results;

            _results = [];
            for (_k = 0, _len2 = params.length; _k < _len2; _k++) {
              p = params[_k];
              _results.push(this.env.alphaName(p));
            }
            return _results;
          }).call(this));
          bindings = this.env.bindings;
          _ref4 = exp[1];
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            p = _ref4[_k];
            bindings[p] = [EVALARG, bindings[p]];
          }
          _ref5 = exp.slice(2);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            e = _ref5[_l];
            result.push(this.alpha(e));
          }
          this.popEnv();
          return result;
        case BLOCK:
          result = [head, exp[1]];
          _ref6 = exp.slice(2);
          for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
            e = _ref6[_m];
            result.push(this.alpha(e));
          }
          return result;
        case BREAK:
          return [head, exp[1], this.alpha(exp[2])];
        case CONTINUE:
          return [head, exp[1]];
        default:
          result = [head];
          _ref7 = exp.slice(1);
          for (_n = 0, _len5 = _ref7.length; _n < _len5; _n++) {
            e = _ref7[_n];
            result.push(this.alpha(e));
          }
          return result;
      }
    };

    Compiler.prototype.cont = function(exp, cont) {
      var act, anyCont, anyFcont, args, body, c, catchBody, cc, checkFunction, clause, clauses, cleanup, compiler, container, continueCont, continues, data, defaultContinues, defaultExits, exitCont, exits, f, fc, final, fun, head, i, init, k, label, length, length1, length2, length3, list1, list2, name, obj, oldEffect, oldprotect, p, params, params1, parsercursor, pos, result, result1, right, start1, start2, start3, step, temp, temp1, temp2, template, test, text, trail, uobj, v, v1, v2, value, value1, value2, values, vop, x1, xs, y1, _base, _base1, _base2, _base3, _i, _j, _k, _l, _len, _m, _n, _o, _p, _q, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;

      if (isString(exp)) {
        return cont.call(this.uservar(exp));
      }
      if (!isArray(exp)) {
        return cont.call(exp);
      }
      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      }
      head = exp[0];
      if (!isInteger(head)) {
        return cont.call(exp);
      }
      switch (head) {
        case QUOTE:
          return cont.call(exp[1]);
        case EVAL:
          v = this.newconst('v');
          p = this.newconst('path');
          return this.cont(exp[1], il.clamda(v, this.cont(exp[1], il.clamda(p, cont.call(il.evalexpr(v, p))))));
        case STRING:
          return cont.call(exp[1]);
        case BEGIN:
          return this.expsCont(exp.slice(1), cont);
        case NONLOCAL:
          return il.begin(il.nonlocal((function() {
            var _i, _len, _ref2, _results;

            _ref2 = exp.slice(1);
            _results = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              name = _ref2[_i];
              _results.push(this.uservar(name));
            }
            return _results;
          }).call(this)), cont.call(null));
        case VARIABLE:
          _ref2 = exp.slice(1);
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            name = _ref2[_i];
            v = this.uservar(name);
            delete v.isConst;
          }
          return cont.call(null);
        case UNIQUEVAR:
          return cont.call(this.uservar(exp[1]));
        case UNIQUECONST:
          return cont.call(this.userconst(exp[1]));
        case ASSIGN:
          return this.leftValueCont(cont, ASSIGN, exp[1], exp[2]);
        case AUGMENTASSIGN:
          return this.leftValueCont(cont, AUGMENTASSIGN, exp[2], exp[3], exp[1]);
        case INC:
          return this.leftValueCont(cont, INC, exp[1]);
        case SUFFIXINC:
          return this.leftValueCont(cont, SUFFIXINC, exp[1]);
        case DEC:
          return this.leftValueCont(cont, DEC, exp[1]);
        case SUFFIXDEC:
          return this.leftValueCont(cont, SUFFIXDEC, exp[1]);
        case INCP:
          return this.leftValueCont(cont, INCP, exp[1]);
        case SUFFIXINCP:
          return this.leftValueCont(cont, SUFFIXINCP, exp[1]);
        case DECP:
          return this.leftValueCont(cont, DECP, exp[1]);
        case SUFFIXDECP:
          return this.leftValueCont(cont, SUFFIXDECP, exp[1]);
        case IF:
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, il.if_(v, this.cont(exp[2], cont), this.cont(exp[3], cont))));
        case SWITCH:
          v = this.newconst('v');
          clauses = (function() {
            var _j, _len1, _ref3, _results;

            _ref3 = exp[1];
            _results = [];
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              clause = _ref3[_j];
              values = clause[0];
              act = clause[1];
              values = (function() {
                var _k, _len2, _results1;

                _results1 = [];
                for (_k = 0, _len2 = values.length; _k < _len2; _k++) {
                  value = values[_k];
                  _results1.push(il.lamda([], this.cont(value, il.idcont())).call());
                }
                return _results1;
              }).call(this);
              act = this.cont(act, cont);
              _results.push([values, act]);
            }
            return _results;
          }).call(this);
          return this.cont(exp[0], il.clamda(v, il.switch_(v, clauses, this.cont(exp[2], cont))));
        case JSFUN:
          f = il.jsfun(exp[1]);
          f._effect = this._effect;
          return cont.call(f);
        case DIRECT:
          return il.begin(exp[1], cont.call());
        case PURE:
          oldEffect = this._effect;
          this._effect = il.PURE;
          result = this.cont(exp[1], cont);
          this._effect = oldEffect;
          return result;
        case EFFECT:
          oldEffect = this._effect;
          this._effect = il.EFFECT;
          result = this.cont(exp[1], cont);
          this._effect = oldEffect;
          return result;
        case IO:
          oldEffect = this._effect;
          this._effect = il.IO;
          result = this.cont(exp[1], cont);
          this._effect = oldEffect;
          return result;
        case LAMDA:
          this.pushEnv();
          params = (function() {
            var _j, _len1, _ref3, _results;

            _ref3 = exp[1];
            _results = [];
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              p = _ref3[_j];
              _results.push(this.uservar(p));
            }
            return _results;
          }).call(this);
          k = this.newconst('cont');
          params.push(k);
          cont = cont.call(il.userlamda(params, this.expsCont(exp.slice(2), k)));
          this.popEnv();
          return cont;
        case MACRO:
          this.pushEnv();
          params1 = (function() {
            var _j, _len1, _ref3, _results;

            _ref3 = exp[1];
            _results = [];
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              p = _ref3[_j];
              _results.push(this.uservar(p));
            }
            return _results;
          }).call(this);
          k = this.newconst('cont');
          params1.push(k);
          cont = cont.call(il.lamda(params1, this.expsCont(exp.slice(2), k)));
          this.popEnv();
          return cont;
        case EVALARG:
          return cont.call(this.uservar(exp[1]).call());
        case ARRAY:
          args = exp.slice(1);
          compiler = this;
          length = args.length;
          xs = (function() {
            var _j, _results;

            _results = [];
            for (i = _j = 0; 0 <= length ? _j < length : _j > length; i = 0 <= length ? ++_j : --_j) {
              _results.push(this.newconst('x' + i));
            }
            return _results;
          }).call(this);
          cont = cont.call(il.array(xs));
          for (i = _j = _ref3 = length - 1; _j >= 0; i = _j += -1) {
            cont = (function(i, cont) {
              return compiler.cont(args[i], il.clamda(xs[i], cont));
            })(i, cont);
          }
          return cont;
        case UARRAY:
          args = exp.slice(1);
          compiler = this;
          length = args.length;
          xs = (function() {
            var _k, _results;

            _results = [];
            for (i = _k = 0; 0 <= length ? _k < length : _k > length; i = 0 <= length ? ++_k : --_k) {
              _results.push(this.newconst('x' + i));
            }
            return _results;
          }).call(this);
          cont = cont.call(il.uarray.apply(il, xs));
          for (i = _k = _ref4 = length - 1; _k >= 0; i = _k += -1) {
            cont = (function(i, cont) {
              return compiler.cont(args[i], il.clamda(xs[i], cont));
            })(i, cont);
          }
          return cont;
        case MAKEOBJECT:
          args = exp.slice(1);
          compiler = this;
          length = args.length;
          obj = this.newconst('object1');
          xs = (function() {
            var _l, _results;

            _results = [];
            for (i = _l = 0; 0 <= length ? _l < length : _l > length; i = 0 <= length ? ++_l : --_l) {
              _results.push(this.newconst('x' + i));
            }
            return _results;
          }).call(this);
          cont = il.begin(il.assign(obj, {}), il.setobject(obj, xs), cont.call(obj));
          for (i = _l = _ref5 = length - 1; _l >= 0; i = _l += -1) {
            cont = (function(i, cont) {
              return compiler.cont(args[i], il.clamda(xs[i], cont));
            })(i, cont);
          }
          return cont;
        case UOBJECT:
          args = exp.slice(1);
          compiler = this;
          length = args.length;
          obj = this.newconst('object1');
          uobj = this.newconst('uobject1');
          xs = (function() {
            var _m, _results;

            _results = [];
            for (i = _m = 0; 0 <= length ? _m < length : _m > length; i = 0 <= length ? ++_m : --_m) {
              _results.push(this.newconst('x' + i));
            }
            return _results;
          }).call(this);
          cont = il.begin(il.assign(obj, {}), il.setobject(obj, xs), il.assign(uobj, il.uobject(obj)), cont.call(uobj));
          for (i = _m = _ref6 = length - 1; _m >= 0; i = _m += -1) {
            cont = (function(i, cont) {
              return compiler.cont(args[i], il.clamda(xs[i], cont));
            })(i, cont);
          }
          return cont;
        case CONS:
          v = this.newconst('v');
          v1 = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, this.cont(exp[2], il.clamda(v1, cont.call(il.cons(v, v1))))));
        case FUNCALL:
          args = exp.slice(2);
          compiler = this;
          f = this.newconst('func');
          length = args.length;
          params = (function() {
            var _n, _results;

            _results = [];
            for (i = _n = 0; 0 <= length ? _n < length : _n > length; i = 0 <= length ? ++_n : --_n) {
              _results.push(this.newconst('arg' + i));
            }
            return _results;
          }).call(this);
          params.push(cont);
          body = f.apply(params);
          for (i = _n = _ref7 = length - 1; _n >= 0; i = _n += -1) {
            body = (function(i, body) {
              return compiler.cont(args[i], il.clamda(params[i], body));
            })(i, body);
          }
          return this.cont(exp[1], il.clamda(f, body));
        case MACROCALL:
          args = exp.slice(2);
          compiler = this;
          f = this.newconst('macro');
          length = args.length;
          params = (function() {
            var _o, _results;

            _results = [];
            for (i = _o = 0; 0 <= length ? _o < length : _o > length; i = 0 <= length ? ++_o : --_o) {
              _results.push(this.newconst('arg' + i));
            }
            return _results;
          }).call(this);
          params.push(cont);
          body = f.apply(params);
          for (i = _o = _ref8 = length - 1; _o >= 0; i = _o += -1) {
            body = (function(i, body) {
              return il.clamda(params[i], body).call(il.lamda([], compiler.cont(args[i], il.idcont())));
            })(i, body);
          }
          return this.cont(exp[1], il.clamda(f, body));
        case JSFUNCALL:
          args = exp.slice(2);
          compiler = this;
          f = this.newconst('func');
          length = args.length;
          params = (function() {
            var _p, _results;

            _results = [];
            for (i = _p = 0; 0 <= length ? _p < length : _p > length; i = 0 <= length ? ++_p : --_p) {
              _results.push(this.newconst('arg' + i));
            }
            return _results;
          }).call(this);
          body = cont.call(f.apply(params));
          for (i = _p = _ref9 = length - 1; _p >= 0; i = _p += -1) {
            body = (function(i, body) {
              return compiler.cont(args[i], il.clamda(params[i], body));
            })(i, body);
          }
          return this.cont(exp[1], il.clamda(f, body));
        case FOR:
          init = il.lamda([], compiler.cont(exp[1], il.idcont())).call();
          test = il.lamda([], compiler.cont(exp[2], il.idcont())).call();
          step = il.lamda([], compiler.cont(exp[3], il.idcont())).call();
          body = compiler.expsCont(exp.slice(4), il.idcont());
          return il.begin(il.for_(init, test, step, body), cont.call(null));
        case FORIN:
          container = il.lamda([], compiler.cont(exp[2], il.idcont())).call();
          body = compiler.expsCont(exp.slice(3), il.idcont());
          return il.begin(il.forin(this.userconst(exp[0]), container), cont.call(null));
        case FOROF:
          container = il.lamda([], compiler.cont(exp[2], il.idcont())).call();
          body = compiler.expsCont(exp.slice(3), il.idcont());
          return il.begin(il.forof(this.userconst(exp[1]), container), cont.call(null));
        case TRY:
          test = il.lamda([], compiler.cont(exp[1], il.idcont())).call();
          catchBody = compiler.cont(exp[3], il.idcont());
          final = compiler.cont(exp[4], il.idcont());
          return il.begin(il["try"](test, this.userconst(exp[2]), catchBody, final), cont.call(null));
        case QUASIQUOTE:
          return this.quasiquote(exp[1], cont);
        case UNQUOTE:
          throw new Error("unquote: too many unquote and unquoteSlice");
          break;
        case UNQUOTESLICE:
          throw new Error("unquoteSlice: too many unquote and unquoteSlice");
          break;
        case BLOCK:
          label = exp[1][1];
          if (!isString(label)) {
            label = '';
            body = [label].concat(body);
          }
          exits = (_ref10 = (_base = this.exits)[label]) != null ? _ref10 : _base[label] = [];
          exits.push(cont);
          defaultExits = (_ref11 = (_base1 = this.exits)['']) != null ? _ref11 : _base1[''] = [];
          defaultExits.push(cont);
          continues = (_ref12 = (_base2 = this.continues)[label]) != null ? _ref12 : _base2[label] = [];
          f = this.newconst(il.blockvar('block' + label));
          f.isRecursive = true;
          fun = il.blocklamda(null);
          continues.push(f);
          defaultContinues = (_ref13 = (_base3 = this.continues)['']) != null ? _ref13 : _base3[''] = [];
          defaultContinues.push(f);
          fun.body = this.expsCont(exp.slice(2), cont);
          exits.pop();
          if (exits.length === 0) {
            delete this.exits[label];
          }
          continues.pop();
          if (continues.length === 0) {
            delete this.continues[label];
          }
          defaultExits.pop();
          defaultContinues.pop();
          return il.begin(il.assign(f, fun), f.call());
        case BREAK:
          label = exp[1][1];
          exits = this.exits[label];
          if (!exits || exits === []) {
            throw new Error(label);
          }
          exitCont = exits[exits.length - 1];
          cont = this.cont(exp[2], this.protect(exitCont));
          return cont;
        case CONTINUE:
          label = exp[1][1];
          continues = this.continues[label];
          if (!continues || continues === []) {
            throw new Error(label);
          }
          continueCont = continues[continues.length - 1];
          return this.protect(continueCont).call();
        case CATCH:
          v = this.newconst('v');
          v2 = this.newconst('v');
          temp1 = this.newconst('temp');
          temp2 = this.newconst('temp');
          return this.cont(exp[1], il.clamda(v, il.assign(temp1, v), il.pushCatch(temp1, cont), this.expsCont(exp.slice(2), il.clamda(v2, il.assign(temp2, v2), il.popCatch(temp1), cont.call(temp2)))));
        case THROW:
          v = this.newconst('v');
          v2 = this.newconst('v');
          temp = this.newconst('temp');
          temp2 = this.newconst('temp');
          return this.cont(exp[1], il.clamda(v, il.assign(temp, v), this.cont(exp[2], il.clamda(v2, il.assign(temp2, v2), this.protect(il.findCatch(temp)).call(temp2)))));
        case UNWINDPROTECT:
          oldprotect = this.protect;
          v1 = this.newconst('v');
          v2 = this.newconst('v');
          temp = this.newconst('temp');
          temp2 = this.newconst('temp');
          compiler = this;
          cleanup = exp.slice(2);
          this.protect = function(cont) {
            return il.clamda(v1, il.assign(temp, v1), compiler.expsCont(cleanup, il.clamda(v2, v2, oldprotect(cont).call(temp))));
          };
          result = this.cont(exp[1], il.clamda(v1, il.assign(temp, v1), this.expsCont(cleanup, il.clamda(v2, v2, cont.call(temp)))));
          this.protect = oldprotect;
          return result;
        case CALLCC:
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, cont.call(v.call(cont, cont))));
        case CALLFC:
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, cont.call(v.call(il.failcont, cont))));
        case LOGICVAR:
          return cont.call(il.newLogicVar(exp[1]));
        case DUMMYVAR:
          return cont.call(il.newDummyVar(exp[1]));
        case UNIFY:
          x1 = this.newconst('x');
          y1 = this.newconst('y');
          return this.cont(exp[1], il.clamda(x1, this.cont(exp[2], il.clamda(y1, il.if_(il.unify(x1, y1), cont.call(true), il.failcont.call(false))))));
        case NOTUNIFY:
          x1 = this.newconst('x');
          y1 = this.newconst('y');
          return this.cont(exp[1], il.clamda(x1, this.cont(exp[2], il.clamda(y1, il.if_(il.unify(x, y), il.failcont.call(false), cont.call(true))))));
        case IS:
          v = this.newconst('v');
          return this.cont(exp[2], il.clamda(v, il.bind(this.userconst(exp[1]), v), cont.call(true)));
        case BIND:
          return il.begin(il.bind(this.userconst(exp[1]), il.deref(this.interlang(exp[2]))), cont.call(true));
        case GETVALUE:
          return cont.call(il.getvalue(this.interlang(exp[1])));
        case SUCCEED:
          return cont.call(true);
        case FAIL:
          return il.failcont.call(false);
        case PUSHP:
          list1 = this.newconst('list');
          value1 = this.newconst('value');
          list2 = this.newconst('list');
          value2 = this.newconst('value');
          fc = this.newconst('fc');
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(list1, il.assign(list2, list1), this.cont(exp[2], il.clamda(value1, il.assign(value2, value1), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.pop(list2), fc.call(value2))), il.push(list2, value2), cont.call(value2)))));
        case ORP:
          v = this.newconst('v');
          fc = this.newconst('fc');
          return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.setfailcont(fc), this.cont(exp[2], cont))), this.cont(exp[1], cont));
        case ORP2:
          v = this.newconst('v');
          trail = this.newconst('trail');
          fc = this.newconst('fc');
          return il.begin(il.assign(trail, il.trail), il.assign(fc, il.failcont), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, v, il.undotrail(il.trail), il.settrail(trail), il.setfailcont(fc), this.cont(exp[2], cont))), this.cont(exp[1], cont));
        case ORP3:
          v = this.newconst('v');
          trail = this.newconst('trail');
          parsercursor = this.newconst('parsercursor');
          fc = this.newconst('fc');
          return il.begin(il.assign(trail, il.trail), il.assign(parsercursor, il.parsercursor), il.assign(fc, il.failcont), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, v, il.undotrail(il.trail), il.settrail(trail), il.setparsercursor(parsercursor), il.setfailcont(fc), this.cont(exp[2], cont))), this.cont(exp[1], cont));
        case IFP:
          v = this.newconst('v');
          fc = this.newconst('fc');
          return il.begin(il.assign(fc, il.failcont), this.cont(exp[1], il.clamda(v, v, il.setfailcont(fc), this.cont(exp[2], cont))));
        case NOTP:
          v = this.newconst('v');
          fc = this.newconst('fc');
          return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.setfailcont(fc), cont.call(false))), this.cont(exp[1], fc));
        case NOTP2:
          v = this.newconst('v');
          trail = this.newconst('trail');
          fc = this.newconst('fc');
          return il.begin(il.assign(trail, il.trail), il.settrail(il.newTrail), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.undotrail(il.trail), il.settrail(trail), il.setfailcont(fc), cont.call(false))), this.cont(exp[1], fc));
        case NOTP3:
          v = this.newconst('v');
          trail = this.newconst('trail');
          parsercursor = this.newconst('parsercursor');
          fc = this.newconst('fc');
          return il.begin(il.assign(trail, il.trail), il.assign(fc, il.failcont), il.assign(parsercursor, il.parsercursor), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, v, il.undotrail(il.trail), il.settrail(trail), il.setparsercursor(parsercursor), il.setfailcont(fc), cont.call(false))), this.cont(exp[1], fc));
        case REPEAT:
          return il.begin(il.setfailcont(cont), cont.call(null));
        case CUTABLE:
          cc = this.newconst('cutcont');
          v = this.newconst('v');
          v1 = this.newconst('v');
          return il.begin(il.assign(cc, il.cutcont), il.assign(il.cutcont, il.failcont), this.cont(exp[1], il.clamda(v, il.assign(v1, v), il.setcutcont(cc), cont.call(v1))));
        case CUT:
          return il.begin(il.setfailcont(il.cutcont), cont.call(null));
        case FINDALL:
          fc = this.newconst('fc');
          v = this.newconst('v');
          v1 = this.newconst('v');
          result = exp[2];
          template = exp[3];
          if (result == null) {
            return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))), this.cont(exp[1], il.failcont));
          } else {
            v2 = this.newconst('v');
            result1 = this.newconst('result');
            return il.begin(il.assign(result1, []), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v2, il.assign(v1, v2), il.if_(il.unify(this.interlang(result), result1), il.begin(il.setfailcont(fc), cont.call(null)), fc.call(v1)))), this.cont(exp[1], il.clamda(v, il.assign(v1, v), il.push(result1, il.getvalue(this.interlang(template))), il.failcont.call(v1))));
          }
          break;
        case ONCE:
          fc = this.newconst('fc');
          v = this.newconst('v');
          v1 = this.newconst('v');
          return il.begin(il.assign(fc, il.failcont), this.cont(exp[1], il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))));
        case PARSE:
          v = this.newconst('v');
          v1 = this.newconst('v');
          return this.cont(exp[2], il.clamda(v, il.assign(v1, v), il.setparserdata(il.index(v1, 0)), il.setparsercursor(il.index(v1, 1)), this.cont(exp[1], il.clamda(v, cont.call(v)))));
        case PARSEDATA:
          v = this.newconst('v');
          data = this.newconst('data');
          return this.cont(exp[2], il.clamda(v, il.begin(il.assign(data, il.parserdata), il.setparserdata(v), il.setparsercursor(0), this.cont(exp[1], il.clamda(v, il.setparserdata(v), cont.call(il.parserdata))))));
        case SETPARSERSTATE:
          v = this.newconst('v');
          v1 = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, il.assign(v1, v), il.setparserdata(il.index(v, 0)), il.setparsercursor(il.index(v, 1)), cont.call(true)));
        case SETPARSERDATA:
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, il.setparserdata(v), il.setparsercursor(0), cont.call(true)));
        case SETPARSERCURSOR:
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, il.setparsercursor(v), cont.call(true)));
        case GETPARSERSTATE:
          return cont.call(il.array(il.parserdata, il.parsercursor));
        case GETPARSERDATA:
          return cont.call(il.parserdata);
        case GETPARSERCURSOR:
          return cont.call(il.parsercursor);
        case EOI:
          data = this.newconst('data');
          pos = this.newconst('pos');
          return il.begin(il.assign(data, il.parserdata), il.assign(pos, il.parsercursor), il.if_(il.ge(pos, il.length(data)), cont.call(true), il.failcont.call(false)));
        case BOI:
          return il.if_(il.eq(il.parsercursor, 0), cont.call(true), il.failcont.call(false));
        case EOL:
          text = this.newconst('text');
          pos = this.newconst('pos');
          c = this.newconst('c');
          return il.begin(il.assign(text, il.parserdata), il.assign(pos, il.parsercursor), il.if_(il.ge(pos, il.length(text)), cont.call(true), il.begin(il.assign(c, il.index(text, pos, 1)), il.if_(il.or_(il.eq(c, "\r"), il.eq(c, "\n")), cont.call(true), il.failcont.call(false)))));
        case BOL:
          text = this.newconst('text');
          pos = this.newconst('pos');
          c = this.newconst('c');
          return il.begin(il.assign(text, il.parserdata), il.assign(pos, il.parsercursor), il.if_(il.eq(pos, 0), cont.call(true), il.begin(il.assign(c, il.index(text, il.sub(pos, 1))), il.if_(il.or_(il.eq(c, "\r"), il.eq(c, "\n")), cont.call(true), il.failcont.call(false)))));
        case STEP:
          v = this.newconst('v');
          return this.cont(exp[1], il.clamda(v, il.setparsercursor(il.add(il.parsercursor, v)), cont.call(il.parsercursor)));
        case LEFTPARSERDATA:
          return cont.call(il.slice(il.parserdata, il.parsercursor));
        case SUBPARSERDATA:
          text = this.newconst('text');
          pos = this.newconst('pos');
          start1 = this.newconst('start');
          length1 = this.newconst('length');
          start2 = this.newconst('start');
          length2 = this.newconst('length');
          start3 = this.newconst('start');
          length3 = this.newconst('length');
          return this.cont(exp[1], il.clamda(length1, il.assign(length2, length1), this.cont(exp[2], il.clamda(start1, il.assign(start2, start1), il.assign(text, il.parserdata), il.assign(pos, il.parsercursor), il.begin(il.assign(start3, il.if_(il.ne(start2, null), start2, pos)), il.assign(length3, il.if_(il.ne(length2, null), length2, il.length(text))), cont.call(il.slice(text, start3, il.add(start3, length3))))))));
        case NEXTCHAR:
          return cont.call(il.index(il.parserdata, il.parsercursor));
        case MAY:
          return il.begin(il.appendFailcont(cont), this.cont(exp[1], cont));
        case LAZYMAY:
          fc = this.newconst('fc');
          v = this.newconst('v');
          return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, v, il.setfailcont(fc), this.cont(exp[1], cont))), cont.call(null));
        case GREEDYMAY:
          fc = this.newconst('fc');
          v = this.newconst('v');
          v1 = this.newconst('v');
          v2 = this.newconst('v');
          return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))), this.cont(exp[1], il.clamda(v, il.assign(v2, v), il.setfailcont(fc), cont.call(v2))));
        case ANY:
          fc = this.newconst('fc');
          trail = this.newconst('trail');
          parsercursor = this.newconst('parsercursor');
          anyCont = this.newconst('anyCont');
          anyCont.isRecursive = true;
          v = this.newconst('v');
          v1 = this.newconst('v');
          return il.begin(il.assign(anyCont, il.recclamda(v, il.assign(fc, il.failcont), il.assign(trail, il.trail), il.assign(parsercursor, il.parsercursor), il.settrail(il.newTrail), il.setfailcont(il.clamda(v, il.assign(v1, v), il.undotrail(il.trail), il.settrail(trail), il.setparsercursor(parsercursor), il.setfailcont(fc), cont.call(v1))), this.cont(exp[1], anyCont))), anyCont.call(null));
        case LAZYANY:
          fc = this.newconst('fc');
          v = this.newconst('v');
          anyCont = this.newconst('anyCont');
          anyFcont = this.newconst('anyFcont');
          anyCont.isRecursive = true;
          anyFcont.isRecursive = true;
          return il.begin(il.assign(anyCont, il.recclamda(v, il.setfailcont(anyFcont), cont.call(null))), il.assign(anyFcont, il.recclamda(v, il.setfailcont(fc), this.cont(exp[1], anyCont))), il.assign(fc, il.failcont), anyCont.call(null));
        case GREEDYANY:
          fc = this.newconst('fc');
          anyCont = this.newconst('anyCont');
          anyCont.isRecursive = true;
          v = this.newconst('v');
          v1 = this.newconst('v');
          return il.begin(il.assign(anyCont, il.recclamda(v, this.cont(exp[1], anyCont))), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(v1, v), il.setfailcont(fc), cont.call(v1))), anyCont.call(null));
        case PARALLEL:
          checkFunction = exp[3] || (function(parsercursor, baseParserCursor) {
            return parsercursor === baseParserCursor;
          });
          parsercursor = this.newconst('parsercursor');
          right = this.newconst('right');
          v = this.newconst('v');
          v1 = this.newconst('v');
          return il.begin(il.assign(parsercursor, il.parsercursor), this.cont(exp[1], il.clamda(v, v, il.assign(right, il.parsercursor), il.setparsercursor(parsercursor), this.cont(exp[2], il.clamda(v, il.assign(v1, v), il.if_(il.fun(checkFunction).call(il.parsercursor, right), cont.call(v1), il.failcont.call(v1)))))));
        case FOLLOW:
          parsercursor = this.newconst('parsercursor');
          v = this.newconst('v');
          v1 = this.newconst('v');
          parsercursor = this.newconst('parsercursor');
          return il.begin(il.assign(parsercursor, il.parsercursor), this.cont(exp[1], il.clamda(v, il.assign(v1, v), il.setparsercursor(parsercursor), cont.call(v))));
        case NOTFOLLOW:
          parsercursor = this.newconst('parsercursor');
          fc = this.newconst('fc');
          v = this.newconst('v');
          v1 = this.newconst('v');
          return il.begin(il.assign(fc, il.failcont), il.assign(parsercursor, il.parsercursor), il.setfailcont(cont), this.cont(exp[1], il.clamda(v, il.assign(v1, v), il.setparsercursor(parsercursor), fc.call(v1))));
        case ADD:
        case SUB:
        case MUL:
        case DIV:
        case MOD:
        case AND:
        case OR:
        case NOT:
        case BITAND:
        case BITOR:
        case BITXOR:
        case LSHIFT:
        case RSHIFT:
        case EQ:
        case NE:
        case LE:
        case LT:
        case GT:
        case GE:
        case NEG:
        case BITNOT:
        case PUSH:
        case LIST:
        case INDEX:
        case ATTR:
        case LENGTH:
        case SLICE:
        case POP:
        case INSTANCEOF:
          vop = il.vopMaps[head];
          args = exp.slice(1);
          compiler = this;
          length = args.length;
          params = (function() {
            var _q, _results;

            _results = [];
            for (i = _q = 0; 0 <= length ? _q < length : _q > length; i = 0 <= length ? ++_q : --_q) {
              _results.push(this.newconst('a' + i));
            }
            return _results;
          }).call(this);
          cont = cont.call(vop.apply(null, params));
          for (i = _q = _ref14 = length - 1; _q >= 0; i = _q += -1) {
            cont = (function(i, cont) {
              return compiler.cont(args[i], il.clamda(params[i], cont));
            })(i, cont);
          }
          return cont;
        default:
          throw new Error(exp);
      }
    };

    Compiler.prototype.leftValueCont = function(cont, task, item, exp, op) {
      var assignExpCont, head, i, index, length, obj, object,
        _this = this;

      assignExpCont = function(item) {
        var fc, temp, v;

        v = _this.newconst('v');
        temp = _this.newconst('temp');
        switch (task) {
          case ASSIGN:
            return _this.cont(exp, il.clamda(v, il.assign(item, v), cont.call(item)));
          case AUGMENTASSIGN:
            return _this.cont(exp, il.clamda(v, il.assign(item, il[op](item, v)), cont.call(item)));
          case INC:
            return il.begin(il.assign(item, il.add(item, 1)), cont.call(item));
          case DEC:
            return il.begin(il.assign(item, il.sub(item, 1)), cont.call(item));
          case SUFFIXINC:
            return il.begin(il.assign(temp, item), il.assign(item, il.add(item, 1)), cont.call(temp));
          case SUFFIXDEC:
            return il.begin(il.assign(temp, item), il.assign(item, il.sub(item, 1)), cont.call(temp));
          case INCP:
            fc = _this.newconst('fc');
            return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.sub(item, 1)), fc.call(item))), il.assign(item, il.add(item, 1)), cont.call(item));
          case DECP:
            fc = _this.newconst('fc');
            return il.begin(il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.add(item, 1)), fc.call(item))), il.assign(item, il.sub(item, 1)), cont.call(item));
          case SUFFIXINCP:
            fc = _this.newconst('fc');
            return il.begin(il.assign(temp, item), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.sub(item, 1)), fc.call(temp))), il.assign(item, il.add(item, 1)), cont.call(temp));
          case SUFFIXINCP:
            fc = _this.newconst('fc');
            return il.begin(il.assign(temp, item), il.assign(fc, il.failcont), il.setfailcont(il.clamda(v, il.assign(item, il.add(item, 1)), fc.call(temp))), il.assign(item, il.sub(item, 1)), cont.call(temp));
        }
      };
      if (isString(item)) {
        return assignExpCont(this.uservar(item));
      }
      if (!isArray(item)) {
        throw new Error("Left value should be an sexpression.");
      }
      length = item.length;
      if (length === 0) {
        throw new Error("Left value side should not be empty list.");
      }
      head = item[0];
      if (!isInteger(head)) {
        throw new Error("sexpression head should be a integer.");
      }
      if (head === INDEX) {
        object = item[1];
        index = item[2];
        obj = this.newconst('obj');
        i = this.newconst('i');
        return this.cont(object, il.clamda(obj, this.cont(index, il.clamda(i, assignExpCont(il.index(obj, i))))));
      } else if (head === UNIQUEVAR) {
        return assignExpCont(this.uservar(item[1]));
      } else if (head === UNIQUECONST) {
        return assignExpCont(this.userconst(item[1]));
      } else {
        throw new Error("Left Value side should be assignable expression.");
      }
    };

    Compiler.prototype.expsCont = function(exps, cont) {
      var length, v;

      length = exps.length;
      if (length === 0) {
        throw new exports.TypeError(exps);
      } else if (length === 1) {
        return this.cont(exps[0], cont);
      } else {
        v = this.newconst('v');
        return this.cont(exps[0], il.clamda(v, v, this.expsCont(exps.slice(1), cont)));
      }
    };

    Compiler.prototype.quasiquote = function(exp, cont) {
      var e, head, i, length, quasilist, v, _i, _ref2;

      if (!isArray(exp)) {
        return cont.call(exp);
      }
      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      }
      head = exp[0];
      if (!isInteger(head)) {
        return cont.call(exp);
      }
      if (head < SEXPR_HEAD_FIRST || head > SEXPR_HEAD_LAST) {
        return cont.call(exp);
      }
      switch (head) {
        case UNQUOTE:
          return this.cont(exp[1], cont);
        case UNQUOTESLICE:
          return this.cont(exp[1], cont);
        case QUOTE:
          return cont.call(exp);
        case STRING:
          return cont.call(exp);
        default:
          quasilist = this.newvar('quasilist');
          v = this.newconst('v');
          cont = cont.call(quasilist);
          for (i = _i = _ref2 = exp.length - 1; _i >= 1; i = _i += -1) {
            e = exp[i];
            if (isArray(e) && e.length > 0 && e[0] === UNQUOTESLICE) {
              cont = this.quasiquote(e, il.clamda(v, il.assign(quasilist, il.concat(quasilist, v)), cont));
            } else {
              cont = this.quasiquote(e, il.clamda(v, il.push(quasilist, v), cont));
            }
          }
          return il.begin(il.assign(quasilist, il.list(head)), cont);
      }
    };

    Compiler.prototype.interlang = function(term) {
      var head, length;

      if (isString(term)) {
        return this.uservar(term);
      }
      if (!isArray(term)) {
        return term;
      }
      length = term.length;
      if (length === 0) {
        return term;
      }
      head = term[0];
      if (!isInteger(head)) {
        return term;
      }
      if (head === STRING) {
        return term[1];
      }
      if (head === UNIQUEVAR) {
        return this.uservar(term);
      }
      if (head === UNIQUECONST) {
        return this.userconst(term);
      }
      return term;
    };

    Compiler.prototype.optimize = function(exp, env) {
      var expOptimize;

      expOptimize = exp != null ? exp.optimize : void 0;
      if (expOptimize) {
        return expOptimize.call(exp, env, this);
      } else {
        return exp;
      }
    };

    Compiler.prototype.toCode = function(exp) {
      var exptoCode;

      exptoCode = exp != null ? exp.toCode : void 0;
      if (exptoCode) {
        return exptoCode.call(exp, this);
      } else if (typeof exp === 'function') {
        return exp.toString();
      } else {
        return JSON.stringify(exp);
      }
    };

    return Compiler;

  })();

  Env = (function() {
    function Env() {}

    return Env;

  })();

  exports.Env = Env = (function() {
    function Env(outer, bindings) {
      this.outer = outer;
      this.bindings = bindings;
    }

    Env.prototype.extend = function(bindings) {
      if (bindings == null) {
        bindings = {};
      }
      return new this.constructor(this, bindings);
    };

    Env.prototype.lookup = function(vari) {
      var bindings, outer;

      bindings = this.bindings;
      if (bindings.hasOwnProperty(vari)) {
        return bindings[vari];
      } else {
        outer = this.outer;
        if (outer) {
          return outer.lookup(vari);
        } else {
          return vari;
        }
      }
    };

    return Env;

  })();

  CpsEnv = (function(_super) {
    __extends(CpsEnv, _super);

    function CpsEnv(outer, bindings) {
      this.outer = outer;
      this.bindings = bindings;
      if (this.outer) {
        this.indexMap = this.outer.indexMap;
        this.vars = this.outer.vars;
      } else {
        this.indexMap = {};
        this.vars = {};
      }
    }

    CpsEnv.prototype.newvar = function(vari) {
      var index, vars;

      vars = this.vars;
      index = this.indexMap[vari.name] || 2;
      while (1) {
        if (!hasOwnProperty.call(vars, vari)) {
          vars[vari] = vari;
          this.indexMap[vari.name] = index;
          return vari;
        }
        vari = new vari.constructor(vari.name, (index++).toString());
      }
    };

    CpsEnv.prototype.alphaNewName = function(name) {
      var index, newName, vars;

      vars = this.vars;
      index = this.indexMap[name] || 2;
      newName = name;
      while (1) {
        if (!hasOwnProperty.call(vars, newName)) {
          vars[name] = newName;
          this.indexMap[name] = index;
          return newName;
        }
        newName = name + index;
      }
    };

    CpsEnv.prototype.newconst = function(vari) {
      var index, vars;

      vars = this.vars;
      index = this.indexMap[vari.name] || 2;
      while (1) {
        if (!hasOwnProperty.call(vars, vari)) {
          vars[vari] = vari;
          this.indexMap[vari.name] = index;
          vari.isConst = true;
          return vari;
        }
        vari = new vari.constructor(vari.name, (index++).toString());
      }
    };

    CpsEnv.prototype.lookup = function(vari) {
      var bindings, outer;

      bindings = this.bindings;
      if (hasOwnProperty.call(bindings, vari)) {
        return bindings[vari];
      } else {
        outer = this.outer;
        if (outer) {
          return outer.lookup(vari);
        } else {
          throw new VarLookupError(vari);
        }
      }
    };

    CpsEnv.prototype.getvar = function(vari) {
      var e, v;

      try {
        return this.lookup(vari);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[vari] = v = this.newconst(vari);
          return v;
        }
      }
    };

    CpsEnv.prototype.alphaName = function(name) {
      var e;

      try {
        return name = this.lookup(name);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[name] = name = this.alphaNewName(name);
          return name;
        }
      }
    };

    CpsEnv.prototype.alphaMacroParam = function(name) {
      var e, result;

      try {
        return name = this.lookup(name);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[name] = result = ['evalarg', this.alphaNewName(name)];
          return result;
        }
      }
    };

    CpsEnv.prototype.uniqueName = function(name, index) {
      var e, uniquename, v;

      uniquename = '@' + name + index;
      try {
        return this.lookup(uniquename);
      } catch (_error) {
        e = _error;
        if (e instanceof VarLookupError) {
          this.bindings[uniquename] = v = this.alphaNewName(name);
          return v;
        }
      }
    };

    return CpsEnv;

  })(Env);

  exports.OptimizationEnv = OptimizationEnv = (function(_super) {
    __extends(OptimizationEnv, _super);

    function OptimizationEnv(outer, bindings, lamda) {
      this.outer = outer;
      this.lamda = lamda;
      if (bindings) {
        this.bindings = bindings;
      } else {
        this.bindings = outer.bindings;
      }
      if (this.outer) {
        this.indexMap = this.outer.indexMap;
        this.vars = this.outer.vars;
      } else {
        this.indexMap = {};
        this.vars = {};
      }
      if (lamda instanceof il.UserLamda) {
        this.userlamda = lamda;
      } else {
        while (outer) {
          if (outer.userlamda) {
            this.userlamda = outer.userlamda;
            return;
          }
          outer = outer.outer;
        }
      }
    }

    OptimizationEnv.prototype.extendBindings = function(bindings, lamda) {
      return new OptimizationEnv(this, bindings, lamda);
    };

    OptimizationEnv.prototype.lookup = function(vari) {
      var bindings, outer;

      bindings = this.bindings;
      if (bindings.hasOwnProperty(vari)) {
        return bindings[vari];
      } else {
        if (this.isConst) {
          outer = this.outer;
          if (outer) {
            return outer.lookup(vari);
          } else {
            return vari;
          }
        } else {
          return vari;
        }
      }
    };

    return OptimizationEnv;

  })(CpsEnv);

  exports.Error = Error = (function() {
    function Error(exp, message, stack) {
      this.exp = exp;
      this.message = message != null ? message : '';
      this.stack = stack != null ? stack : this;
    }

    Error.prototype.toString = function() {
      return "" + this.constructor.name + ": " + this.exp + " >>> " + this.message;
    };

    return Error;

  })();

  VarLookupError = (function() {
    function VarLookupError(vari) {
      this.vari = vari;
    }

    return VarLookupError;

  })();

  exports.TypeError = TypeError = (function(_super) {
    __extends(TypeError, _super);

    function TypeError() {
      _ref2 = TypeError.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return TypeError;

  })(Error);

  exports.ArgumentError = ArgumentError = (function(_super) {
    __extends(ArgumentError, _super);

    function ArgumentError() {
      _ref3 = ArgumentError.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return ArgumentError;

  })(Error);

  exports.ArityError = ArityError = (function(_super) {
    __extends(ArityError, _super);

    function ArityError() {
      _ref4 = ArityError.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    return ArityError;

  })(Error);

}).call(this);

/*
//@ sourceMappingURL=core.map
*/
