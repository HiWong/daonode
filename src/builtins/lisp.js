// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, debug, general, if_fun, iff_fun, macro, not_, runner, solve, solver, special, _,
    __slice = [].slice;

  _ = require('underscore');

  solve = require("../../src/solve");

  general = require("../../src/builtins/general");

  solver = solve.solver;

  special = solve.special;

  macro = solve.macro;

  debug = solve.debug;

  exports.quote = special('quote', function(cont, exp) {
    return function() {
      solver.value = exp;
      return cont();
    };
  });

  exports.eval_ = special('eval', function(cont, exp) {
    return solver.cont(exp, function() {
      return solver.cont(solver.value, cont);
    });
  });

  exports.assign = special('assign', function(cont, vari, exp) {
    return solver.cont(exp, function() {
      vari.binding = solver.value;
      return cont;
    });
  });

  exports.begin = special('begin', function() {
    var cont, exps;

    cont = arguments[0], exps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return solver.expsCont(exps, cont);
  });

  if_fun = function(cont, test, then_, else_) {
    var else_cont, then_cont;

    then_cont = solver.cont(then_, cont);
    else_cont = solver.cont(else_, cont);
    return solver.cont(test, function() {
      if (solver.value) {
        return then_cont();
      } else {
        return else_cont();
      }
    });
  };

  exports.if_ = special('if_', if_fun);

  iff_fun = function(cont, clauses, else_) {
    var iff_else_cont, length, test, then_, then_cont, _ref, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new exports.TypeError(clauses);
    } else if (length === 1) {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      return if_fun(cont, test, then_, else_);
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      then_cont = solver.cont(then_, cont);
      iff_else_cont = iff_fun(cont, clauses.slice(1), else_);
      return solver.cont(test, function() {
        if (solver.value) {
          return then_cont();
        } else {
          return iff_else_cont();
        }
      });
    }
  };

  exports.iff = special('iff', iff_fun);

  /* iff's macro version
  iff = macro (clauses_, else_) ->
    length = clauses.length
    if length is 0 then throw new exports.TypeError(clauses)
    else if length is 1
      exports.if_(clauses[0][0], clauses[0][1], else_)
    else
       exports.if_(clauses[0][0], clauses[0][1], iff(clauses[1...], else_)
  */


  exports.block = block = special('block', function() {
    var body, cont, continues, defaultContinues, defaultExits, exits, fun, holder, label, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

    cont = arguments[0], label = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    exits = (_ref = (_base = solver.exits)[label]) != null ? _ref : _base[label] = [];
    exits.push(cont);
    defaultExits = (_ref1 = (_base1 = solver.exits)['']) != null ? _ref1 : _base1[''] = [];
    defaultExits.push(cont);
    holder = [null];
    continues = (_ref2 = (_base2 = solver.continues)[label]) != null ? _ref2 : _base2[label] = [];
    continues.push(holder);
    defaultContinues = (_ref3 = (_base3 = solver.continues)['']) != null ? _ref3 : _base3[''] = [];
    defaultContinues.push(holder);
    holder[0] = fun = solver.expsCont(body, cont);
    exits.pop();
    if (exits.length === 0) {
      delete solver.exits[label];
    }
    continues.pop();
    if (continues.length === 0) {
      delete solver.continues[label];
    }
    defaultExits.pop();
    defaultContinues.pop();
    return fun;
  });

  exports.break_ = break_ = special('break_', function(cont, label, value) {
    var exitCont, exits;

    if (label == null) {
      label = '';
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !_.isString(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !_.isString(label)) {
      value = label;
      label = '';
    }
    exits = solver.exits[label];
    if (!exits || exits === []) {
      throw Error(label);
    }
    exitCont = exits[exits.length - 1];
    return solver.cont(value, function() {
      return exitCont();
    });
  });

  exports.continue_ = continue_ = special('continue_', function(cont, label) {
    var continueCont, continues;

    if (label == null) {
      label = '';
    }
    continues = solver.continues[label];
    if (!continues || continues === []) {
      throw Error(label);
    }
    continueCont = continues[continues.length - 1];
    return function() {
      return continueCont[0]();
    };
  });

  not_ = general.not_;

  exports.loop_ = macro('loop', function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  });

  exports.while_ = macro('while_', function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  });

  exports.until_ = macro('until_', function() {
    var body, label, test, _i;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), test = arguments[_i++];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  });

  exports.catch_ = special('catch_', function() {
    var cont, forms, tag;

    cont = arguments[0], tag = arguments[1], forms = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.cont(tag, function() {
      var formsCont, v1;

      v1 = solver.value;
      solver.pushCatch(v1, cont);
      formsCont = solver.expsCont(forms, function() {
        solver.popCatch(v1);
        return cont();
      });
      return formsCont();
    });
  });

  exports.throw_ = special('throw_', function(cont, tag, form) {
    return solver.cont(tag, function() {
      var v;

      v = solver.value;
      return solver.cont(form, function() {
        return solver.protect(solver.findCatch(v))();
      })();
    });
  });

  exports.protect = special('protect', function() {
    var cleanup, cont, form, oldprotect;

    cont = arguments[0], form = arguments[1], cleanup = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    oldprotect = solver.protect;
    solver.protect = function(fun) {
      return function() {
        var value;

        value = solver.value;
        return solver.expsCont(cleanup, function() {
          solver.protect = oldprotect;
          solver.value = value;
          return oldprotect(fun)();
        })();
      };
    };
    return solver.cont(form, function() {
      var formValue;

      formValue = solver.value;
      return solver.expsCont(cleanup, function() {
        solver.protect = oldprotect;
        solver.value = formValue;
        return cont();
      })();
    });
  });

  runner = function(cont) {
    return function() {
      var d;

      d = solver.done;
      solver.done = false;
      while (!solver.done) {
        cont = cont();
      }
      solver.done = d;
      return solver.value;
    };
  };

  exports.callcc = special('callcc', function(cont, fun) {
    return function() {
      solver.value = fun(runner(cont));
      solver.done = false;
      return cont();
    };
  });

  exports.callfc = special('callfc', function(cont, fun) {
    return function() {
      solver.value = fun(runner(solver.failcont));
      solver.done = false;
      return cont();
    };
  });

  exports.quasiquote = exports.qq = special('quasiquote', function(cont, item) {
    return typeof solver.quasiquote === "function" ? solver.quasiquote(item, cont) : void 0;
  });

  exports.unquote = exports.uq = special('unquote', function(cont, item) {
    throw "unquote: too many unquote and unquoteSlice";
  });

  exports.unquoteSlice = exports.uqs = special('unquoteSlice', function(cont, item) {
    throw "unquoteSlice: too many unquote and unquoteSlice";
  });

}).call(this);

/*
//@ sourceMappingURL=lisp.map
*/
