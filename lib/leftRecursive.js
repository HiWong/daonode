// Generated by CoffeeScript 1.6.2
(function() {
  exports.BaseParser = (function() {
    function _Class() {}

    _Class.prototype.parse = function(code, options) {
      this.text = code;
      this.textLength = code.length;
      this.cursor = 0;
      this.tokens = [];
      this._memo = {};
      this.memoState = {};
      this.lookDepth = {};
      this.indentList = [];
      this.tabWidth = 4;
      this.yy = this.yy;
      return this.Root(0);
    };

    _Class.prototype.andp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        _this.cursor = start;
        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (!(result = exp(_this.cursor))) {
            return;
          }
        }
        return result;
      };
    };

    _Class.prototype.orp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (result = exp(start)) {
            return result;
          }
        }
      };
    };

    _Class.prototype.notp = function(exp) {
      var _this = this;

      return function(start) {
        if (exp(start)) {

        } else {
          return true;
        }
      };
    };

    _Class.prototype.char = function(c) {
      var _this = this;

      return function(start) {
        if (_this.text[start] === c) {
          _this.cursor = start + 1;
          return c;
        }
      };
    };

    _Class.prototype.literal = function(string) {
      var _this = this;

      return function(start) {
        var len, stop;

        len = string.length;
        if (_this.text.slice(start, stop = start + len) === string) {
          _this.cursor = stop;
          return true;
        }
      };
    };

    _Class.prototype.spaces = function(start) {
      var len, text;

      len = 0;
      this.cursor = start;
      text = this.text;
      while (1) {
        switch (text[this.cursor]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };

    _Class.prototype.spaces1 = function(start) {
      var cursor, len, text;

      len = 0;
      cursor = start;
      text = this.text;
      while (1) {
        switch (text[cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return this.cursor = cursor;
        return len;
      }
    };

    _Class.prototype.wrap = function(item, left, right) {
      if (left == null) {
        left = spaces;
      }
      if (right == null) {
        right = spaces;
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(this.cursor) && right(this.cursor))) {
          return result;
        }
      };
    };

    _Class.prototype.recursive = function(symbol) {
      var rule,
        _this = this;

      rule = this[symbol];
      return function(start) {
        var hash, m, memo, result;

        hash = symbol + start;
        memo = _this._memo;
        m = memo[hash];
        if (!m) {
          m = memo[hash] = [void 0, start];
        }
        while (1) {
          if ((result = rule(start)) && (result !== m[0] || _this.cursor !== m[1])) {
            memo[hash] = m = [result, _this.cursor];
          } else {
            return result;
          }
        }
      };
    };

    _Class.prototype.look = function(symbol) {
      var _this = this;

      return function(start) {
        var hash, m, m1, memo, memoState, rule, state;

        rule = _this[symbol];
        hash = symbol + start;
        memo = _this._memo;
        m = memo[hash];
        memoState = _this.memoState;
        while (1) {
          state = memoState[hash] = !memoState[hash];
          if (state) {
            rule(start);
          }
          m1 = memo[hash];
          if (m1 === m) {
            return m[0];
          } else {
            m = m1;
          }
        }
      };
    };

    _Class.prototype.memo = function(symbol) {
      var _this = this;

      return function(position) {
        var m;

        m = _this._memo[symbol + position];
        if (m) {
          _this.cursor = m[1];
          return m[0];
        }
      };
    };

    return _Class;

  })();

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
