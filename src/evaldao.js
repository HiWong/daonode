// Generated by CoffeeScript 1.6.2
(function() {
  var dao, deref, done, faildone, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('underscore');

  dao = exports;

  dao.Env = (function() {
    function Env(bindings, outer) {
      this.bindings = bindings != null ? bindings : {};
      this.outer = outer;
    }

    Env.prototype.extend = function(bindings) {
      return new Environemt(bindings, this);
    };

    Env.prototype.get = function(vari) {
      var env;

      env = this;
      while (env) {
        if (this.bindings.hasOwnProperty(vari.name)) {
          return this.bindings[vari.name];
        }
        env = env.outer;
      }
      return vari;
    };

    Env.prototype.set = function(vari, value) {
      this.bindings[vari.name] = value;
      return this;
    };

    return Env;

  })();

  dao.Bindings = (function() {
    function Bindings(map) {
      this.map = map != null ? map : {};
    }

    Bindings.prototype.clone = function() {
      return new dao.Bindings(_.extend({}, this.map));
    };

    Bindings.prototype.get = function(vari) {
      if (this.map.hasOwnProperty(vari.name)) {
        return this.map[vari.name];
      } else {
        return vari;
      }
    };

    Bindings.prototype.set = function(vari, value) {
      this.map[vari.name] = value;
      return this;
    };

    return Bindings;

  })();

  deref = function(x, env) {
    if (x instanceof dao.Var) {
      return x.deref(env);
    } else {
      return x;
    }
  };

  done = function(v, solver) {
    var result;

    console.log("succeed!");
    result = v.getvalue(solver.env);
    if (result instanceof dao.Atom) {
      return result.item;
    } else {
      return result;
    }
  };

  faildone = function(v, solver) {
    var result;

    console.log("fail!");
    result = v.getvalue(solver.env);
    if (result instanceof dao.Atom) {
      return result.item;
    } else {
      return result;
    }
  };

  dao.solve = function(exp, env, cont, failcont) {
    if (env == null) {
      env = new dao.Bindings();
    }
    if (cont == null) {
      cont = done;
    }
    if (failcont == null) {
      failcont = faildone;
    }
    if (_.isNumber(exp)) {
      exp = dao.number(exp);
    } else if (_.isString(exp)) {
      exp = dao.string(exp);
    } else if (!_.isObject(exp)) {
      exp = dao.atom(exp);
    } else if (!exp instanceof dao.Element) {
      exp = dao.atom(exp);
    }
    return new dao.Solver(env, failcont).solve(exp);
  };

  dao.Solver = (function() {
    function Solver(env, failcont, state) {
      this.env = env;
      this.failcont = failcont;
      this.state = state;
    }

    Solver.prototype.clone = function(update) {
      if (update == null) {
        update = {};
      }
      return new dao.Solver(update.env || this.env.clone(), update.failcont || this.failcont, update.state || this.state);
    };

    Solver.prototype.cont = function(exp, cont) {
      return exp.cont(this, cont || done);
    };

    Solver.prototype.solve = function(exp, cont) {
      cont = this.cont(exp, cont || done);
      return cont(dao.NULL, this);
    };

    return Solver;

  })();

  dao.Element = (function() {
    function Element() {}

    return Element;

  })();

  dao.Var = (function(_super) {
    __extends(Var, _super);

    function Var(name) {
      this.name = name;
    }

    return Var;

  })(dao.Element);

  dao.Atom = (function(_super) {
    __extends(Atom, _super);

    function Atom(item) {
      this.item = item;
    }

    return Atom;

  })(dao.Element);

  dao.Number = (function(_super) {
    __extends(Number, _super);

    function Number() {
      _ref = Number.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Number;

  })(dao.Atom);

  dao.Print = (function(_super) {
    __extends(Print, _super);

    function Print() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.args = args;
    }

    return Print;

  })(dao.Element);

  dao.Succeed = (function(_super) {
    __extends(Succeed, _super);

    function Succeed() {
      _ref1 = Succeed.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Succeed;

  })(dao.Element);

  dao.Fail = (function(_super) {
    __extends(Fail, _super);

    function Fail() {
      _ref2 = Fail.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return Fail;

  })(dao.Element);

  dao.And = (function(_super) {
    __extends(And, _super);

    function And(x, y) {
      this.x = x;
      this.y = y;
    }

    return And;

  })(dao.Element);

  dao.Or = (function(_super) {
    __extends(Or, _super);

    function Or(x, y) {
      this.x = x;
      this.y = y;
    }

    return Or;

  })(dao.Element);

  dao.Not = (function(_super) {
    __extends(Not, _super);

    function Not(x) {
      this.x = x;
    }

    return Not;

  })(dao.Element);

  dao.Unify = (function(_super) {
    __extends(Unify, _super);

    function Unify(x, y) {
      this.x = x;
      this.y = y;
    }

    return Unify;

  })(dao.Element);

  dao.Parse = (function(_super) {
    __extends(Parse, _super);

    function Parse(exp, data) {
      this.exp = exp;
      this.data = data;
    }

    return Parse;

  })(dao.Element);

  dao.Char = (function(_super) {
    __extends(Char, _super);

    function Char(x) {
      this.x = x;
    }

    return Char;

  })(dao.Element);

  dao.vari = function(name) {
    return new dao.Var(name);
  };

  dao.atom = function(x) {
    return new dao.Atom(x);
  };

  dao.number = function(x) {
    return new dao.Number(x);
  };

  dao.print_ = function() {
    var x;

    x = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(dao.Print, x, function(){});
  };

  dao.succeed = new dao.Succeed();

  dao.fail = new dao.Fail();

  dao.and_ = function(x, y) {
    return new dao.And(x, y);
  };

  dao.or_ = function(x, y) {
    return new dao.Or(x, y);
  };

  dao.not_ = function(x, y) {
    return new dao.Not(x);
  };

  dao.unify = function(x, y) {
    return new dao.Unify(x, y);
  };

  dao.parse = function(exp, data) {
    return new dao.Parse(exp, data);
  };

  dao.char = function(x) {
    return new dao.Char(x);
  };

  dao.Var.prototype.toString = "dao.vari(" + this.name + ")";

  dao.Atom.prototype.toString = "dao.atom(" + this.item + ")";

  dao.Number.prototype.toString = "dao.number(" + this.item + ")";

  dao.Succeed.prototype.toString = "dao.succeed";

  dao.Number.prototype.toString = "dao.fail";

  dao.TRUE = dao.atom(true);

  dao.FALSE = dao.atom(false);

  dao.NULL = dao.atom(null);

  dao.And.prototype.toString = "dao.and_(" + this.x + ", " + this.y + ")";

  dao.Or.prototype.toString = "dao.or_(" + this.x + ", " + this.y + ")";

  dao.Not.prototype.toString = "dao.not_(" + this.x + ")";

  dao.Unify.prototype.toString = "dao.unify_(" + this.x + ", " + this.y + ")";

  dao.Parse.prototype.toString = "dao.parse(" + this.exp + ", " + this.data + ")";

  dao.Char.prototype.toString = "dao.char(" + this.x + ")";

  dao.Element.prototype.deref = function(env) {
    return this;
  };

  dao.Var.prototype.deref = function(env) {
    return env.get(this);
  };

  dao.Element.prototype.getvalue = function(env) {
    return this;
  };

  dao.Var.prototype.getvalue = function(env) {
    return this.deref(env);
  };

  dao.Var.prototype.cont = function(solver, cont) {
    var _this = this;

    return function(v, solver) {
      return cont(_this.deref(solver.env), solver);
    };
  };

  dao.Atom.prototype.cont = function(solver, cont) {
    var _this = this;

    return function(v, solver) {
      return cont(_this, solver);
    };
  };

  dao.Print.prototype.cont = function(solver, cont) {
    var _this = this;

    return function(v, solver) {
      console.log.apply(console, _this.args);
      return cont(dao.NULL, solver);
    };
  };

  dao.Succeed.prototype.cont = function(solver, cont) {
    return function(v, solver) {
      return cont(dao.FALSE, solver);
    };
  };

  dao.Fail.prototype.cont = function(solver, cont) {
    return function(v, solver) {
      return solver.failcont(dao.FALSE, solver);
    };
  };

  dao.And.prototype.cont = function(solver, cont) {
    return this.x.cont(solver, this.y.cont(solver, cont));
  };

  dao.Or.prototype.cont = function(solver, cont) {
    var fc, saved_solver,
      _this = this;

    fc = solver.failcont;
    saved_solver = solver.clone();
    solver.failcont = function(v, solver) {
      return _this.y.cont(solver, cont)(v, saved_solver);
    };
    return this.x.cont(solver, (function(v, solver) {
      solver.failcont = fc;
      return cont(v, solver);
    }));
  };

  dao.Not.prototype.cont = function(solver, cont) {
    var fc, saved_solver;

    fc = solver.failcont;
    saved_solver = solver.clone();
    solver.failcont = cont;
    return this.x.cont(solver, function(v, solver) {
      return fc(v, saved_solver);
    });
  };

  dao.Unify.prototype.cont = function(solver, cont) {
    var _this = this;

    return function(v, solver) {
      var x, y;

      x = deref(_this.x, solver.env);
      y = deref(_this.y, solver.env);
      if (x instanceof dao.Var) {
        solver.env.set(x, y);
        return cont(dao.TRUE, solver);
      } else if (y instanceof dao.Var) {
        solver.env.set(y, x);
        return cont(dao.TRUE, solver);
      } else if (x === y) {
        return cont(dao.TRUE, solver);
      } else {
        return solver.failcont(dao.FALSE, solver);
      }
    };
  };

  dao.Parse.prototype.cont = function(solver, cont) {
    var _this = this;

    return function(v, solver) {
      var state;

      state = solver.state;
      solver.state = [_this.data, 0];
      return _this.exp.cont(solver, (function(v, solver) {
        solver.state = state;
        return cont(v, solver);
      }))(dao.TRUE, solver);
    };
  };

  dao.Char.prototype.cont = function(solver, cont) {
    var _this = this;

    return function(v, solver) {
      var c, data, pos, x, _ref3;

      _ref3 = solver.state, data = _ref3[0], pos = _ref3[1];
      if (pos === data.length) {
        return solver.failcont(dao.FALSE, solver);
      }
      x = deref(_this.x, solver.env);
      c = data[pos];
      if (_.isString(x)) {
        if (x === c) {
          solver.state = [data, pos + 1];
          return cont(dao.TRUE, solver);
        } else {
          return solver.failcont(v, solver);
        }
      } else if (x instanceof dao.Var) {
        solver.env.set(x, c);
        return cont(dao.TRUE, solver);
      } else {
        throw new dao.TypeError(_this);
      }
    };
  };

}).call(this);

/*
//@ sourceMappingURL=evaldao.map
*/
