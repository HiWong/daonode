// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, Trail, TypeError, Var, _ref;

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  exports.binaryOperator = function(solver, cont) {
    var c, c1, length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        solver.state = [text, pos + 1];
        return cont('vop_add');
      case '-':
        solver.state = [text, pos + 1];
        return cont('vop_sub');
      case '*':
        solver.state = [text, pos + 1];
        return cont('vop_mul');
      case '/':
        solver.state = [text, pos + 1];
        return cont('vop_div');
      case '%':
        solver.state = [text, pos + 1];
        return cont('vop_mod');
      case '=':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_eq');
        } else {
          return solver.failcont(pos);
        }
        break;
      case '!':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_ne');
        } else {
          return solver.failcont(pos);
        }
        break;
      case '>':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_ge');
        } else if (c1 === '>') {
          solver.state = [text, pos + 2];
          return cont('vop_rshift');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_gt');
        }
        break;
      case '<':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.state = [text, pos + 2];
          return cont('vop_le');
        } else if (c1 === '<') {
          solver.state = [text, pos + 2];
          return cont('vop_lshift');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_lt');
        }
    }
  };

  exports.unaryOperator = function(solver, cont) {
    var c, c1, length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_inc');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_pos');
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_dec');
        } else {
          solver.state = [text, pos + 1];
          return cont('vop_neg');
        }
        break;
      case '!':
        solver.state = [text, pos + 1];
        return cont('vop_not');
      case '~':
        solver.state = [text, pos + 1];
        return cont('vop_bitnot');
      default:
        return solver.failcont(pos);
    }
  };

  exports.suffixOperator = function(solver, cont) {
    var c, c1, length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_inc');
        } else {
          return solver.failcont(pos);
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.state = [text, pos + 2];
          return cont('vop_dec');
        } else {
          return solver.failcont(pos);
        }
        break;
      default:
        return solver.failcont(pos);
    }
  };

  exports.program = function(solver, cont) {
    var length, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return cont(null);
    } else {
      return programBody(solver, cont);
    }
  };

  exports.programBody = function(solver, cont) {
    var exps, pos, stmt, text, _ref1;

    exps = [];
    while (1) {
      stmt = statement(solver, cont);
      if (stmt[0] === sexpression.COMMENT) {
        continue;
      }
      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      if (pos === text.length) {
        break;
      }
    }
    if (exps.length === 0) {
      return null;
    } else {
      exps.unshift(sexpression.BEGIN);
      return exps;
    }
  };

  exports.statement = function(solver, cont) {
    var token;

    solver.token = token = readStartToken(solver, cont);
    switch (token) {
      case RETURN:
        return returnStatement(solver, cont);
      case PASS:
        return passStatement(solver, cont);
      case BLOCKCOMMENT:
        return blockComment(solver, cont);
      case LINECOMMENT:
        return lineComment(solver, cont);
      default:
        return expression(solver, cont);
    }
  };

}).call(this);

/*
//@ sourceMappingURL=daoutil.map
*/
