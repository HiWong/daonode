// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, core, debug, general, if_fun, iff_fun, il, macro, not_, special, _,
    __slice = [].slice;

  _ = require('underscore');

  core = require("../core");

  il = require("../interlang");

  general = require("./general");

  special = core.special;

  macro = core.macro;

  debug = core.debug;

  exports.quote = special(1, 'quote', function(compiler, cont, exp) {
    var v;

    v = compiler.vari('v');
    return il.clamda(v, il["return"](il.array(cont, exp)));
  });

  exports.eval_ = special(1, 'eval', function(compiler, cont, exp) {
    return compiler.cont(exp, function(v) {
      return [compiler.cont(v, cont), null];
    });
  });

  exports.assign = special(2, 'assign', function(compiler, cont, vari, exp) {
    return compiler.cont(exp, function(v) {
      if (v instanceof core.Var) {
        new core.TypeError(v, "do NOT assign free logic var to var");
      }
      vari.binding = v;
      return cont(v);
    });
  });

  exports.zero = special(1, 'zero', function(compiler, cont, vari, exp) {
    return function(v) {
      vari.binding = 0;
      return cont(v);
    };
  });

  exports.one = special(1, 'one', function(compiler, cont, vari, exp) {
    return function(v) {
      vari.binding = 1;
      return cont(v);
    };
  });

  exports.begin = special(null, 'begin', function() {
    var compiler, cont, exps;

    compiler = arguments[0], cont = arguments[1], exps = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return compiler.expsCont(exps, cont);
  });

  if_fun = function(compiler, cont, test, then_, else_) {
    var action, else_cont, then_cont;

    then_cont = compiler.cont(then_, cont);
    if (else_ != null) {
      else_cont = compiler.cont(else_, cont);
      action = function(v) {
        if (v) {
          return then_cont(v);
        } else {
          return else_cont(v);
        }
      };
      return compiler.cont(test, action);
    } else {
      action = function(v) {
        if (v) {
          return then_cont(null);
        } else {
          return cont(null);
        }
      };
      return compiler.cont(test, action);
    }
  };

  exports.if_ = special([2, 3], 'if_', if_fun);

  iff_fun = function(compiler, cont, clauses, else_) {
    var action, iff_else_cont, length, test, then_, then_cont, _ref, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new exports.TypeError(clauses);
    } else if (length === 1) {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      return if_fun(compiler, cont, test, then_, else_);
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      then_cont = compiler.cont(then_, cont);
      iff_else_cont = iff_fun(compiler, cont, clauses.slice(1), else_);
      action = function(v) {
        if (v) {
          return [then_cont, v];
        } else {
          return [iff_else_cont, v];
        }
      };
      return compiler.cont(test, action);
    }
  };

  exports.iff = special(-2, 'iff', iff_fun);

  exports.block = block = special(null, 'block', function() {
    var body, compiler, cont, continues, defaultContinues, defaultExits, exits, fun, holder, label, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

    compiler = arguments[0], cont = arguments[1], label = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    exits = (_ref = (_base = compiler.exits)[label]) != null ? _ref : _base[label] = [];
    exits.push(cont);
    defaultExits = (_ref1 = (_base1 = compiler.exits)['']) != null ? _ref1 : _base1[''] = [];
    defaultExits.push(cont);
    holder = [null];
    continues = (_ref2 = (_base2 = compiler.continues)[label]) != null ? _ref2 : _base2[label] = [];
    continues.push(holder);
    defaultContinues = (_ref3 = (_base3 = compiler.continues)['']) != null ? _ref3 : _base3[''] = [];
    defaultContinues.push(holder);
    holder[0] = fun = compiler.expsCont(body, cont);
    exits.pop();
    if (exits.length === 0) {
      delete compiler.exits[label];
    }
    continues.pop();
    if (continues.length === 0) {
      delete compiler.continues[label];
    }
    defaultExits.pop();
    defaultContinues.pop();
    return fun;
  });

  exports.break_ = break_ = special([0, 1, 2], 'break_', function(compiler, cont, label, value) {
    var exitCont, exits, valCont;

    if (label == null) {
      label = '';
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !_.isString(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !_.isString(label)) {
      value = label;
      label = '';
    }
    exits = compiler.exits[label];
    if (!exits || exits === []) {
      throw Error(label);
    }
    exitCont = exits[exits.length - 1];
    valCont = function(v) {
      return compiler.protect(exitCont)(v);
    };
    return compiler.cont(value, valCont);
  });

  exports.continue_ = continue_ = special([0, 1], 'continue_', function(compiler, cont, label) {
    var continueCont, continues;

    if (label == null) {
      label = '';
    }
    continues = compiler.continues[label];
    if (!continues || continues === []) {
      throw Error(label);
    }
    continueCont = continues[continues.length - 1];
    return function(v) {
      return [compiler.protect(continueCont[0]), v];
    };
  });

  not_ = general.not_;

  exports.loop_ = macro(null, 'loop', function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  });

  exports.while_ = macro(null, 'while_', function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  });

  exports.until_ = macro(null, 'until_', function() {
    var body, label, test, _i;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), test = arguments[_i++];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  });

  exports.catch_ = special(-1, 'catch_', function() {
    var compiler, cont, forms, tag, tagCont;

    compiler = arguments[0], cont = arguments[1], tag = arguments[2], forms = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    tagCont = function(v) {
      var formsCont;

      compiler.pushCatch(v, cont);
      formsCont = compiler.expsCont(forms, function(v2) {
        compiler.popCatch(v);
        return [cont, v2];
      });
      return [formsCont, v];
    };
    return compiler.cont(tag, tagCont);
  });

  exports.throw_ = special(2, 'throw_', function(compiler, cont, tag, form) {
    var formCont;

    formCont = function(v) {
      return compiler.cont(form, function(v2) {
        return compiler.protect(compiler.findCatch(v))(v2);
      })(v);
    };
    return compiler.cont(tag, formCont);
  });

  exports.protect = special(-1, 'protect', function() {
    var cleanup, cleanupCont, compiler, cont, form, oldprotect, result;

    compiler = arguments[0], cont = arguments[1], form = arguments[2], cleanup = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    oldprotect = compiler.protect;
    compiler.protect = function(fun) {
      return function(v1) {
        return compiler.expsCont(cleanup, function(v2) {
          compiler.protect = oldprotect;
          return oldprotect(fun)(v1);
        })(v1);
      };
    };
    cleanupCont = function(v1) {
      return compiler.expsCont(cleanup, function(v2) {
        compiler.protect = oldprotect;
        return cont(v1);
      })(v1);
    };
    result = compiler.cont(form, cleanupCont);
    return result;
  });

  exports.callcc = special(1, 'callcc', function(compiler, cont, fun) {
    return function(v) {
      var cc, faked;

      faked = compiler.fake();
      cc = function(v) {
        var result;

        compiler.restore(faked);
        result = compiler.run(v, cont);
        return compiler.trail.getvalue(result[1]);
      };
      return cont(fun(cc));
    };
  });

  exports.callfc = special(1, 'callfc', function(compiler, cont, fun) {
    return function(v) {
      var faked, fc;

      faked = compiler.fake();
      fc = function(v) {
        var result;

        compiler.restore(faked);
        result = compiler.run(v, compiler.failcont);
        return compiler.trail.getvalue(result[1]);
      };
      return cont(fun(fc));
    };
  });

  exports.callcs = special(1, 'callcs', function(compiler, cont, fun) {
    return function(v) {
      return cont(fun(compiler, compiler.fake(), cont));
    };
  });

  exports.quasiquote = exports.qq = special(1, 'quasiquote', function(compiler, cont, item) {
    return typeof compiler.quasiquote === "function" ? compiler.quasiquote(item, cont) : void 0;
  });

  exports.unquote = exports.uq = special(1, 'unquote', function(compiler, cont, item) {
    throw "unquote: too many unquote and unquoteSlice";
  });

  exports.unquoteSlice = exports.uqs = special(1, 'unquoteSlice', function(compiler, cont, item) {
    throw "unquoteSlice: too many unquote and unquoteSlice";
  });

}).call(this);

/*
//@ sourceMappingURL=lisp.map
*/
