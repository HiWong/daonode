// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, Trail, TypeError, Var, any2, defaultHash, defaultPureHash, greedyany2, greedysome1, greedysome2, lazyany2, lazysome1, lazysome2, numberTimes1Fun, numberTimes2Fun, parallelFun, some1, some2, special, times1, times1Fun, times2, times2Fun, _, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  special = require("../core").special;

  defaultPureHash = function() {
    var args, caller, name;

    name = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return (name || caller.name) + args.join(',');
  };

  exports.purememo = function(caller, name, hash) {
    if (name == null) {
      name = '';
    }
    if (hash == null) {
      hash = defaultPureHash;
    }
    if (!_.isString(name)) {
      hash = name;
      name = '';
    }
    return special(null, 'purememo', function() {
      var args, cont, fromCont, hashValue, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      hashValue = hash.apply(null, [name, caller].concat(__slice.call(args)));
      if (hashValue === void 0) {
        return solver.cont(caller.apply(null, args), cont);
      } else {
        fromCont = solver.cont(caller.apply(null, args), function(v) {
          solver.finished = true;
          return [cont, v];
        });
        return function(v) {
          var newCont, result, _ref1;

          if (solver.purememo.hasOwnProperty(hashValue)) {
            return cont(solver.purememo[hashValue]);
          } else {
            result = (_ref1 = solver.run(null, fromCont), newCont = _ref1[0], v = _ref1[1], _ref1);
            solver.finished = false;
            solver.purememo[hashValue] = v;
            return result;
          }
        };
      }
    });
  };

  exports.clearPureMemo = special(0, 'clearPureMemo', function(solver, cont) {
    return function(v) {
      solver._memoPureResult = {};
      return cont(v);
    };
  })();

  defaultHash = function() {
    var args, caller, name, solver;

    name = arguments[0], solver = arguments[1], caller = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return (name || caller.name) + solver.state[1];
  };

  exports.memo = function(caller, name, hash) {
    if (name == null) {
      name = '';
    }
    if (hash == null) {
      hash = defaultHash;
    }
    if (!_.isString(name)) {
      hash = name;
      name = '';
    }
    return special(null, name, function() {
      var args, cont, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return function(v) {
        var fromCont, hashValue, newCont, result, _ref1, _ref2;

        hashValue = hash.apply(null, [name, solver, caller].concat(__slice.call(args)));
        if (hashValue === void 0) {
          return solver.cont(caller.apply(null, args), cont);
        } else {
          fromCont = solver.cont(caller.apply(null, args), function(v) {
            solver.finished = true;
            return [cont, v];
          });
          if (solver.memo.hasOwnProperty(hashValue)) {
            _ref1 = solver.memo[hashValue], result = _ref1[0], solver.state[1] = _ref1[1];
            return cont(result);
          } else {
            result = (_ref2 = solver.run(null, fromCont), newCont = _ref2[0], v = _ref2[1], _ref2);
            solver.finished = false;
            solver.memo[hashValue] = [v, solver.state[1]];
            return result;
          }
        }
      };
    });
  };

  exports.clearmemo = special(0, 'clearmemo', function(solver, cont) {
    return function(v) {
      solver.memo = {};
      return cont(v);
    };
  })();

  parallelFun = function(solver, cont, state, args) {
    var leftCont, length;

    length = args.length;
    if (length === 0) {
      return cont;
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else {
      leftCont = parallelFun(solver, cont, state, args.slice(1));
      return solver.cont(args[0], function(v) {
        solver.state = state;
        return leftCont(v);
      });
    }
  };

  exports.parallel = special(null, 'parallel', function(solver, cont, args, checkFunction) {
    var adjustCont, length, right, x, xcont, y, ycont;

    if (checkFunction == null) {
      checkFunction = function(state, baseState) {
        return state[1] === baseState[1];
      };
    }
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else {
      right = null;
      if (length === 2) {
        x = args[0];
        y = [args[1]];
      } else {
        x = args[0];
        y = args.slice(1);
      }
      adjustCont = function(v) {
        if (checkParallel(solver.state, right)) {
          return cont(v);
        } else {
          return solver.failcont(v);
        }
      };
      ycont = parallelFun(solver, adjustCont, state, y);
      xcont = solver.cont(x, function(v) {
        right = solver.state;
        solver.state = state;
        return ycont(v);
      });
      return xcont;
    }
  });

  exports.any = function(exp, result, template) {
    if (!result) {
      return any1(exp);
    } else {
      return any2(exp, result, template);
    }
  };

  any2 = special(3, 'any', function(solver, cont, exp, result, template) {
    var anyCont, expCont, result1;

    result1 = null;
    anyCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new core.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = function(v) {
          result1.pop();
          return fc(v);
        };
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return anyCont(v);
    });
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      return anyCont(v);
    };
  });

  exports.lazyany = function(exp, result, template) {
    if (!result) {
      return lazyany1(exp);
    } else {
      return lazyany2(exp, result, template);
    }
  };

  lazyany2 = special(3, 'lazyany', function(solver, cont, exp, result, template) {
    var anyCont, anyFcont, expcont, fc, result1;

    result1 = fc = null;
    anyCont = function(v) {
      solver.failcont = anyFcont;
      result.bind(result1, solver.trail);
      return cont(v);
    };
    expcont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return anyCont(v);
    });
    anyFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    return function(v) {
      result1 = [];
      fc = solver.failcont;
      return anyCont(v);
    };
  });

  exports.greedyany = function(exp, result, template) {
    if (!result) {
      return greedyany1(exp);
    } else {
      return greedyany2(exp, result, template);
    }
  };

  greedyany2 = special(3, 'greedyany', function(solver, cont, exp, result, template) {
    var anyCont, expCont, result1;

    result1 = null;
    anyCont = function(v) {
      return [expCont, v];
    };
    expCont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return anyCont(v);
    });
    return function(v) {
      var fc;

      result1 = [];
      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        result.bind(result1, solver.trail);
        return cont(v);
      };
      return anyCont(v);
    };
  });

  exports.some = function(exp, result, template) {
    if (!result) {
      return some1(exp);
    } else {
      return some2(exp, result, template);
    }
  };

  some1 = special(1, 'some', function(solver, cont, exp) {
    var expCont, someCont;

    someCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new core.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, someCont);
    return expCont;
  });

  some2 = special(3, 'some', function(solver, cont, exp, result, template) {
    var expCont, result1, someCont;

    result1 = null;
    someCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new core.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = function(v) {
          result1.pop();
          return fc(v);
        };
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return someCont(v);
    });
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      return expCont(v);
    };
  });

  exports.lazysome = function(exp, result, template) {
    if (!result) {
      return lazysome1(exp);
    } else {
      return lazysome2(exp, result, template);
    }
  };

  lazysome1 = special(1, 'lazysome', function(solver, cont, exp) {
    var expcont, fc, someCont, someFcont;

    fc = null;
    someFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    someCont = function(v) {
      solver.failcont = someFcont;
      return cont(v);
    };
    expcont = solver.cont(exp, someCont);
    return function(v) {
      fc = solver.failcont;
      return expcont(v);
    };
  });

  lazysome2 = special(3, 'lazysome', function(solver, cont, exp, result, template) {
    var expcont, fc, result1, someCont, someFcont;

    result1 = fc = null;
    someFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    someCont = function(v) {
      result1.push(solver.trail.getvalue(template));
      solver.failcont = someFcont;
      return cont(v);
    };
    expcont = solver.cont(exp, someCont);
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      fc = solver.failcont;
      return expcont(v);
    };
  });

  exports.greedysome = function(exp, result, template) {
    if (!result) {
      return greedysome1(exp);
    } else {
      return greedysome2(exp, result, template);
    }
  };

  greedysome1 = special(1, 'greedysome', function(solver, cont, exp) {
    var expCont, someCont;

    someCont = function(v) {
      return [expCont, v];
    };
    expCont = solver.cont(exp, someCont);
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return expCont(v);
    };
  });

  greedysome2 = special(3, 'greedysome', function(solver, cont, exp, result, template) {
    var expCont, result1, someCont;

    result1 = null;
    someCont = function(v) {
      result1.push(solver.trail.getvalue(template));
      return [expCont, v];
    };
    expCont = solver.cont(exp, someCont);
    return function(v) {
      var fc;

      result1 = [];
      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        result.bind(result1, solver.trail);
        return cont(v);
      };
      return expCont(v);
    };
  });

  exports.times = function(exp, expectTimes, result, template) {
    if (!result) {
      return times1(exp, expectTimes);
    } else {
      return times2(exp, expectTimes, result, template);
    }
  };

  numberTimes1Fun = function(solver, cont, exp, expectTimes) {
    var expCont, i;

    expectTimes = Math.floor(expectTimes);
    if (expectTimes < 0) {
      throw new ValueError(expectTimes);
    } else if (expectTimes === 0) {
      return cont;
    } else if (expectTimes === 1) {
      return solver.cont(exp, cont);
    } else if (expectTimes === 2) {
      expCont = solver.cont(exp, cont);
      return solver.cont(exp, expCont);
    } else {
      i = null;
      expCont = solver.cont(exp, function(v) {
        i++;
        if (i === expectTimes) {
          return cont(v);
        } else {
          return expCont(v);
        }
      });
      return function(v) {
        i = 0;
        return expCont(v);
      };
    }
  };

  times1Fun = function(solver, cont, exp, expectTimes) {
    var anyCont, expCont, expectTimes1, i;

    if (_.isNumber(expectTimes)) {
      return numberTimes1Fun(solver, cont, exp, expectTimes);
    } else {
      expectTimes1 = i = null;
      anyCont = function(v) {
        var fc, state, trail;

        fc = solver.failcont;
        trail = solver.trail;
        solver.trail = new core.Trail;
        state = solver.state;
        solver.failcont = function(v) {
          solver.trail.undo();
          solver.trail = trail;
          solver.state = state;
          solver.failcont = function(v) {
            i--;
            return fc(v);
          };
          expectTimes1.bind(i, solver.trail);
          return cont(v);
        };
        return [expCont, v];
      };
      expCont = solver.cont(exp, function(v) {
        i++;
        return anyCont(v);
      });
      return solver.cont(expectTimes, function(v) {
        expectTimes1 = v;
        if (_.isNumber(expectTimes1)) {
          return numberTimes1Fun(solver, cont, exp, expectTimes1)(v);
        } else {
          i = 0;
          return anyCont(v);
        }
      });
    }
  };

  times1 = special(2, 'times', times1Fun);

  numberTimes2Fun = function(solver, cont, exp, expectTimes, result, template) {
    var expCont, i, result1;

    expectTimes = Math.floor(expectTimes);
    if (expectTimes < 0) {
      throw new ValueError(expectTimes);
    } else if (expectTimes === 0) {
      return function(v) {
        result.bind([], solver.trail);
        return cont(v);
      };
    } else if (expectTimes === 1) {
      return solver.cont(exp, function(v) {
        result.bind([solver.trail.getvalue(template)], solver.trail);
        return cont(v);
      });
    } else if (expectTimes === 2) {
      result1 = [];
      expCont = solver.cont(exp, function(v) {
        result1.push(solver.trail.getvalue(template));
        result.bind(result1, solver.trail);
        return cont(v);
      });
      return solver.cont(exp, function(v) {
        result1.push(solver.trail.getvalue(template));
        return expCont(v);
      });
    } else {
      result1 = i = null;
      expCont = solver.cont(exp, function(v) {
        i++;
        result1.push(solver.trail.getvalue(template));
        if (i === expectTimes) {
          result.bind(result1, solver.trail);
          return cont(v);
        } else {
          return expCont(v);
        }
      });
      return function(v) {
        i = 0;
        result1 = [];
        return expCont(v);
      };
    }
  };

  times2Fun = function(solver, cont, exp, expectTimes, result, template) {
    var anyCont, expCont, expectTimes1, i, result1;

    if (_.isNumber(expectTimes)) {
      return numberTimes2Fun(solver, cont, exp, expectTimes, result, template);
    } else {
      result1 = expectTimes1 = i = null;
      anyCont = function(v) {
        var fc, state, trail;

        fc = solver.failcont;
        trail = solver.trail;
        solver.trail = new core.Trail;
        state = solver.state;
        solver.failcont = function(v) {
          solver.trail.undo();
          solver.trail = trail;
          solver.state = state;
          solver.failcont = function(v) {
            i--;
            result1.pop();
            return fc(v);
          };
          expectTimes1.bind(i, solver.trail);
          return cont(v);
        };
        return [expCont, v];
      };
      expCont = solver.cont(exp, function(v) {
        i++;
        result1.push(solver.trail.getvalue(template));
        return anyCont(v);
      });
      return solver.cont(expectTimes, function(v) {
        expectTimes1 = v;
        if (_.isNumber(expectTimes1)) {
          return numberTimes2Fun(solver, cont, exp, expectTimes1, result, template)(v);
        } else {
          i = 0;
          result1 = [];
          result.bind(result1, solver.trail);
          return anyCont(v);
        }
      });
    }
  };

  times2 = special(4, 'times', times2Fun);

  exports.seplist = function(exp, options) {
    var andp, bind, expectTimes, freep, getvalue, i, ifp, inc, is_, list, n, one, prependFailcont, push, pushp, result, sep, sub, succeed, template, vari;

    if (options == null) {
      options = {};
    }
    sep = options.sep || char(' ');
    expectTimes = options.times || null;
    result = options.result || null;
    template = options.template || null;
    vari = core.vari;
    succeed = logic.succeed;
    andp = logic.andp;
    bind = logic.bind;
    is_ = logic.is_;
    freep = logic.freep;
    ifp = logic.ifp;
    prependFailcont = logic.prependFailcont;
    list = general.list;
    push = general.push;
    pushp = general.pushp;
    one = lisp.one;
    inc = general.inc;
    sub = general.sub;
    getvalue = general.getvalue;
    if (expectTimes === null) {
      if (result === null) {
        return andp(exp, any(andp(sep, exp)));
      } else {
        return andp(bind(result, []), exp, pushp(result, getvalue(template)), any(andp(sep, exp, pushp(result, getvalue(template)))));
      }
    } else if (_.isNumber(expectTimes)) {
      expectTimes = Math.floor(Math.max(0, expectTimes));
      if (result === null) {
        switch (expectTimes) {
          case 0:
            return succeed;
          case 1:
            return exp;
          default:
            return andp(exp, times(andp(sep, exp), expectTimes - 1));
        }
      } else {
        switch (expectTimes) {
          case 0:
            return bind(result, []);
          case 1:
            return andp(exp, bind(result, list(getvalue(template))));
          default:
            return andp(bind(result, []), exp, pushp(result, getvalue(template)), times(andp(sep, exp, pushp(result, getvalue(template))), expectTimes - 1));
        }
      }
    } else {
      n = vari('n');
      i = vari('i');
      if (result === null) {
        return ifp(freep(expectTimes), andp(exp, one(i), any(andp(sep, exp, inc(i))), bind(expectTimes, i)), andp(exp, is_(n, sub(expectTimes, 1)), times(andp(sep, exp), n)));
      } else {
        return andp(bind(result, []), ifp(freep(expectTimes), andp(exp, one(i), push(result, getvalue(template)), any(andp(sep, exp, push(result, getvalue(template)), inc(i), prependFailcont(function() {
          result.binding.pop();
          return i.binding--;
        }))), bind(expectTimes, i)), andp(exp, pushp(result, getvalue(template)), is_(n, sub(expectTimes, 1)), times(andp(sep, exp, pushp(result, getvalue(template))), n))));
      }
    }
  };

  exports.char = function(solver, x) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      x.bind(c, solver.trail);
      solver.state = [data, pos + 1];
      return pos + 1;
    } else if (x === c) {
      solver.state = [data, pos + 1];
      return pos + 1;
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return solver.failcont(pos);
      } else {
        throw new ExpressionError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.followChar = function(solver, x) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      throw new TypeError(x);
    } else if (x === c) {
      return pos;
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return solver.failcont(pos);
      } else {
        throw new ValueError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.notFollowChar = function(solver, x) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      throw new TypeError(x);
    } else if (x === c) {
      return solver.failcont(pos);
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return pos;
      } else {
        throw new ValueError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.followChars = function(solver, chars) {
    var c, data, pos, trail, _ref1;

    chars = trail.deref(chars);
    if (chars instanceof Var) {
      throw new TypeError(chars);
    }
    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    c = data[pos];
    if (__indexOf.call(chars, c) >= 0) {
      return pos;
    } else if (!_.isString(chars)) {
      throw new TypeError(chars);
    } else {
      return solver.failcont(pos);
    }
  };

  exports.notFollowChars = function(solver, chars) {
    var c, data, pos, trail, _ref1;

    chars = trail.deref(chars);
    if (chars instanceof Var) {
      throw new TypeError(chars);
    }
    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    c = data[pos];
    if (__indexOf.call(chars, c) >= 0) {
      return solver.failcont(pos);
    } else if (!_.isString(chars)) {
      throw new TypeError(chars);
    } else {
      return cont(pos);
    }
  };

  exports.charWhen = function(solver, test) {
    var c, data, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (test(c)) {
      solver.state = [data, pos + 1];
      return pos;
    } else {
      return solver.failcont(pos);
    }
  };

  exports.spaces = function(solver) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (c !== ' ') {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && data[p] === ' ') {
      p++;
    }
    solver.state = [data, p];
    return p;
  };

  exports.spaces0 = function(solver) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos >= length) {
      return pos;
    }
    c = data[pos];
    if (c !== ' ') {
      return pos;
    }
    p = pos + 1;
    while (p < length && data[p] === ' ') {
      p++;
    }
    solver.state = [data, p];
    return pos;
  };

  exports.stringWhile = function(solver, test) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos === length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (!test(c)) {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && test(data[p])) {
      p++;
    }
    solver.state = [data, p];
    return data.slice(pos, p);
  };

  exports.stringWhile0 = function(solver, test) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos === length) {
      return '';
    }
    c = data[pos];
    if (!test(c)) {
      return '';
    }
    p = pos + 1;
    while (p < length && test(data[p])) {
      p++;
    }
    solver.state = [data, p];
    return data.slice(pos, p);
  };

  exports.number = exports.float = function(solver, arg) {
    var dot, length, p, pE, pos, text, value, _ref1, _ref2, _ref3, _ref4;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    p = pos;
    if (text[p] === '+' || text[p] === '-') {
      p++;
    }
    if (p >= length) {
      return solver.failcont(p);
    }
    dot = false;
    if (text[p] === '.') {
      dot = true;
      p++;
    }
    if (p >= length || text[p] < '0' || '9' < text[p]) {
      return solver.failcont(p);
    }
    p++;
    while (p < length && ('0' <= (_ref2 = text[p]) && _ref2 <= '9')) {
      p++;
    }
    if (!dot) {
      if (p < length && text[p] === '.') {
        p++;
      }
      while (p < length && ('0' <= (_ref3 = text[p]) && _ref3 <= '9')) {
        p++;
      }
    }
    if (p < length - 1 && text[p] === 'e' || text[p] === 'E') {
      p++;
      pE = p;
      if (p < length && (text[p] === '+' || text[p] === '-')) {
        p++;
      }
      if (p >= length || text[p] < '0' || '9' < text[p]) {
        p = pE - 1;
      } else {
        while (p < length && ('0' <= (_ref4 = text[p]) && _ref4 <= '9')) {
          p++;
        }
      }
    }
    arg = solver.trail.deref(arg);
    value = eval(text.slice(pos, p));
    if (arg instanceof Var) {
      arg.bind(value, solver.trail);
      solver.state = [text, p];
      return p;
    } else {
      if (_.isNumber(arg)) {
        if (arg === value) {
          solver.state = [text, p];
          return p;
        } else {
          return solver.failcont(pos);
        }
      } else {
        throw new TypeError(arg);
      }
    }
  };

  exports.literal = function(solver, arg) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      solver.state = [text, p];
      return p;
    } else {
      return solver.failcont(p);
    }
  };

  exports.followLiteral = function(solver, arg) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      return p;
    } else {
      return solver.failcont(p);
    }
  };

  exports.notFollowLiteral = function(solver, arg) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      return solver.failcont(p);
    } else {
      return p;
    }
  };

  exports.quoteString = function(solver, quote) {
    var char, length, p, pos, string, text, _ref1;

    string = '';
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    quote = solver.trail.deref(quote);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    if (text[pos] !== quote) {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length) {
      char = text[p];
      p++;
      if (char === '\\') {
        p++;
      } else if (char === quote) {
        string = text.slice(pos + 1, p);
        break;
      }
    }
    if (p === length) {
      return solver.failcont(p);
    }
    solver.state = [text, p];
    return string;
  };

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
