// Generated by CoffeeScript 1.6.2
(function() {
  var ArgumentError, binaryPredicate, callfc, core, general, il, notunifyList, notunifyListFun, runner, unaryPredicate, unifyList, unifyListFun, _,
    __slice = [].slice;

  _ = require('underscore');

  ArgumentError = (core = require("../core")).ArgumentError;

  il = require("../interlang");

  general = require("./general");

  exports.prependFailcont = special(1, 'setFailcont', function(compiler, cont, fun) {
    return function(v) {
      var fc;

      fc = compiler.failcont;
      compiler.failcont = function(v) {
        fun();
        return fc(v);
      };
      return cont(v);
    };
  });

  exports.unifyListFun = unifyListFun = function(compiler, cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        compiler.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (!compiler.trail.unify(xs[i], ys[i])) {
            return compiler.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.unifyList = unifyList = special(2, 'unifyList', unifyListFun);

  exports.notunifyListFun = notunifyListFun = function(compiler, cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        compiler.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (compiler.trail.unify(xs[i], ys[i])) {
            return compiler.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.notunifyList = notunifyList = special(2, 'notunifyList', notunifyListFun);

  exports.rule = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname_rule';
    }
    return macro(arity, name, function() {
      var args, body, clauses, head, i, length, result;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clauses = fun.apply(null, args);
      length = clauses.length;
      if (length === 0) {
        return succeed;
      }
      result = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = length - 1; _i < _ref; i = _i += 2) {
          head = clauses[i];
          body = clauses[i + 1];
          _results.push(andp(unifyList(head, args), body));
        }
        return _results;
      })();
      if (length - Math.floor(length / 2) * 2 === 1) {
        result.push(clauses[length - 1]);
      }
      return orp.apply(null, result);
    });
  };

  runner = function(compiler, cont) {
    return function(v) {
      var _ref;

      while (!compiler.done) {
        _ref = cont(v), cont = _ref[0], v = _ref[1];
      }
      compiler.done = false;
      return v;
    };
  };

  callfc = require("./lisp").callfc;

  exports.callfc = callfc;

  exports.truep = special(1, 'truep', function(compiler, cont, fun, x) {
    return compiler.cont(x, function(x1) {
      if (x1) {
        return cont(x1);
      } else {
        return compiler.failcont(x1);
      }
    });
  });

  exports.falsep = special(1, 'falsep', function(compiler, cont, fun, x) {
    return compiler.cont(x, function(x1) {
      if (!x1) {
        return cont(x1);
      } else {
        return compiler.failcont(x1);
      }
    });
  });

  exports.unaryPredicate = unaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(1, name, function(compiler, cont, x) {
      return compiler.cont(x, function(x1) {
        var result;

        result = fun(x1);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      });
    });
  };

  exports.binaryPredicate = binaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(2, name, function(compiler, cont, x, y) {
      var x1, ycont;

      x1 = null;
      return ycont = compiler.cont(y, function(y1) {
        var result;

        result = fun(x1, y1);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      }, compiler.cont(x, function(v) {
        x1 = v;
        return ycont(null);
      }));
    });
  };

  exports.eqp = binaryPredicate(function(x, y) {
    return x === y;
  });

  exports.nep = binaryPredicate(function(x, y) {
    return x !== y;
  });

  exports.ltp = binaryPredicate(function(x, y) {
    return x < y;
  });

  exports.lep = binaryPredicate(function(x, y) {
    return x <= y;
  });

  exports.gtp = binaryPredicate(function(x, y) {
    return x > y;
  });

  exports.gep = binaryPredicate(function(x, y) {
    return x >= y;
  });

  exports.ternaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(3, name, function(compiler, cont, x, y, z) {
      var ycont, zcont;

      zcont = compiler.cont(z, function(z) {
        var result;

        result = fun(x, y, z);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      });
      return ycont = compiler.cont(y, function(v) {
        y = v;
        return zcont(null);
      }, compiler.cont(x, function(v) {
        x = v;
        return ycont(null);
      }));
    });
  };

  exports.functionPredicate = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(arity, name, function() {
      var args, compiler, cont;

      compiler = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return compiler.argsCont(args, function(params) {
        var result;

        result = fun.apply(null, params);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      });
    });
  };

  exports.between = special(3, 'between', function(compiler, cont, fun, x, y, z) {
    var y1, ycont, z1, zcont;

    y1 = z1 = null;
    zcont = compiler.cont(z, function(zz) {
      var fc, y11;

      if (x1 instanceof core.Var) {
        throw new core.TypeError(x);
      } else if (y1 instanceof core.Var) {
        throw new core.TypeError(y);
      }
      if (y1 instanceof core.Var) {
        y11 = y1;
        fc = compiler.failcont;
        compiler.failcont = function(v) {
          y11++;
          if (y11 > z1) {
            return fc(v);
          } else {
            y1.bind(y11, compiler.trail);
            return cont(y11);
          }
        };
        y1.bind(y11, compiler.trail);
        return cont(y11);
      } else {
        if ((x1 <= y1 && y1 <= z1)) {
          return cont(true);
        } else {
          return compiler.failcont(false);
        }
      }
    });
    ycont = compiler.cont(y, function(v) {
      y1 = v;
      return zcont(null);
    });
    return compiler.cont(x, function(v) {
      var x1;

      x1 = v;
      return ycont(null);
    });
  });

  exports.rangep = special(2, 'rangep', function(compiler, cont, x, y) {
    var x1, ycont;

    x1 = null;
    ycont = compiler.cont(y, function(y) {
      var fc, result;

      if (x1 instanceof core.Var) {
        throw new core.TypeError(x);
      } else if (y1 instanceof core.Var) {
        throw new core.TypeError(y);
      } else if (x1 > y1) {
        return compiler.failcont(false);
      }
      result = x1;
      fc = compiler.failcont;
      compiler.failcont = function(v) {
        result++;
        if (result > y1) {
          return fc(v);
        } else {
          return cont(result);
        }
      };
      return cont(result);
    });
    return compiler.cont(x, function(v) {
      x1 = v;
      return ycont(null);
    });
  });

  exports.varp = special(1, 'varp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {
      if (x1 instanceof core.Var) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    });
  });

  exports.nonvarp = special(1, 'notvarp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {
      if (!(x1 instanceof core.Var)) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    });
  });

  exports.freep = special(1, 'freep', function(compiler, cont, x) {
    return function(v) {
      if (compiler.trail.deref(x) instanceof Var) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    };
  });

  exports.numberp = special(1, 'numberp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isNumber(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.stringp = special(1, 'stringp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isString(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.atomp = special(1, 'atomp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isNumber(x1) || _.isString(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.listp = special(1, 'listp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isArray(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.callablep = special(1, 'callablep', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, x1 instanceof core.Apply ? cont(true) : compiler.failcont(false));
  });

}).call(this);

/*
//@ sourceMappingURL=logic.map
*/
