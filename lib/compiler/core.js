// Generated by CoffeeScript 1.6.2
(function() {
  var ArgumentError, ArityError, Compiler, Env, Error, TypeError, UnquoteSliceValue, Var, beautify, compile, fs, il, keywords, reElements, solve, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fs = require("fs");

  il = require("./interlang");

  solve = require('./solve');

  beautify = require('js-beautify').js_beautify;

  keywords = require('./keywords');

  exports.solve = function(exp) {
    var path;

    path = compile(exp);
    delete require.cache[require.resolve(path)];
    return require(path).main();
  };

  compile = function(exp) {
    var code, compiler, fd, path;

    compiler = new Compiler();
    code = compiler.compile(exp);
    code = beautify(code, {
      indent_size: 2
    });
    path = path || "f:/daonode/lib/compiler/test/compiled.js";
    fd = fs.openSync(path, 'w');
    fs.writeSync(fd, code);
    fs.closeSync(fd);
    return path;
  };

  exports.Compiler = Compiler = (function() {
    function Compiler() {
      this.nameToVarIndex = {};
    }

    Compiler.prototype.compile = function(exp) {
      var f, fromCont, v;

      v = vari('v');
      fromCont = this.cont(exp, il.clamda(v, v));
      f = il.clamda(v, fromCont);
      f = f.jsify(this);
      return "exports.main = " + (f.toCode(this));
    };

    Compiler.prototype.cont = function(exp, cont) {
      var args, body, fun, head, i, k, length, m, params, v, x, _i, _ref;

      length = exp.length;
      if (length === 0) {
        return cont.call(exp);
      } else {
        head = exp[0];
        if (head(typeof Number)) {
          switch (head) {
            case keywords.quote:
              return cont.call(exp[1]);
            case keywords.eval_:
              v = compiler.vari('v');
              return compiler.cont(exp[1], il.clamda(v, compiler.cont(v, cont)));
            case keywords.begin:
              return this.expsCont(exp.slice(1), cont);
            case keywords.assign:
              v = compiler.vari('v');
              return compiler.cont(exp[1], il.clamda(v, il.assign(exp[2].interlang(), v), cont.call(v)));
            case keywors.if_:
              v = this.vari('v');
              return compiler.cont(exp[1], il.clamda(v, il.if_(v, compiler.cont(exp[2], cont), compiler.cont(exp[3], cont))));
            case keywords.vari:
              return todo;
            case keywords.jsfun:
              return todo;
            case keywords.jsmacro:
              return todo;
            case keywords.lamda:
              params = exp[1];
              body = exp.slice(2);
              k = compiler.vari('k');
              return il.lamda([k].concat(params), compiler.cont(body, k));
            case keywords.macro:
              params = exp[1];
              body = exp.slice(2);
              k = compiler.vari('k');
              return il.lamda([k].concat(params), compiler.cont(body, k));
            case keywords.let_:
              return todo;
            case keywords.funcall:
              params = (function() {
                var _i, _len, _results;

                _results = [];
                for (_i = 0, _len = args.length; _i < _len; _i++) {
                  x = args[_i];
                  _results.push(compiler.vari('a'));
                }
                return _results;
              })();
              fun = exp[1];
              args = exp.slice(2);
              for (i = _i = _ref = length - 1; _i >= 0; i = _i += -1) {
                cont = (function(i, cont) {
                  return compiler.cont(args[i], il.clamda(params[i], cont));
                })(i, cont);
              }
              return cont;
            case keywords.macrocall:
              return m = exp[1];
            default:
              return cont.call(exp);
          }
        } else {
          return cont.call(exp);
        }
      }
    };

    Compiler.prototype.optimize = function(exp, env) {
      var expOptimize;

      expOptimize = exp != null ? exp.optimize : void 0;
      if (expOptimize) {
        return expOptimize.call(exp, env, this);
      } else {
        return exp;
      }
    };

    Compiler.prototype.toCode = function(exp) {
      var exptoCode;

      exptoCode = exp != null ? exp.toCode : void 0;
      if (exptoCode) {
        return exptoCode.call(exp, this);
      } else {
        if (exp === void 0) {
          return 'undefined';
        } else if (exp === null) {
          return 'null';
        } else if (_.isNumber(exp)) {
          return exp.toString();
        } else if (_.isString(exp)) {
          return JSON.stringify(exp);
        } else if (exp === true) {
          return "true";
        } else if (exp === false) {
          return "false";
        } else {
          throw new TypeError(exp);
        }
      }
    };

    Compiler.prototype.expsCont = function(exps, cont) {
      var length, v;

      length = exps.length;
      if (length === 0) {
        throw exports.TypeError(exps);
      } else if (length === 1) {
        return this.cont(exps[0], cont);
      } else {
        v = this.vari('v');
        return this.cont(exps[0], il.clamda(v, this.expsCont(exps.slice(1), cont)));
      }
    };

    Compiler.prototype.argsCont = function(args, cont) {
      var compiler, i, length, params, x, _i, _j, _len, _ref;

      length = args.length;
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        x = args[_i];
        params = this.vari('a');
      }
      cont = cont.call(params);
      compiler = this;
      for (i = _j = _ref = length - 1; _j >= 0; i = _j += -1) {
        cont = (function(i, cont) {
          return compiler.cont(args[i], il.clamda(params[i], cont));
        })(i, cont);
      }
      return cont;
    };

    Compiler.prototype.quasiquote = function(exp, cont) {
      return (exp != null ? typeof exp.quasiquote === "function" ? exp.quasiquote(this, cont) : void 0 : void 0) || (function(v) {
        return cont(exp);
      });
    };

    return Compiler;

  })();

  Env = (function() {
    function Env(outer, data) {
      this.outer = outer;
      this.data = data != null ? data : {};
    }

    Env.prototype.extend = function(vari, value) {
      var data;

      data = {};
      data[vari.name] = value;
      return new Env(this, data);
    };

    Env.prototype.lookup = function(vari) {
      var data, name, outer;

      data = this.data;
      name = vari.name;
      if (data.hasOwnProperty(name)) {
        return data[name];
      } else {
        outer = this.outer;
        if (outer) {
          return outer.lookup(vari);
        } else {
          return vari;
        }
      }
    };

    return Env;

  })();

  exports.Var = Var = (function() {
    function Var(name) {
      this.name = name;
    }

    Var.prototype.cont = function(compiler, cont) {
      return il["return"](cont.call(il.deref(this.interlang())));
    };

    Var.prototype.interlang = function() {
      return il.vari(this.name);
    };

    Var.prototype.toString = function() {
      return "vari(" + this.name + ")";
    };

    return Var;

  })();

  reElements = /\s*,\s*|\s+/;

  exports.vari = function(name) {
    return new Var(name);
  };

  exports.vars = function(names) {
    var name, _i, _len, _ref, _results;

    _ref = split(names, reElements);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _results.push(vari(name));
    }
    return _results;
  };

  UnquoteSliceValue = exports.UnquoteSliceValue = (function() {
    function UnquoteSliceValue(value) {
      this.value = value;
    }

    return UnquoteSliceValue;

  })();

  exports.macro = commandMaker(exports.Macro);

  exports.Error = Error = (function() {
    function Error(exp, message, stack) {
      this.exp = exp;
      this.message = message != null ? message : '';
      this.stack = stack != null ? stack : this;
    }

    Error.prototype.toString = function() {
      return "" + this.constructor.name + ": " + this.exp + " >>> " + this.message;
    };

    return Error;

  })();

  exports.TypeError = TypeError = (function(_super) {
    __extends(TypeError, _super);

    function TypeError() {
      _ref = TypeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TypeError;

  })(Error);

  exports.ArgumentError = ArgumentError = (function(_super) {
    __extends(ArgumentError, _super);

    function ArgumentError() {
      _ref1 = ArgumentError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ArgumentError;

  })(Error);

  exports.ArityError = ArityError = (function(_super) {
    __extends(ArityError, _super);

    function ArityError() {
      _ref2 = ArityError.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return ArityError;

  })(Error);

}).call(this);

/*
//@ sourceMappingURL=core.map
*/
