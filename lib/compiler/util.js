// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, defaultLabel, excludes, if_, iff, il, io, isLabel, jsfun, lambda, macro, makeLabel, name, not_, orp, quasiquote, sideEffect, string, unquote, unquoteSlice, vop, _, _o,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  exports.string = string = function(s) {
    return ["string", s];
  };

  exports.vars = function(names) {
    var name, _i, _len, _ref, _results;

    _ref = split(names, reElements);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _results.push(vari(name));
    }
    return _results;
  };

  exports.quote = function(exp) {
    return ["quote", exp];
  };

  exports.eval_ = function(exp, path) {
    return ["eval", exp, path];
  };

  exports.begin = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ["begin"].concat(exps);
  };

  exports.assign = function(left, exp) {
    return ["assign", left, exp];
  };

  exports.augassign = function(left, exp) {
    return ["augment-assign", op, left, exp];
  };

  exports.addassign = function(left, exp) {
    return ["augment-assign", 'add', left, exp];
  };

  exports.subassign = function(left, exp) {
    return ["augment-assign", 'sub', left, exp];
  };

  exports.mulassign = function(left, exp) {
    return ["augment-assign", 'mul', left, exp];
  };

  exports.divassign = function(left, exp) {
    return ["augment-assign", 'div', left, exp];
  };

  exports.modassign = function(left, exp) {
    return ["augment-assign", 'mod', left, exp];
  };

  exports.andassign = function(left, exp) {
    return ["augment-assign", 'and', left, exp];
  };

  exports.orassign = function(left, exp) {
    return ["augment-assign", 'or', left, exp];
  };

  exports.bitandassign = function(left, exp) {
    return ["augment-assign", 'bitand', left, exp];
  };

  exports.bitorassign = function(left, exp) {
    return ["augment-assign", 'bitor', left, exp];
  };

  exports.bitxorassign = function(left, exp) {
    return ["augment-assign", 'bitxor', left, exp];
  };

  exports.lshiftassign = function(left, exp) {
    return ["augment-assign", 'lshift', left, exp];
  };

  exports.rshiftassign = function(left, exp) {
    return ["augment-assign", 'rshift', left, exp];
  };

  exports.if_ = if_ = function(test, then_, else_) {
    return ["if", test, then_, else_];
  };

  exports.iff = iff = function(clauses, else_) {
    var length, test, then_, _ref;

    length = clauses.length;
    if (length === 0) {
      throw new Error("iff clauses should have at least one clause.");
    } else {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      if (length === 1) {
        return if_(test, then_, else_);
      } else {
        return if_(test, then_, iff(clauses.slice(1), else_));
      }
    }
  };

  exports.funcall = function() {
    var args, caller;

    caller = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ["funcall", caller].concat(args);
  };

  exports.macall = function() {
    var args, caller;

    caller = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ["macall", caller].concat(args);
  };

  exports.jsobject = function(exp) {
    return ["jsobject", exp];
  };

  exports.jsfun = jsfun = function(exp) {
    return ["jsfun", exp];
  };

  exports.pure = io = function(exp) {
    return ["pure", exp];
  };

  exports.effect = sideEffect = function(exp) {
    return ["effect", exp];
  };

  exports.io = io = function(exp) {
    return ["io", exp];
  };

  exports.lamda = lambda = function() {
    var body, params;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ["lambda", params].concat(body);
  };

  exports.macro = macro = function() {
    var body, params;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ["macro", params].concat(body);
  };

  exports.qq = quasiquote = function(exp) {
    return ["quasiquote", exp];
  };

  exports.uq = unquote = function(exp) {
    return ["unquote", exp];
  };

  exports.uqs = unquoteSlice = function(exp) {
    return ["unquote-slice", exp];
  };

  isLabel = function(label) {
    return _.isArray(label) && label.length === 2 && label[0] === 'label';
  };

  exports.makeLabel = makeLabel = function(label) {
    return ['label', label];
  };

  defaultLabel = ['label', ''];

  exports.block = block = function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!isLabel(label)) {
      label = makeLabel('');
      body = [label].concat(body);
    }
    return ['block', label].concat(__slice.call(body));
  };

  exports.break_ = break_ = function(label, value) {
    if (label == null) {
      label = defaultLabel;
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !isLabel(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !isLabel(label)) {
      value = label;
      label = makeLabel('');
    }
    return ['break', label, value];
  };

  exports.continue_ = continue_ = function(label) {
    if (label == null) {
      label = defaultLabel;
    }
    return ['continue', label];
  };

  exports.loop_ = function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!isLabel(label)) {
      label = defaultLabel;
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  };

  exports.while_ = function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!isLabel(label)) {
      label = defaultLabel;
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  };

  exports.until_ = function() {
    var body, label, test, _i;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), test = arguments[_i++];
    if (!isLabel(label)) {
      label = defaultLabel;
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  };

  exports.catch_ = function() {
    var forms, tag;

    tag = arguments[0], forms = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ['catch', tag].concat(__slice.call(forms));
  };

  exports.throw_ = function(tag, form) {
    return ['throw', tag, form];
  };

  exports.protect = function() {
    var cleanup, form;

    form = arguments[0], cleanup = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ['unwind-protect', form].concat(__slice.call(cleanup));
  };

  exports.callcc = function(fun) {
    return ['callcc', fun];
  };

  exports.print_ = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return ['funcall', io(jsfun('console.log'))].concat(exps);
  };

  exports.vop = vop = function() {
    var args, name;

    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ["vop_" + name].concat(args);
  };

  exports.inc = function(item) {
    return ['inc', item];
  };

  exports.suffixinc = function(item) {
    return ['suffixinc', item];
  };

  exports.dec = function(item) {
    return ['dec', item];
  };

  exports.suffixdec = function(item) {
    return ['suffixdec', item];
  };

  il = require("./interlang");

  excludes = ['evalexpr', 'failcont', 'run', 'push', 'getvalue', 'fake', 'findCatch', 'popCatch', 'pushCatch', 'protect', 'suffixdec', 'suffixdec', 'dec', 'inc'];

  for (name in il) {
    _o = il[name];
    if (_o instanceof il.VirtualOperation && __indexOf.call(excludes, name) < 0) {
      (function(name) {
        return exports[name] = function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return vop.apply(null, [name].concat(__slice.call(args)));
        };
      })(name);
    }
  }

  not_ = exports.not_;

  exports.succeed = ['succeed'];

  exports.fail = ['fail'];

  exports.andp = exports.begin;

  exports.orp = orp = function() {
    var exps, length;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    length = exps.length;
    if (length === 0) {
      throw new ArgumentError(exps);
    } else if (length === 1) {
      return exps[0];
    } else if (length === 2) {
      return ['orp'].concat(__slice.call(exps));
    } else {
      return ['orp', exps[0], orp.apply(null, exps.slice(1))];
    }
  };

  exports.notp = function(goal) {
    return ['notp', goal];
  };

  exports.repeat = function() {
    return ['repeat'];
  };

}).call(this);

/*
//@ sourceMappingURL=util.map
*/
