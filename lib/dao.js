// Generated by CoffeeScript 1.6.2
(function() {
  var $arrayLiteral, $assignExpr, $atomExpr, $attrExpr, $binaryExpr, $blockcomment, $code, $exprList, $expression, $forExpr, $ifExpr, $indexExpr, $invocationExpr, $leftValueExpr, $linecomment, $matchToEOL, $operationExpr, $parenExper, $parenExpr, $program, $programBody, $statement, $switchExpr, $throwExpr, $tryExpr, $unaryExpr, $valueExpr, TOKEN_ADD, TOKEN_ADD2, TOKEN_AND, TOKEN_ARROW, TOKEN_BACKQUOTE, TOKEN_BACKQUOTE2, TOKEN_BACKQUOTE3, TOKEN_BITNOT, TOKEN_BITXOR, TOKEN_BLOCKCOMMENTBEGIN, TOKEN_CASE, TOKEN_CATCH, TOKEN_CLASS, TOKEN_COLON, TOKEN_COLONEQ, TOKEN_CONTINUE, TOKEN_DEBUGGER, TOKEN_DEFAULT, TOKEN_DELETE, TOKEN_DIV, TOKEN_DO, TOKEN_DOT, TOKEN_DOT2, TOKEN_DOT3, TOKEN_DOUBLEQUOTE, TOKEN_DOUBLEQUOTE2, TOKEN_DOUBLEQUOTE3, TOKEN_ELSE, TOKEN_EQ, TOKEN_EQ2, TOKEN_EQ3, TOKEN_FINALLY, TOKEN_FUNCTION, TOKEN_GE, TOKEN_GT, TOKEN_IF, TOKEN_IN, TOKEN_INSTANCEOF, TOKEN_LBRACE, TOKEN_LBRACKET, TOKEN_LE, TOKEN_LET, TOKEN_LINECOMMENTBEGIN, TOKEN_LOGICAND, TOKEN_LOGICNOT, TOKEN_LOGICOR, TOKEN_LOOP, TOKEN_LPAREN, TOKEN_LSHIFT, TOKEN_LT, TOKEN_MUL, TOKEN_NE, TOKEN_NEW, TOKEN_NOT, TOKEN_OR, TOKEN_PASS, TOKEN_QUOTE, TOKEN_QUOTE2, TOKEN_QUOTE3, TOKEN_RBRACE, TOKEN_RETURN, TOKEN_RPAREN, TOKEN_RSHIFT, TOKEN_SEMICOLON, TOKEN_SUB, TOKEN_SUB2, TOKEN_SWITCH, TOKEN_THIS, TOKEN_THROW, TOKEN_TRY, TOKEN_TYPEOF, TOKEN_UNTIL, TOKEN_VAR, TOKEN_VOID, TOKEN_WHEN, TOKEN_WHILE, TOKEN_WITH, andp, array, assign, begin, body, char, charComma, charConlon, charDot, charLeftBracket, charLeftParen, charRightBracket, charRightParen, charSemiConlon, compile, concat, core, daoutil, direct, eoi, eq, exp, funcall, grammar, headList, identifier, if_, il, jsfun, lamda, left, nonlocal, number, op, operator, orp, parsetext, quoteString, readToken, repl, solve, solver, string, switch_, token, util, x, y, z, _i, _ref, _ref1, _results;

  solve = (core = require('./core')).solve;

  _ref = util = require('./util'), string = _ref.string, char = _ref.char, number = _ref.number, parsetext = _ref.parsetext, quoteString = _ref.quoteString, identifier = _ref.identifier, begin = _ref.begin, nonlocal = _ref.nonlocal, direct = _ref.direct, switch_ = _ref.switch_, if_ = _ref.if_, eq = _ref.eq, concat = _ref.concat, jsfun = _ref.jsfun, lamda = _ref.lamda, funcall = _ref.funcall, andp = _ref.andp, orp = _ref.orp, assign = _ref.assign, array = _ref.array, headList = _ref.headList, eoi = _ref.eoi;

  operator = (daoutil = require('./daoutil')).operator;

  il = require('./interlang');

  _ref1 = (function() {
    _results = [];
    for (_i = 1; _i <= 255; _i++){ _results.push(_i); }
    return _results;
  }).apply(this), TOKEN_BLOCKCOMMENTBEGIN = _ref1[0], TOKEN_LINECOMMENTBEGIN = _ref1[1], TOKEN_QUOTE = _ref1[2], TOKEN_QUOTE2 = _ref1[3], TOKEN_QUOTE3 = _ref1[4], TOKEN_DOUBLEQUOTE = _ref1[5], TOKEN_DOUBLEQUOTE2 = _ref1[6], TOKEN_DOUBLEQUOTE3 = _ref1[7], TOKEN_BACKQUOTE = _ref1[8], TOKEN_BACKQUOTE2 = _ref1[9], TOKEN_BACKQUOTE3 = _ref1[10], TOKEN_LPAREN = _ref1[11], TOKEN_RPAREN = _ref1[12], TOKEN_LBRACKET = _ref1[13], TOKEN_RPAREN = _ref1[14], TOKEN_LBRACE = _ref1[15], TOKEN_RBRACE = _ref1[16], TOKEN_COLON = _ref1[17], TOKEN_SEMICOLON = _ref1[18], TOKEN_DOT = _ref1[19], TOKEN_DOT2 = _ref1[20], TOKEN_DOT3 = _ref1[21], TOKEN_ARROW = _ref1[22], TOKEN_EQ = _ref1[23], TOKEN_EQ2 = _ref1[24], TOKEN_EQ3 = _ref1[25], TOKEN_NE = _ref1[26], TOKEN_GT = _ref1[27], TOKEN_GE = _ref1[28], TOKEN_LE = _ref1[29], TOKEN_LT = _ref1[30], TOKEN_COLONEQ = _ref1[31], TOKEN_ADD = _ref1[32], TOKEN_ADD2 = _ref1[33], TOKEN_SUB = _ref1[34], TOKEN_SUB2 = _ref1[35], TOKEN_MUL = _ref1[36], TOKEN_DIV = _ref1[37], TOKEN_LSHIFT = _ref1[38], TOKEN_RSHIFT = _ref1[39], TOKEN_BITNOT = _ref1[40], TOKEN_BITXOR = _ref1[41], TOKEN_LOGICNOT = _ref1[42], TOKEN_LOGICAND = _ref1[43], TOKEN_LOGICOR = _ref1[44], TOKEN_IF = _ref1[45], TOKEN_ELSE = _ref1[46], TOKEN_SWITCH = _ref1[47], TOKEN_THIS = _ref1[48], TOKEN_CLASS = _ref1[49], TOKEN_RETURN = _ref1[50], TOKEN_PASS = _ref1[51], TOKEN_TRY = _ref1[52], TOKEN_CATCH = _ref1[53], TOKEN_FINALLY = _ref1[54], TOKEN_WHILE = _ref1[55], TOKEN_UNTIL = _ref1[56], TOKEN_DO = _ref1[57], TOKEN_WHEN = _ref1[58], TOKEN_LET = _ref1[59], TOKEN_CASE = _ref1[60], TOKEN_DEBUGGER = _ref1[61], TOKEN_DEFAULT = _ref1[62], TOKEN_DELETE = _ref1[63], TOKEN_IN = _ref1[64], TOKEN_INSTANCEOF = _ref1[65], TOKEN_NEW = _ref1[66], TOKEN_THROW = _ref1[67], TOKEN_FUNCTION = _ref1[68], TOKEN_CONTINUE = _ref1[69], TOKEN_VOID = _ref1[70], TOKEN_VAR = _ref1[71], TOKEN_WITH = _ref1[72], TOKEN_TYPEOF = _ref1[73], TOKEN_LOOP = _ref1[74], TOKEN_AND = _ref1[75], TOKEN_NOT = _ref1[76], TOKEN_OR = _ref1[77];

  repl = function() {};

  exports.compile = compile = function(code) {
    var path, sexpr;

    sexpr = core.solve(parsetext(grammar, string(exp)));
    path = process.cwd() + '/lib/compiled.js';
    return core.compile(sexpr, path);
  };

  exports.solve = solve = function(exp) {
    var sexpr;

    return sexpr = core.solve(parsetext(grammar, string(exp)));
  };

  solver = 'solver';

  x = 'x';

  y = 'y';

  z = 'z';

  op = 'op';

  left = 'left';

  token = 'token';

  readToken = 'readToken';

  exp = 'exp';

  body = 'body';

  $program = '$program';

  $programBody = '$programBody';

  $statement = '$statement';

  $expression = '$expression';

  $exprList = '$exprList';

  $ifExpr = '$ifExpr';

  $forExpr = '$forExpr';

  $switchExpr = '$switchExpr';

  $tryExpr = '$tryExpr';

  $throwExpr = '$throwExpr';

  $assignExpr = '$assignExpr';

  $leftValueExpr = '$leftValueExpr';

  $attrExpr = '$attrExpr';

  $indexExpr = '$indexExpr';

  $operationExpr = '$operationExpr';

  $binaryExpr = '$binaryExpr';

  $unaryExpr = '$unaryExpr';

  $atomExpr = '$atomExpr';

  $parenExpr = '$parenExpr';

  $valueExpr = '$valueExpr';

  $invocationExpr = '$invocationExpr';

  $code = '$code';

  $parenExper = '$parenExper';

  $arrayLiteral = '$arrayLiteral';

  $linecomment = '$linecomment';

  $blockcomment = '$blockcomment\
';

  $matchToEOL = '$matchToEOL';

  charLeftParen = char(string('('));

  charRightParen = char(string(')'));

  charLeftBracket = char(string('['));

  charRightBracket = char(string(']'));

  charDot = char(string('.'));

  charComma = char(string(','));

  charSemiConlon = char(string(';'));

  charConlon = char(string(':'));

  grammar = begin(direct(il.begin(il.assign(il.uservar('daoutil'), il.require('./daoutil')), il.assign(il.uservar('readToken'), il.attr(il.uservar('daoutil'), il.symbol('readToken'))), il.assign(il.uservar('binaryOperator'), il.attr(il.uservar('daoutil'), il.symbol('binaryOperator'))), il.assign(il.uservar('unaryOperator'), il.attr(il.uservar('daoutil'), il.symbol('unaryOperator'))), il.assign(il.uservar('assignOperator'), il.attr(il.uservar('daoutil'), il.symbol('assignOperator'))), il.assign(il.uservar('suffixOperator'), il.attr(il.uservar('daoutil'), il.symbol('suffixOperator'))))), assign($program, lamda([], orp(andp(eoi, null), andp(assign(body, funcall($programBody), headList('begin', body)))))), assign($statement, lamda([], assign(token, funcall(readToken)), switch_(token, [TOKEN_RETURN], begin(assign(exp, funcall($expression)), array(util.RETURN, exp)), [TOKEN_PASS], funcall($matchToEOL), [TOKEN_BLOCKCOMMENTBEGIN], funcall($blockcomment), funcall($expression)))), assign($expression, lamda([], orp(funcall($valueExpr), funcall($invocationExpr), funcall($code), funcall($operationExpr), funcall($assignExpr), funcall($ifExpr), funcall($tryExpr), funcall($forExpr), funcall($switchExpr), funcall($throwExpr)))), assign($assignExpr, lamda([], assign(left, funcall($leftValueExpr)), assign(op, funcall('assignOperator', solver)), assign(exp, funcall($expression)), if_(eq(op, util.ASSIGN), array(op, left, exp), concat(op, array(left, exp))))), assign($leftValueExpr, lamda([], orp(identifier(), funcall($attrExpr), funcall($indexExpr)))), assign($attrExpr, lamda([], andp(orp(identifier(), funcall($parenExper), funcall($arrayLiteral), quoteString()), charDot, identifier()))), assign($indexExpr, lamda([], andp(orp(identifier(), funcall($parenExpr)), charLeftBracket, funcall($expression), charRightBracket))), assign($binaryExpr, lamda([], andp(assign(x, funcall($unaryExpr)), orp(andp(assign(op, funcall('binaryOperator', solver)), assign(y, funcall($unaryExpr)), array(op, x, y)), x)))), assign($unaryExpr, lamda([], orp(andp(assign(op, funcall('unaryOperator', solver)), assign(x, funcall($atomExpr)), array(op, x)), andp(assign(x, funcall($atomExpr)), orp(andp(assign(op, funcall('suffixOperator', solver)), array(op, x)), x))))), assign($parenExpr, lamda([], andp(charLeftParen, assign(exp, funcall($binaryExpr)), charRightParen, exp))), assign($atomExpr, lamda([], orp(identifier(), array(util.STRING, quoteString()), number(), funcall($parenExpr)))), funcall($binaryExpr));

}).call(this);

/*
//@ sourceMappingURL=dao.map
*/
