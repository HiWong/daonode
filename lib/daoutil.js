// Generated by CoffeeScript 1.6.2
(function() {
  var ADD, AND, BITAND, BITNOT, BITOR, BinaryOperatorMap, DIV, ExpressionError, LSFHIFT, MOD, MUL, NOT, OR, RSHIFT, SUB, StateMachine, Trail, TypeError, UnaryOperatorMap, Var, andp, char, hasOwnProperty, index, keyword, literal, newToken, nextToken, notp, orp, pair, readToken, rules, spaces, spaces1, suffixOperatorMap, tokenInfoList, tokenNames, util, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  _ref1 = util = require("./util"), ADD = _ref1.ADD, SUB = _ref1.SUB, MUL = _ref1.MUL, DIV = _ref1.DIV, MOD = _ref1.MOD, LSFHIFT = _ref1.LSFHIFT, RSHIFT = _ref1.RSHIFT, AND = _ref1.AND, OR = _ref1.OR, NOT = _ref1.NOT, BITAND = _ref1.BITAND, BITOR = _ref1.BITOR, BITNOT = _ref1.BITNOT;

  index = 0;

  exports.tokenInfoList = tokenInfoList = [];

  newToken = function(text) {
    var i, name, names, symbol, _i, _len;

    i = text.indexOf(': ');
    names = text.slice(0, i).split(' ');
    symbol = text.slice(i + 2);
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      tokenNames[name] = global[name] = index;
    }
    tokenInfoList.push([symbol, index]);
    return index++;
  };

  exports.tokenNames = tokenNames = {};

  _ref2 = ['TKNLINECOMMENTBEGIN TKNSHARP: #', 'TKNSHARP2: ##', 'TKNSHARP3: ###', "TKNQUOTE: '", "TKNQUOTE2: ''", "TKNQUOTE3: '''", 'TKNDOUBLEQUOTE1: "', 'TKNDOUBLEQUOTE2: ""', 'TKNDOUBLEQUOTE3: """', 'TKNBACKQUOTE: `', 'TKNBACKQUOTE2: ``', 'TKNBACKQUOTE3: ```', 'TKNLPAREN: (', 'TKNRPAREN: )', 'TKNLBRACKET: [', 'TKNRBRACKET: ]', 'TKNLBRACE: {', 'TKNRBRACE: }', 'TKNCOLON: :', 'TKNCOLON2: ::', 'TKNCOLON3: :::', 'TKNSEMICOLON: ;', 'TKNDOT: .', 'TKNDOT2: ..', 'TKNDOT3: ...', 'TKNEQ: =', 'TKNEQ2: ==', 'TKNEQ3: ===', 'TKNGT: >', 'TKNGT2 TKNRSHIFT: >>', 'TKNGT3: >>>', 'TKNLT: <', 'TKNLT2 TKNLSHIFT: <<', 'TKNLT3: <<<', 'TKNNE: !=', 'TKNLTGT: <>', 'TKNGE: >=', 'TKNLE: <=', 'TKNSUBARROW: ->', 'TKNEQARROW: =>', 'TKNCOLONEQ: :=', 'TKNCOLONSUB: :-', 'TKNPOSITIVE TKNADD: +', 'TKNINC TKNADD2: ++', 'TKNADD3: +++', 'TKNNEG TKNSUB: -', 'TKNDEC TKNSUB2: --', 'TKNSUB3: ---', 'TKNMUL: *', 'TKNMUL2: **', 'TKNMUL3: ***', 'TKNDIV: /', 'TKNDIV2: //', 'TKNDIV3: ///', 'TKNMOD: %', 'TKNMOD2: %%', 'TKNMOD3: %%%', 'TKNVLINE TKNBITOR: |', 'TKNVLINE2 TKNOR: ||', 'TKNVLINE3: |||', 'TKNBITNOT: ~', 'TKNBITXOR: ^', 'TKNNOT: !', 'TKNBITAND AMPERSAND1: &', 'TKNAND AMPERSAND2: &&', 'AMPERSAND3: &&&', 'TKNRETURN: return', 'TKNPASS: pass', 'TKNCONTINUE: continue', 'TKNBREAK: break', 'TKNIF: if', 'TKNELSE: else', 'TKNELSEIF: elseif', 'TKNELIF: elif', 'TKNSWITCH: switch', 'TKNDEFAULT: default', 'TKNTRY: try', 'TKNCATCH: catch', 'TKNEXCEPT: except', 'TKNFINALLY: finally', 'TKNTHROW: throw', 'TKNRAISE: raise', 'TKNERROR: error', 'TKNWHILE: while', 'TKNUNTIL: until', 'TKNLOOP: loop', 'TKNWHEN: when', 'TKNON: on', 'TKNLET: let', 'TKNWHERE: where', 'TKNCASE: case', 'TKNVAR: var', 'TKNWITH: with', 'TKNDELETE: delete', 'TKNDEL: del', 'TKNFUNCTION: function', 'TKNFUN: fun', 'TKNDEF: def', 'TKNCLASS: class', 'TKNMACRO: macro', 'TKNIN: in', 'TKNIS: is', 'TKNIS: unify', 'TKNINSTANCEOF: instanceof', 'TKNTYPEOF: typeof', 'TKNDOF: of', 'TKNAND: and', 'TKNNOT: not', 'TKNOR: or', 'TKNVOID: void', 'TKNNEW: new', 'TKNDEBUGGER: debugger', 'TKNTHIS: this'];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    x = _ref2[_i];
    newToken(x);
  }

  hasOwnProperty = Object.hasOwnProperty;

  exports.StateMachine = StateMachine = (function() {
    function StateMachine(items) {
      var item, _j, _len1;

      if (items == null) {
        items = [];
      }
      this.index = 1;
      this.stateMap = {};
      this.stateMap[0] = {};
      this.tagMap = {};
      for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
        item = items[_j];
        this.add(item[0], item[1]);
      }
    }

    StateMachine.prototype.add = function(word, tag) {
      var c, i, length, newState, s, state;

      length = word.length;
      state = 0;
      i = 0;
      while (i < length - 1) {
        c = word[i++];
        if (hasOwnProperty.call(this.stateMap[state], c)) {
          state = this.stateMap[state][c];
          if (state < 0) {
            state = -state;
          }
        } else {
          newState = this.index++;
          this.stateMap[state][c] = newState;
          this.stateMap[newState] = {};
          state = newState;
        }
      }
      c = word[i];
      if (hasOwnProperty.call(this.stateMap[state], c)) {
        s = this.stateMap[state][c];
        if (s > 0) {
          this.stateMap[state][c] = -s;
          return this.tagMap[s] = tag;
        }
      } else {
        newState = this.index++;
        this.stateMap[state][c] = -newState;
        this.stateMap[newState] = {};
        return this.tagMap[newState] = tag;
      }
    };

    StateMachine.prototype.match = function(text, i) {
      var cursor, length, state, succeedState;

      state = 0;
      length = text.length;
      while (i < length) {
        state = this.stateMap[state][text[i++]];
        if (state === void 0) {
          i--;
          break;
        } else if (state < 0) {
          state = -state;
          succeedState = state;
          cursor = i;
        }
      }
      if (succeedState) {
        return [this.tagMap[succeedState], cursor];
      } else {
        return [null, i];
      }
    };

    return StateMachine;

  })();

  exports.readToken = readToken = function(text, start) {
    var cursor, result, tokenStateMachine, value;

    tokenStateMachine = solver.tokenStateMachine;
    text = solver.parserdata;
    start = solver.parsercursor;
    result = tokenStateMachine.match(text, start);
    value = result[0];
    cursor = result[1];
    if (value) {
      solver.parsercursor = cursor;
      return [value, cursor];
    } else {
      solver.parsercursor = start;
      return null;
    }
  };

  BinaryOperatorMap = {};

  _ref3 = [[TKNADD, ADD], [TKNSUB, SUB], [TKNMUL, MUL], [TKNDIV, DIV], [TKNMOD, MOD], [TKNAND, AND], [TKNOR, OR], [TKNBITAND, BITAND], [TKNBITOR, BITOR], [TKNLSHIFT, LSHIFT], [TKNRSHIFT, RSHIFT], [TKNEQ, EQ], [TKNNE, NE], [TKNLT, LT], [TKNLE, LE], [TKNGE, GE], [TKNGT, GT]];
  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
    pair = _ref3[_j];
    BinaryOperatorMap[pair[0]] = pair[1];
  }

  exports.BinaryOperator = function(solver, cont) {
    var op, start, token;

    start = solver.parsercursor;
    token = readToken(solver);
    op = BinaryOperatorMap[token];
    if (op !== void 0) {
      return cont(op);
    } else {
      solver.parsercursor = start;
      return solver.failcont(null);
    }
  };

  UnaryOperatorMap = {};

  _ref4 = [[TKNNOT, NOT], [TKNBITNOT, BITNOT], [TKNNEG, NEG], [TKNPOSITIVE, POSITIVE], [TKNINC, INC], [TKNDEC, DEC]];
  for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
    pair = _ref4[_k];
    UnaryOperatorMap[pair[0]] = pair[1];
  }

  exports.UnaryOperator = function(solver, cont) {
    var op, start, token;

    start = solver.parsercursor;
    token = readToken(solver);
    op = UnaryOperatorMap[token];
    if (op !== void 0) {
      return cont(op);
    } else {
      solver.parsercursor = start;
      return solver.failcont(null);
    }
  };

  suffixOperatorMap = {};

  _ref5 = [[TKNINC, INC], [TKNDEC, SUFFIXDEC]];
  for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
    pair = _ref5[_l];
    suffixOperatorMap[pair[0]] = pair[1];
  }

  exports.suffixOperator = function(solver, cont) {
    var op, start, token;

    start = solver.parsercursor;
    token = readToken(solver);
    op = suffixOperatorMap[token];
    if (op !== void 0) {
      return cont(op);
    } else {
      solver.parsercursor = start;
      return solver.failcont(null);
    }
  };

  nextToken = function(solver, cont) {
    var c, c2, cursor, result, result2, text;

    text = solver.parserdata;
    cursor = solver.parsercursor;
    c = text[cursor];
    switch (c) {
      case void 0:
        return [EOI, cursor];
      case '0':
        c2 = cursor[1];
        switch (c2) {
          case 'x':
          case 'X':
          case 'h':
          case 'H':
            return hexadigit(text, cursor);
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
            return octal(text, cursor);
        }
        break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        return number(text, cursor);
      case '+':
      case '-':
        c2 = cursor[1];
        switch (c) {
          case '0':
            c2 = cursor[1];
            switch (c2) {
              case 'x':
              case 'X':
              case 'h':
              case 'H':
                return hexadigit(text, cursor);
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                return octal(text, cursor);
            }
            break;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            return number(text, cursor);
        }
        break;
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
        result = keyword(text, cursor);
        if (result[0] === void 0) {
          return result2 = identifier(text, result[1]);
        } else {
          c2 = text[result[1]];
          if (isIdentifierCharacter(c2)) {
            return result2 = identifier(text, result[1]);
          }
        }
        break;
      case '_':
      case '$':
      case 'z':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
        return identifier(text, cursor);
      case ' ':
      case '\t':
        return whitespace(text, cursor);
      case '"':
      case "'":
        result = quoteString(text, cursor, c);
        if (result[0] === void 0) {
          return [QUOTE, c];
        }
        break;
      case '#':
        return result = comment(text, cursor);
      case '\r':
      case '\n':
        return newlineIndent(text, cursor, solver);
      default:
        return symbolToken(text, cursor);
    }
  };

  orp = function(exps) {
    return function(start) {
      var i, length;

      length = exps.length;
      i = 0;
      while (i < length) {
        x = exps(start);
        if (x != null) {
          return x;
        }
      }
    };
  };

  andp = function(exps) {
    return function(start) {
      var cursor, i, length;

      length = exps.length;
      i = 0;
      cursor = start;
      while (i < length) {
        x = exps(cursor);
        if (x == null) {
          return;
        }
      }
      return x;
    };
  };

  notp = function(exp) {
    return function(start) {
      x = exp(start);
      if (x == null) {
        return true;
      }
    };
  };

  char = function(c) {
    return function(start) {
      var cursor;

      if (text[start] === c) {
        cursor = start + 1;
        return true;
      }
    };
  };

  literal = function(string) {
    return function(start) {
      var cursor, len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  keyword = function(string) {
    return function(start) {
      var cursor, len, stop, stop2;

      len = string.length;
      if (text.slice(start, stop = start + len) === string && !text[stop2 = stop + 1].match(/^[A-Za-z]/)) {
        cursor = stop2;
        return true;
      }
    };
  };

  spaces = function(start) {
    var cursor, len;

    len = 0;
    cursor = start;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  spaces1 = function(start) {
    var cursor, len;

    len = 0;
    cursor = start;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return len;
    }
  };

  exports.parse = function(element, text, tabWidth) {
    if (tabWidth == null) {
      tabWidth = 4;
    }
    global.text = text;
    global.cursor = 0;
    global.tokens = [];
    global.memo = {};
    global.indentList = [];
    global.tabWidth = tabWidth;
    return rules[element](0);
  };

  rules = {
    Root: function(start) {
      if (start === textLength) {
        return null;
      } else {
        return rules.Body(start);
      }
    },
    Body: function(start) {
      var cursor, exps;

      cursor = start;
      exps = [];
      while (1) {
        x = rules.Statement(start);
        if (x instanceof Comment) {
          continue;
        } else if (cursor === textLength) {
          return begin.apply(null, exps);
        } else {
          exps.push(Statement());
        }
      }
    },
    Statement: orp(rules.Comment, rules.Return, rules.Expression),
    Expression: orp(rules.If, rules.Try, rules.For, rules.While, rules.Throw, rules.Class, rules.Switch, rules.Value, rules.Invocation, rules.FunctionDef, rules.Operation),
    Block: andp(indent, rules.Body, dedent),
    Literal: orp(rules.KeywordLiteral, rules.RawJS, rules.String, rules.Alpha, rules.Number, rules.JSRegex),
    KeywordLiteral: function(start) {
      var s;

      if (text.slice(start, start + 2) === 'true') {
        return new Literal(true);
      }
      s = text.slice(start, start + 4);
      if (s === 'null') {
        return new Literal(null);
      }
      if (s === 'true') {
        return new Literal(true);
      }
      s = text.slice(start, start + 5);
      if (s === 'false') {
        return new Literal(false);
      }
      if (text.slice(start, start + 7) === 'debugger') {
        return new Literal('debugger');
      }
      s = text.slice(start, start + 9);
      if (s === 'undefined') {
        return new Literal(void 0);
      }
    },
    Assign: function(start) {
      var exp, left;

      left = rules.Assignable(start);
      if (left === null) {
        return;
      }
      if (rules.wrapSpaces('=')(cursor) === null) {
        return;
      }
      if (newline(cursor) === null) {
        exp = rules.Expression(cursor);
      } else {
        if (indent() === null) {
          return;
        }
        exp = rules.Expression(cursor);
        if (dedent() === null) {
          return;
        }
      }
      return assign(left, exp);
    },
    AssignObj: orp(rules.Comment, AssignObjClause),
    AssignObjClause: function(start) {
      var exp, left;

      left = rules.ObjAssignable(start);
      if (left === null) {
        return;
      }
      andp(spaces, char(':'), spaces)(cursor);
      if (indent(cursor) === null) {
        exp = rules.Expression(cursor);
      } else {
        if ((exp = rules.Expression(cursor)) !== null) {
          dedent(cursor);
        }
      }
      return [left, exp];
    },
    ObjAssignable: orp(rules.Identifier, rules.Alpha, rules.Numberic, rules.ThisProperty),
    Return: function(start) {
      var exp;

      if (keyword('return')(start) && spaces(cursor)) {
        if (exp = rules.Expression(cursor)) {
          return util.return_(exp);
        } else {
          return util.return_();
        }
      }
    },
    Comment: function(start) {
      var string;

      spaces(start);
      char('#')(cursor);
      string = matchToNewLine(cursor);
      return new Comment(string);
    },
    FunctionDef: function(start) {
      var body, params;

      params = rules.Parameters(start);
      wrapped(rules.FuncGlyph)(cursor);
      body = Block(cursor);
      return util.lamda(params, body);
    },
    FuncGlyph: function(start) {
      if (literal('->')(start)) {
        return 'func';
      } else if (literal('=>')(start)) {
        return 'boundfunc';
      }
    },
    Parameters: function(start) {
      x = wrap(ParamList, leftParen, rightParen);
      if (x != null) {
        return x;
      } else {
        return [];
      }
    },
    ParameterList: function(start) {
      var exp, result;

      result = [];
      spaces(curosr);
      while (1) {
        exp = rules.Param(cursor);
        orp(wrapped(char(',')), andp(may(wrapped(char(','))), newline))(curosr);
        if (exp != null) {
          result.push(exp);
        } else {
          breaks;
        }
      }
      return [];
    },
    Param: function(start) {
      var v, v2;

      v = rules.ParamVar(start);
      if (v) {
        if (wrap('...')(cursor)) {
          return new Param($1, null, true);
        } else {
          if (v2 = andp(wrap('='), rules.Expression)) {
            new Param($1, $3);
          }
        }
      }
      o('ParamVar', function() {
        return new Param($1);
      });
      o('ParamVar ...', function() {
        return new Param($1, null, true);
      });
      return o('ParamVar = Expression', function() {
        return new Param($1, $3);
      });
    },
    ParamVar: [o('Identifier'), o('ThisProperty'), o('Array'), o('Object')],
    Splat: [
      o('Expression ...', function() {
        return new Splat($1);
      })
    ],
    SimpleAssignable: [
      o('Identifier', function() {
        return new Value($1);
      }), o('Value Accessor', function() {
        return $1.add($2);
      }), o('Invocation Accessor', function() {
        return new Value($1, [].concat($2));
      }), o('ThisProperty')
    ],
    Assignable: [
      o('SimpleAssignable'), o('Array', function() {
        return new Value($1);
      }), o('Object', function() {
        return new Value($1);
      })
    ],
    Value: [
      o('Assignable'), o('Literal', function() {
        return new Value($1);
      }), o('Parenthetical', function() {
        return new Value($1);
      }), o('Range', function() {
        return new Value($1);
      }), o('This')
    ],
    Accessor: [
      o('.  Identifier', function() {
        return new Access($2);
      }), o('?. Identifier', function() {
        return new Access($2, 'soak');
      }), o(':: Identifier', function() {
        return [LOC(1)(new Access(new Literal('prototype'))), LOC(2)(new Access($2))];
      }), o('?:: Identifier', function() {
        return [LOC(1)(new Access(new Literal('prototype'), 'soak')), LOC(2)(new Access($2))];
      }), o('::', function() {
        return new Access(new Literal('prototype'));
      }), o('Index')
    ],
    Index: [
      o('INDEX_START IndexValue INDEX_END', function() {
        return $2;
      }), o('INDEX_SOAK  Index', function() {
        return extend($2, {
          soak: true
        });
      })
    ],
    IndexValue: [
      o('Expression', function() {
        return new Index($1);
      }), o('Slice', function() {
        return new Slice($1);
      })
    ],
    Object: [
      o('{ AssignList OptComma }', function() {
        return new Obj($2, $1.generated);
      })
    ],
    AssignList: [
      o('', function() {
        return [];
      }), o('AssignObj', function() {
        return [$1];
      }), o('AssignList , AssignObj', function() {
        return $1.concat($3);
      }), o('AssignList OptComma TERMINATOR AssignObj', function() {
        return $1.concat($4);
      }), o('AssignList OptComma INDENT AssignList OptComma OUTDENT', function() {
        return $1.concat($4);
      })
    ],
    Class: [
      o('CLASS', function() {
        return new Class;
      }), o('CLASS Block', function() {
        return new Class(null, null, $2);
      }), o('CLASS EXTENDS Expression', function() {
        return new Class(null, $3);
      }), o('CLASS EXTENDS Expression Block', function() {
        return new Class(null, $3, $4);
      }), o('CLASS SimpleAssignable', function() {
        return new Class($2);
      }), o('CLASS SimpleAssignable Block', function() {
        return new Class($2, null, $3);
      }), o('CLASS SimpleAssignable EXTENDS Expression', function() {
        return new Class($2, $4);
      }), o('CLASS SimpleAssignable EXTENDS Expression Block', function() {
        return new Class($2, $4, $5);
      })
    ],
    Invocation: [
      o('Value OptFuncExist Arguments', function() {
        return new Call($1, $3, $2);
      }), o('Invocation OptFuncExist Arguments', function() {
        return new Call($1, $3, $2);
      }), o('SUPER', function() {
        return new Call('super', [new Splat(new Literal('arguments'))]);
      }), o('SUPER Arguments', function() {
        return new Call('super', $2);
      })
    ],
    OptFuncExist: [
      o('', function() {
        return false;
      }), o('FUNC_EXIST', function() {
        return true;
      })
    ],
    Arguments: [
      o('CALL_START CALL_END', function() {
        return [];
      }), o('CALL_START ArgList OptComma CALL_END', function() {
        return $2;
      })
    ],
    This: [
      o('THIS', function() {
        return new Value(new Literal('this'));
      }), o('@', function() {
        return new Value(new Literal('this'));
      })
    ],
    ThisProperty: [
      o('@ Identifier', function() {
        return new Value(LOC(1)(new Literal('this')), [LOC(2)(new Access($2))], 'this');
      })
    ],
    Array: [
      o('[ ]', function() {
        return new Arr([]);
      }), o('[ ArgList OptComma ]', function() {
        return new Arr($2);
      })
    ],
    RangeDots: [
      o('..', function() {
        return 'inclusive';
      }), o('...', function() {
        return 'exclusive';
      })
    ],
    Range: [
      o('[ Expression RangeDots Expression ]', function() {
        return new Range($2, $4, $3);
      })
    ],
    Slice: [
      o('Expression RangeDots Expression', function() {
        return new Range($1, $3, $2);
      }), o('Expression RangeDots', function() {
        return new Range($1, null, $2);
      }), o('RangeDots Expression', function() {
        return new Range(null, $2, $1);
      }), o('RangeDots', function() {
        return new Range(null, null, $1);
      })
    ],
    ArgList: [
      o('Arg', function() {
        return [$1];
      }), o('ArgList , Arg', function() {
        return $1.concat($3);
      }), o('ArgList OptComma TERMINATOR Arg', function() {
        return $1.concat($4);
      }), o('INDENT ArgList OptComma OUTDENT', function() {
        return $2;
      }), o('ArgList OptComma INDENT ArgList OptComma OUTDENT', function() {
        return $1.concat($4);
      })
    ],
    Arg: [o('Expression'), o('Splat')],
    SimpleArgs: [
      o('Expression'), o('SimpleArgs , Expression', function() {
        return [].concat($1, $3);
      })
    ],
    Try: [
      o('TRY Block', function() {
        return new Try($2);
      }), o('TRY Block Catch', function() {
        return new Try($2, $3[0], $3[1]);
      }), o('TRY Block FINALLY Block', function() {
        return new Try($2, null, null, $4);
      }), o('TRY Block Catch FINALLY Block', function() {
        return new Try($2, $3[0], $3[1], $5);
      })
    ],
    Catch: [
      o('CATCH Identifier Block', function() {
        return [$2, $3];
      }), o('CATCH Object Block', function() {
        return [LOC(2)(new Value($2)), $3];
      }), o('CATCH Block', function() {
        return [null, $2];
      })
    ],
    Throw: [
      o('THROW Expression', function() {
        return new Throw($2);
      })
    ],
    Parenthetical: [
      o('( Body )', function() {
        return new Parens($2);
      }), o('( INDENT Body OUTDENT )', function() {
        return new Parens($3);
      })
    ],
    WhileSource: [
      o('WHILE Expression', function() {
        return new While($2);
      }), o('WHILE Expression WHEN Expression', function() {
        return new While($2, {
          guard: $4
        });
      }), o('UNTIL Expression', function() {
        return new While($2, {
          invert: true
        });
      }), o('UNTIL Expression WHEN Expression', function() {
        return new While($2, {
          invert: true,
          guard: $4
        });
      })
    ],
    While: [
      o('WhileSource Block', function() {
        return $1.addBody($2);
      }), o('Statement  WhileSource', function() {
        return $2.addBody(LOC(1)(Block.wrap([$1])));
      }), o('Expression WhileSource', function() {
        return $2.addBody(LOC(1)(Block.wrap([$1])));
      }), o('Loop', function() {
        return $1;
      })
    ],
    Loop: [
      o('LOOP Block', function() {
        return new While(LOC(1)(new Literal('true'))).addBody($2);
      }), o('LOOP Expression', function() {
        return new While(LOC(1)(new Literal('true'))).addBody(LOC(2)(Block.wrap([$2])));
      })
    ],
    For: [
      o('Statement  ForBody', function() {
        return new For($1, $2);
      }), o('Expression ForBody', function() {
        return new For($1, $2);
      }), o('ForBody    Block', function() {
        return new For($2, $1);
      })
    ],
    ForBody: [
      o('FOR Range', function() {
        return {
          source: LOC(2)(new Value($2))
        };
      }), o('ForStart ForSource', function() {
        $2.own = $1.own;
        $2.name = $1[0];
        $2.index = $1[1];
        return $2;
      })
    ],
    ForStart: [
      o('FOR ForVariables', function() {
        return $2;
      }), o('FOR OWN ForVariables', function() {
        $3.own = true;
        return $3;
      })
    ],
    ForValue: [
      o('Identifier'), o('ThisProperty'), o('Array', function() {
        return new Value($1);
      }), o('Object', function() {
        return new Value($1);
      })
    ],
    ForVariables: [
      o('ForValue', function() {
        return [$1];
      }), o('ForValue , ForValue', function() {
        return [$1, $3];
      })
    ],
    ForSource: [
      o('FORIN Expression', function() {
        return {
          source: $2
        };
      }), o('FOROF Expression', function() {
        return {
          source: $2,
          object: true
        };
      }), o('FORIN Expression WHEN Expression', function() {
        return {
          source: $2,
          guard: $4
        };
      }), o('FOROF Expression WHEN Expression', function() {
        return {
          source: $2,
          guard: $4,
          object: true
        };
      }), o('FORIN Expression BY Expression', function() {
        return {
          source: $2,
          step: $4
        };
      }), o('FORIN Expression WHEN Expression BY Expression', function() {
        return {
          source: $2,
          guard: $4,
          step: $6
        };
      }), o('FORIN Expression BY Expression WHEN Expression', function() {
        return {
          source: $2,
          step: $4,
          guard: $6
        };
      })
    ],
    Switch: [
      o('SWITCH Expression INDENT Whens OUTDENT', function() {
        return new Switch($2, $4);
      }), o('SWITCH Expression INDENT Whens ELSE Block OUTDENT', function() {
        return new Switch($2, $4, $6);
      }), o('SWITCH INDENT Whens OUTDENT', function() {
        return new Switch(null, $3);
      }), o('SWITCH INDENT Whens ELSE Block OUTDENT', function() {
        return new Switch(null, $3, $5);
      })
    ],
    Whens: [
      o('When'), o('Whens When', function() {
        return $1.concat($2);
      })
    ],
    When: [
      o('LEADING_WHEN SimpleArgs Block', function() {
        return [[$2, $3]];
      }), o('LEADING_WHEN SimpleArgs Block TERMINATOR', function() {
        return [[$2, $3]];
      })
    ],
    IfBlock: [
      o('IF Expression Block', function() {
        return new If($2, $3, {
          type: $1
        });
      }), o('IfBlock ELSE IF Expression Block', function() {
        return $1.addElse(LOC(3, 5)(new If($4, $5, {
          type: $3
        })));
      })
    ],
    If: [
      o('IfBlock'), o('IfBlock ELSE Block', function() {
        return $1.addElse($3);
      }), o('Statement  POST_IF Expression', function() {
        return new If($3, LOC(1)(Block.wrap([$1])), {
          type: $2,
          statement: true
        });
      }), o('Expression POST_IF Expression', function() {
        return new If($3, LOC(1)(Block.wrap([$1])), {
          type: $2,
          statement: true
        });
      })
    ],
    Operation: [
      o('UNARY Expression', function() {
        return new Op($1, $2);
      }), o('-     Expression', (function() {
        return new Op('-', $2);
      }), {
        prec: 'UNARY'
      }), o('+     Expression', (function() {
        return new Op('+', $2);
      }), {
        prec: 'UNARY'
      }), o('-- SimpleAssignable', function() {
        return new Op('--', $2);
      }), o('++ SimpleAssignable', function() {
        return new Op('++', $2);
      }), o('SimpleAssignable --', function() {
        return new Op('--', $1, null, true);
      }), o('SimpleAssignable ++', function() {
        return new Op('++', $1, null, true);
      }), o('Expression ?', function() {
        return new Existence($1);
      }), o('Expression +  Expression', function() {
        return new Op('+', $1, $3);
      }), o('Expression -  Expression', function() {
        return new Op('-', $1, $3);
      }), o('Expression MATH     Expression', function() {
        return new Op($2, $1, $3);
      }), o('Expression SHIFT    Expression', function() {
        return new Op($2, $1, $3);
      }), o('Expression COMPARE  Expression', function() {
        return new Op($2, $1, $3);
      }), o('Expression LOGIC    Expression', function() {
        return new Op($2, $1, $3);
      }), o('Expression RELATION Expression', function() {
        if ($2.charAt(0) === '!') {
          return new Op($2.slice(1), $1, $3).invert();
        } else {
          return new Op($2, $1, $3);
        }
      }), o('SimpleAssignable COMPOUND_ASSIGN\
                 Expression', function() {
        return new Assign($1, $3, $2);
      }), o('SimpleAssignable COMPOUND_ASSIGN\
                 INDENT Expression OUTDENT', function() {
        return new Assign($1, $4, $2);
      }), o('SimpleAssignable COMPOUND_ASSIGN TERMINATOR\
                 Expression', function() {
        return new Assign($1, $4, $2);
      }), o('SimpleAssignable EXTENDS Expression', function() {
        return new Extends($1, $3);
      })
    ],
    Binary: function(start) {
      "Binary: Unary | Binary+Unary";
      var a, hash, m;

      hash = 'Binary' + start;
      m = memo[hash];
      if (m === null) {
        memo[hash] = rules.Unary(start);
        return rules.Binary(start);
      }
      if (text[cursor] !== '+') {
        delete memo[hash];
        return m;
      }
      cursor++;
      a = rules.Unary(cursor);
      if (a === null) {
        delete memo[hash];
        return m;
      }
      memo[hash] = m + a;
      return rules.Binary(start);
    },
    Unary: function(start) {
      "Unary: +Unary | -Unary | Atom | Atom++ | Atom--";
      var c;

      c = text[cursor];
      switch (c) {
        case '+':
          cursor++;
          if (text[cursor] === '+') {
            cursor++;
            return rules.Unary(cursor) + 1;
          } else {
            return rules.Unary(cursor);
          }
          break;
        case '-':
          cursor++;
          if (text[cursor] === '-') {
            cursor++;
            return rules.Unary(cursor) - 1;
          } else {
            return -rules.Unary(cursor);
          }
          break;
        default:
          x = rules.Atom(start);
          if (text[cursor] === '+' && text[cursor + 1] === '+') {
            cursor += 2;
            return x + 1;
          } else if (text[cursor] === '-' && text[cursor + 1] === '-') {
            cursor += 2;
            return x - 1;
          } else {
            return x;
          }
      }
    },
    Atom: function(start) {
      "Atom: 1 | ( Binary )";
      var exp;

      switch (text[cursor]) {
        case '1':
          cursor++;
          return 1;
        case '(':
          cursor++;
          exp = rules.Binary(cursor);
          match(')');
          return exp;
        case '[':
          cursor++;
          exp = rules.Expression(cursor);
          match(')');
          return exp;
      }
    }
  };

}).call(this);

/*
//@ sourceMappingURL=daoutil.map
*/
