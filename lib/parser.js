// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, SolverFail, Trail, TypeError, Var, _, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError, SolverFail = _ref.SolverFail;

  exports.char = function(solver, x, cont) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      x.bind(c, solver.trail);
      solver.state = [data, pos + 1];
      return cont(pos + 1);
    } else if (x === c) {
      solver.state = [data, pos + 1];
      return cont(pos + 1);
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return solver.failcont(pos);
      } else {
        throw new ExpressionError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.followChar = function(solver, x, cont) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      throw new TypeError(x);
    } else if (x === c) {
      return cont(pos);
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return solver.failcont(pos);
      } else {
        throw new ValueError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.notFollowChar = function(solver, x, cont) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      throw new TypeError(x);
    } else if (x === c) {
      return solver.failcont(pos);
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return cont(pos);
      } else {
        throw new ValueError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.followChars = function(solver, chars, cont) {
    var c, data, pos, trail, _ref1;

    chars = trail.deref(chars);
    if (chars instanceof Var) {
      throw new TypeError(chars);
    }
    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    c = data[pos];
    if (__indexOf.call(chars, c) >= 0) {
      return cont(pos);
    } else if (!_.isString(chars)) {
      throw new TypeError(chars);
    } else {
      return solver.failcont(pos);
    }
  };

  exports.notFollowChars = function(solver, chars, cont) {
    var c, data, pos, trail, _ref1;

    chars = trail.deref(chars);
    if (chars instanceof Var) {
      throw new TypeError(chars);
    }
    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    c = data[pos];
    if (__indexOf.call(chars, c) >= 0) {
      return solver.failcont(pos);
    } else if (!_.isString(chars)) {
      throw new TypeError(chars);
    } else {
      return cont(pos);
    }
  };

  exports.charWhen = function(solver, test, cont) {
    var c, data, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (test(c)) {
      solver.state = [data, pos + 1];
      return cont(pos);
    } else {
      return solver.failcont(pos);
    }
  };

  exports.spaces = function(solver, cont) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (c !== ' ') {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && data[p] === ' ') {
      p++;
    }
    solver.state = [data, p];
    return cont(p);
  };

  exports.spaces0 = function(solver, cont) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos >= length) {
      return pos;
    }
    c = data[pos];
    if (c !== ' ') {
      return pos;
    }
    p = pos + 1;
    while (p < length && data[p] === ' ') {
      p++;
    }
    solver.state = [data, p];
    return cont(pos);
  };

  exports.stringWhile = function(solver, test, cont) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos === length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (!test(c)) {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && test(data[p])) {
      p++;
    }
    solver.state = [data, p];
    return cont(data.slice(pos, p));
  };

  exports.stringWhile0 = function(solver, test, cont) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos === length) {
      return '';
    }
    c = data[pos];
    if (!test(c)) {
      return '';
    }
    p = pos + 1;
    while (p < length && test(data[p])) {
      p++;
    }
    solver.state = [data, p];
    return cont(data.slice(pos, p));
  };

  exports.number = exports.float = function(solver, cont) {
    var dot, length, p, pE, pos, text, value, _ref1, _ref2, _ref3, _ref4;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    p = pos;
    if (text[p] === '+' || text[p] === '-') {
      p++;
    }
    if (p >= length) {
      return solver.failcont(p);
    }
    dot = false;
    if (text[p] === '.') {
      dot = true;
      p++;
    }
    if (p >= length || text[p] < '0' || '9' < text[p]) {
      return solver.failcont(p);
    }
    p++;
    while (p < length && ('0' <= (_ref2 = text[p]) && _ref2 <= '9')) {
      p++;
    }
    if (!dot) {
      if (p < length && text[p] === '.') {
        p++;
      }
      while (p < length && ('0' <= (_ref3 = text[p]) && _ref3 <= '9')) {
        p++;
      }
    }
    if (p < length - 1 && text[p] === 'e' || text[p] === 'E') {
      p++;
      pE = p;
      if (p < length && (text[p] === '+' || text[p] === '-')) {
        p++;
      }
      if (p >= length || text[p] < '0' || '9' < text[p]) {
        p = pE - 1;
      } else {
        while (p < length && ('0' <= (_ref4 = text[p]) && _ref4 <= '9')) {
          p++;
        }
      }
    }
    value = eval(text.slice(pos, p));
    if (_.isNumber(value)) {
      solver.state = [text, p];
      return cont(value);
    } else {
      return solver.failcont(pos);
    }
  };

  exports.literal = function(solver, arg, cont) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      solver.state = [text, p];
      return cont(p);
    } else {
      return solver.failcont(p);
    }
  };

  exports.followLiteral = function(solver, arg, cont) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      return cont(p);
    } else {
      return solver.failcont(p);
    }
  };

  exports.notFollowLiteral = function(solver, arg, cont) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      return solver.failcont(p);
    } else {
      return cont(p);
    }
  };

  exports.quoteString = function(solver, cont) {
    var char, length, p, pos, quote, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    quote = text[pos];
    if (quote !== "'" && quote !== '"') {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length) {
      char = text[p];
      p++;
      if (char === '\\') {
        p++;
      } else if (char === quote) {
        solver.state = [text, p++];
        return cont(text.slice(pos, p));
      }
    }
    return solver.failcont(p);
  };

  exports.identifier = function(solver, cont) {
    var c, length, p, pos, text, _ref1;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    if (!(c === '_' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))) {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && (c = text[p] && (c === '_' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')))) {
      p++;
    }
    solver.state = [text, p];
    return cont(text.slice(pos, p));
  };

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
