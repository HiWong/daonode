// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, Trail, TypeError, Var, any1, any2, dao, defaultHash, defaultPureHash, dqstring, general, greedyany1, greedyany2, greedysome1, greedysome2, lazyany1, lazyany2, lazysome1, lazysome2, lisp, logic, name, numberTimes1Fun, numberTimes2Fun, parallelFun, solve, some1, some2, special, sqstring, times1, times1Fun, times2, times2Fun, _, _memoPureResult, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  _ = require('underscore');

  dao = require("../dao");

  logic = require("./logic");

  general = require("./general");

  lisp = require("./lisp");

  _ref = (function() {
    var _i, _len, _ref, _results;

    _ref = "Trail, solve, Var,  ExpressionError, TypeError, special".split(", ");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _results.push(dao[name]);
    }
    return _results;
  })(), Trail = _ref[0], solve = _ref[1], Var = _ref[2], ExpressionError = _ref[3], TypeError = _ref[4], special = _ref[5];

  exports.parse = special(2, 'parse', function(solver, cont, exp, state) {
    var expCont, oldState;

    oldState = null;
    expCont = solver.cont(exp, function(v) {
      solver.state = oldState;
      return [cont, v];
    });
    return function(v) {
      oldState = solver.state;
      solver.state = state;
      return expCont(v);
    };
  });

  exports.parsetext = exports.parsesequence = function(exp, sequence) {
    return exports.parse(exp, [sequence, 0]);
  };

  exports.setstate = special(1, 'setstate', function(solver, cont, state) {
    return function(v) {
      solver.state = state;
      return cont(v);
    };
  });

  exports.settext = exports.setsequence = function(sequence) {
    return exports.setstate([sequence, 0]);
  };

  exports.getstate = special(0, 'getstate', function(solver, cont) {
    return function(v) {
      return cont(solver.state);
    };
  })();

  exports.gettext = exports.getsequence = special(0, 'gettext', function(solver, cont) {
    return function(v) {
      return cont(solver.state[0]);
    };
  })();

  exports.getpos = special(0, 'getpos', function(solver, cont) {
    return function(v) {
      return cont(solver.state[1]);
    };
  })();

  exports.eoi = special(0, 'eoi', function(solver, cont) {
    return function(v) {
      var data, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return cont(true);
      } else {
        return solver.failcont(v);
      }
    };
  })();

  exports.boi = special(0, 'boi', function(solver, cont) {
    return function(v) {
      if (solver.state[1] === 0) {
        return cont(true);
      } else {
        return solver.failcont(v);
      }
    };
  })();

  exports.eol = special(0, 'eol', function(solver, cont) {
    return function(v) {
      var data, pos, text, _ref1, _ref2, _ref3;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return cont(true);
      } else {
        _ref2 = solver.state, text = _ref2[0], pos = _ref2[1];
        if (_ref3 = text[pos], __indexOf.call("\r\n", _ref3) >= 0) {
          return cont(true);
        } else {
          return solver.failcont(v);
        }
      }
    };
  })();

  exports.bol = special(0, 'bol', function(solver, cont) {
    return function(v) {
      var pos, text, _ref1, _ref2;

      if (solver.state[1] === 0) {
        return cont(true);
      } else {
        _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
        if (_ref2 = text[pos - 1], __indexOf.call("\r\n", _ref2) >= 0) {
          return cont(true);
        } else {
          return solver.failcont(v);
        }
      }
    };
  })();

  exports.step = special([0, 1], 'step', function(solver, cont, n) {
    if (n == null) {
      n = 1;
    }
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      solver.state = [text, pos + n];
      return cont(pos + n);
    };
  });

  exports.lefttext = special(0, 'lefttext', function(solver, cont) {
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      return cont(text.slice(pos));
    };
  })();

  exports.subtext = exports.subsequence = special([0, 1, 2], 'subtext', function(solver, cont, length, start) {
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      start = (start != null) || pos;
      length = (length != null) || text.length;
      return cont(text.slice(start, start + length));
    };
  });

  exports.nextchar = special(0, 'nextchar', function(solver, cont) {
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      return cont(text[pos]);
    };
  })();

  defaultPureHash = function() {
    var args, caller, name;

    name = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return (name || caller.name) + args.join(',');
  };

  exports._memoPureResult = _memoPureResult = {};

  exports.purememo = function(caller, name, hash) {
    if (name == null) {
      name = '';
    }
    if (hash == null) {
      hash = defaultPureHash;
    }
    if (!_.isString(name)) {
      hash = name;
      name = '';
    }
    return special(1, 'memo', function() {
      var args, cont, realCont, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      realCont = solver.cont(caller.apply(null, args), cont);
      return function(v) {
        var hashValue, newCont, result, _ref1;

        hashValue = hash.apply(null, [name, caller].concat(__slice.call(args)));
        if (hashValue === void 0) {
          return realCont(v);
        } else {
          if (_memoPureResult.hasOwnProperty(hashValue)) {
            return cont(_memoPureResult[hashValue]);
          } else {
            result = (_ref1 = realCont(v), newCont = _ref1[0], v = _ref1[1], _ref1);
            _memoPureResult[hashValue] = v;
            return result;
          }
        }
      };
    });
  };

  exports.clearPureMemo = special(1, 'clearPureMemo', function(solver, cont) {
    return function(v) {
      exports._memoPureResult = {};
      return cont(v);
    };
  });

  defaultHash = function() {
    var args, caller, name, solver;

    name = arguments[0], solver = arguments[1], caller = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return (name || caller.name) + solver.state[1];
  };

  exports._memoResult = {};

  exports.memo = function(caller, name, hash) {
    if (name == null) {
      name = '';
    }
    if (hash == null) {
      hash = defaultHash;
    }
    if (!_.isString(name)) {
      hash = name;
      name = '';
    }
    return special(1, 'memo', function() {
      var args, cont, realCont, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      realCont = solver.cont(caller.apply(null, args), cont);
      return function(v) {
        var result, _ref1, _ref2;

        hash = hash.apply(null, [name, solver, caller].concat(__slice.call(args)));
        if (hash === void 0) {
          return realCont(v);
        } else {
          if (exports._memoResult.hasOwnProperty(hash)) {
            _ref1 = memoResult[hash], result = _ref1[0], solver.state = _ref1[1];
            return cont(result);
          } else {
            result = (_ref2 = realCont(v), v = _ref2[0], _ref2);
            exports._memoResult[hash] = [v, solver.state];
            return result;
          }
        }
      };
    });
  };

  exports.todoclearmemo = special(1, 'clearmemo', function(solver, cont) {
    return function(v) {
      exports._memoResult = {};
      return cont(v);
    };
  });

  exports.follow = special(1, 'follow', function(solver, cont, item) {
    var itemCont, state;

    state = null;
    itemCont = solver.cont(item, function(v) {
      solver.state = state;
      return cont(v);
    });
    return function(v) {
      state = solver.state;
      return itemCont(v);
    };
  });

  exports.notfollow = special(1, 'notfollow', function(solver, cont, item) {
    var fc, itemCont, state;

    fc = state = null;
    itemCont = solver.cont(item, function(v) {
      solver.state = state;
      return fc(v);
    });
    return function(v) {
      fc = solver.failcont;
      solver.failcont = cont;
      state = solver.state;
      return itemCont(v);
    };
  });

  parallelFun = function(solver, cont, state, args) {
    var leftCont, length;

    length = args.length;
    if (length === 0) {
      return cont;
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else {
      leftCont = parallelFun(solver, cont, state, args.slice(1));
      return solver.cont(args[0], function(v) {
        solver.state = state;
        return leftCont(v);
      });
    }
  };

  exports.parallel = special(null, 'parallel', function(solver, cont, args, checkFunction) {
    var adjustCont, length, right, x, xcont, y, ycont;

    if (checkFunction == null) {
      checkFunction = function(state, baseState) {
        return state[1] === baseState[1];
      };
    }
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else {
      right = null;
      if (length === 2) {
        x = args[0];
        y = [args[1]];
      } else {
        x = args[0];
        y = args.slice(1);
      }
      adjustCont = function(v) {
        if (checkParallel(solver.state, right)) {
          return cont(v);
        } else {
          return solver.failcont(v);
        }
      };
      ycont = parallelFun(solver, adjustCont, state, y);
      xcont = solver.cont(x, function(v) {
        right = solver.state;
        solver.state = state;
        return ycont(v);
      });
      return xcont;
    }
  });

  exports.may = special(1, 'may', function(solver, cont, exp) {
    var exp_cont;

    exp_cont = solver.cont(exp, cont);
    return function(v) {
      solver.appendFailcont(cont);
      return exp_cont(v);
    };
  });

  exports.lazymay = special(1, 'lazymay', function(solver, cont, exp) {
    var expCont;

    expCont = solver.cont(exp, cont);
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return expCont(v);
      };
      return cont(v);
    };
  });

  exports.greedymay = special(1, 'greedymay', function(solver, cont, exp) {
    var expCont, fc;

    fc = null;
    expCont = solver.cont(exp, function(v) {
      solver.failcont = fc;
      return cont(v);
    });
    return function(v) {
      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return expCont(v);
    };
  });

  exports.any = function(exp, result, template) {
    if (!result) {
      return any1(exp);
    } else {
      return any2(exp, result, template);
    }
  };

  any1 = special(1, 'any', function(solver, cont, exp) {
    var anyCont, expCont;

    anyCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new dao.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, anyCont);
    return anyCont;
  });

  any2 = special(3, 'any', function(solver, cont, exp, result, template) {
    var anyCont, expCont, result1;

    result1 = null;
    anyCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new dao.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = function(v) {
          result1.pop();
          return fc(v);
        };
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return anyCont(v);
    });
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      return anyCont(v);
    };
  });

  exports.lazyany = function(exp, result, template) {
    if (!result) {
      return lazyany1(exp);
    } else {
      return lazyany2(exp, result, template);
    }
  };

  lazyany1 = special(1, 'lazyany', function(solver, cont, exp) {
    var anyCont, anyFcont, expcont, fc;

    fc = null;
    anyCont = function(v) {
      solver.failcont = anyFcont;
      return cont(v);
    };
    expcont = solver.cont(exp, anyCont);
    anyFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    return function(v) {
      fc = solver.failcont;
      return anyCont(v);
    };
  });

  lazyany2 = special(3, 'lazyany', function(solver, cont, exp, result, template) {
    var anyCont, anyFcont, expcont, fc, result1;

    result1 = fc = null;
    anyCont = function(v) {
      solver.failcont = anyFcont;
      result.bind(result1, solver.trail);
      return cont(v);
    };
    expcont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return anyCont(v);
    });
    anyFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    return function(v) {
      result1 = [];
      fc = solver.failcont;
      return anyCont(v);
    };
  });

  exports.greedyany = function(exp, result, template) {
    if (!result) {
      return greedyany1(exp);
    } else {
      return greedyany2(exp, result, template);
    }
  };

  greedyany1 = special(1, 'greedyany', function(solver, cont, exp) {
    var anyCont, expCont;

    anyCont = function(v) {
      return [expCont, v];
    };
    expCont = solver.cont(exp, anyCont);
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return anyCont(v);
    };
  });

  greedyany2 = special(3, 'greedyany', function(solver, cont, exp, result, template) {
    var anyCont, expCont, result1;

    result1 = null;
    anyCont = function(v) {
      return [expCont, v];
    };
    expCont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return anyCont(v);
    });
    return function(v) {
      var fc;

      result1 = [];
      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        result.bind(result1, solver.trail);
        return cont(v);
      };
      return anyCont(v);
    };
  });

  exports.some = function(exp, result, template) {
    if (!result) {
      return some1(exp);
    } else {
      return some2(exp, result, template);
    }
  };

  some1 = special(1, 'some', function(solver, cont, exp) {
    var expCont, someCont;

    someCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new dao.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, someCont);
    return expCont;
  });

  some2 = special(3, 'some', function(solver, cont, exp, result, template) {
    var expCont, result1, someCont;

    result1 = null;
    someCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new dao.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = function(v) {
          result1.pop();
          return fc(v);
        };
        return cont(v);
      };
      return [expCont, v];
    };
    expCont = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return someCont(v);
    });
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      return expCont(v);
    };
  });

  exports.lazysome = function(exp, result, template) {
    if (!result) {
      return lazysome1(exp);
    } else {
      return lazysome2(exp, result, template);
    }
  };

  lazysome1 = special(1, 'lazysome', function(solver, cont, exp) {
    var expcont, fc, someCont, someFcont;

    fc = null;
    someFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    someCont = function(v) {
      solver.failcont = someFcont;
      return cont(v);
    };
    expcont = solver.cont(exp, someCont);
    return function(v) {
      fc = solver.failcont;
      return expcont(v);
    };
  });

  lazysome2 = special(3, 'lazysome', function(solver, cont, exp, result, template) {
    var expcont, fc, result1, someCont, someFcont;

    result1 = fc = null;
    someFcont = function(v) {
      solver.failcont = fc;
      return [expcont, v];
    };
    someCont = function(v) {
      result1.push(solver.trail.getvalue(template));
      solver.failcont = someFcont;
      return cont(v);
    };
    expcont = solver.cont(exp, someCont);
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      fc = solver.failcont;
      return expcont(v);
    };
  });

  exports.greedysome = function(exp, result, template) {
    if (!result) {
      return greedysome1(exp);
    } else {
      return greedysome2(exp, result, template);
    }
  };

  greedysome1 = special(1, 'greedysome', function(solver, cont, exp) {
    var expCont, someCont;

    someCont = function(v) {
      return [expCont, v];
    };
    expCont = solver.cont(exp, someCont);
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return expCont(v);
    };
  });

  greedysome2 = special(3, 'greedysome', function(solver, cont, exp, result, template) {
    var expCont, result1, someCont;

    result1 = null;
    someCont = function(v) {
      result1.push(solver.trail.getvalue(template));
      return [expCont, v];
    };
    expCont = solver.cont(exp, someCont);
    return function(v) {
      var fc;

      result1 = [];
      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        result.bind(result1, solver.trail);
        return cont(v);
      };
      return expCont(v);
    };
  });

  exports.times = function(exp, expectTimes, result, template) {
    if (!result) {
      return times1(exp, expectTimes);
    } else {
      return times2(exp, expectTimes, result, template);
    }
  };

  numberTimes1Fun = function(solver, cont, exp, expectTimes) {
    var expCont, i;

    expectTimes = Math.floor(expectTimes);
    if (expectTimes < 0) {
      throw new ValueError(expectTimes);
    } else if (expectTimes === 0) {
      return cont;
    } else if (expectTimes === 1) {
      return solver.cont(exp, cont);
    } else if (expectTimes === 2) {
      expCont = solver.cont(exp, cont);
      return solver.cont(exp, expCont);
    } else {
      i = null;
      expCont = solver.cont(exp, function(v) {
        i++;
        if (i === expectTimes) {
          return cont(v);
        } else {
          return expCont(v);
        }
      });
      return function(v) {
        i = 0;
        return expCont(v);
      };
    }
  };

  times1Fun = function(solver, cont, exp, expectTimes) {
    var anyCont, expCont, expectTimes1, i;

    if (_.isNumber(expectTimes)) {
      return numberTimes1Fun(solver, cont, exp, expectTimes);
    } else {
      expectTimes1 = i = null;
      anyCont = function(v) {
        var fc, state, trail;

        fc = solver.failcont;
        trail = solver.trail;
        solver.trail = new dao.Trail;
        state = solver.state;
        solver.failcont = function(v) {
          solver.trail.undo();
          solver.trail = trail;
          solver.state = state;
          solver.failcont = function(v) {
            i--;
            return fc(v);
          };
          expectTimes1.bind(i, solver.trail);
          return cont(v);
        };
        return [expCont, v];
      };
      expCont = solver.cont(exp, function(v) {
        i++;
        return anyCont(v);
      });
      return solver.cont(expectTimes, function(v) {
        expectTimes1 = v;
        if (_.isNumber(expectTimes1)) {
          return numberTimes1Fun(solver, cont, exp, expectTimes1)(v);
        } else {
          i = 0;
          return anyCont(v);
        }
      });
    }
  };

  times1 = special(2, 'times', times1Fun);

  numberTimes2Fun = function(solver, cont, exp, expectTimes, result, template) {
    var expCont, i, result1;

    expectTimes = Math.floor(expectTimes);
    if (expectTimes < 0) {
      throw new ValueError(expectTimes);
    } else if (expectTimes === 0) {
      return function(v) {
        result.bind([], solver.trail);
        return cont(v);
      };
    } else if (expectTimes === 1) {
      return solver.cont(exp, function(v) {
        result.bind([solver.trail.getvalue(template)], solver.trail);
        return cont(v);
      });
    } else if (expectTimes === 2) {
      result1 = [];
      expCont = solver.cont(exp, function(v) {
        result1.push(solver.trail.getvalue(template));
        result.bind(result1, solver.trail);
        return cont(v);
      });
      return solver.cont(exp, function(v) {
        result1.push(solver.trail.getvalue(template));
        return expCont(v);
      });
    } else {
      result1 = i = null;
      expCont = solver.cont(exp, function(v) {
        i++;
        result1.push(solver.trail.getvalue(template));
        if (i === expectTimes) {
          result.bind(result1, solver.trail);
          return cont(v);
        } else {
          return expCont(v);
        }
      });
      return function(v) {
        i = 0;
        result1 = [];
        return expCont(v);
      };
    }
  };

  times2Fun = function(solver, cont, exp, expectTimes, result, template) {
    var anyCont, expCont, expectTimes1, i, result1;

    if (_.isNumber(expectTimes)) {
      return numberTimes2Fun(solver, cont, exp, expectTimes, result, template);
    } else {
      result1 = expectTimes1 = i = null;
      anyCont = function(v) {
        var fc, state, trail;

        fc = solver.failcont;
        trail = solver.trail;
        solver.trail = new dao.Trail;
        state = solver.state;
        solver.failcont = function(v) {
          solver.trail.undo();
          solver.trail = trail;
          solver.state = state;
          solver.failcont = function(v) {
            i--;
            result1.pop();
            return fc(v);
          };
          expectTimes1.bind(i, solver.trail);
          return cont(v);
        };
        return [expCont, v];
      };
      expCont = solver.cont(exp, function(v) {
        i++;
        result1.push(solver.trail.getvalue(template));
        return anyCont(v);
      });
      return solver.cont(expectTimes, function(v) {
        expectTimes1 = v;
        if (_.isNumber(expectTimes1)) {
          return numberTimes2Fun(solver, cont, exp, expectTimes1, result, template)(v);
        } else {
          i = 0;
          result1 = [];
          result.bind(result1, solver.trail);
          return anyCont(v);
        }
      });
    }
  };

  times2 = special(4, 'times', times2Fun);

  exports.seplist = function(exp, options) {
    var andp, bind, expectTimes, freep, getvalue, i, ifp, inc, is_, list, n, one, prependFailcont, push, pushp, result, sep, sub, succeed, template, vari;

    if (options == null) {
      options = {};
    }
    sep = options.sep || char(' ');
    expectTimes = options.times || null;
    result = options.result || null;
    template = options.template || null;
    vari = dao.vari;
    succeed = logic.succeed;
    andp = logic.andp;
    bind = logic.bind;
    is_ = logic.is_;
    freep = logic.freep;
    ifp = logic.ifp;
    prependFailcont = logic.prependFailcont;
    list = general.list;
    push = general.push;
    pushp = general.pushp;
    one = lisp.one;
    inc = general.inc;
    sub = general.sub;
    getvalue = general.getvalue;
    if (expectTimes === null) {
      if (result === null) {
        return andp(exp, any(andp(sep, exp)));
      } else {
        return andp(bind(result, []), exp, pushp(result, getvalue(template)), any(andp(sep, exp, pushp(result, getvalue(template)))));
      }
    } else if (_.isNumber(expectTimes)) {
      expectTimes = Math.floor(Math.max(0, expectTimes));
      if (result === null) {
        switch (expectTimes) {
          case 0:
            return succeed;
          case 1:
            return exp;
          default:
            return andp(exp, times(andp(sep, exp), expectTimes - 1));
        }
      } else {
        switch (expectTimes) {
          case 0:
            return bind(result, []);
          case 1:
            return andp(exp, bind(result, list(getvalue(template))));
          default:
            return andp(bind(result, []), exp, pushp(result, getvalue(template)), times(andp(sep, exp, pushp(result, getvalue(template))), expectTimes - 1));
        }
      }
    } else {
      n = vari('n');
      i = vari('i');
      if (result === null) {
        return ifp(freep(expectTimes), andp(exp, one(i), any(andp(sep, exp, inc(i))), bind(expectTimes, i)), andp(exp, is_(n, sub(expectTimes, 1)), times(andp(sep, exp), n)));
      } else {
        return andp(bind(result, []), ifp(freep(expectTimes), andp(exp, one(i), push(result, getvalue(template)), any(andp(sep, exp, push(result, getvalue(template)), inc(i), prependFailcont(function() {
          result.binding.pop();
          return i.binding--;
        }))), bind(expectTimes, i)), andp(exp, pushp(result, getvalue(template)), is_(n, sub(expectTimes, 1)), times(andp(sep, exp, pushp(result, getvalue(template))), n))));
      }
    }
  };

  exports.char = special(1, 'char', function(solver, cont, x) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return solver.failcont(v);
      }
      trail = solver.trail;
      x = trail.deref(x);
      c = data[pos];
      if (x instanceof Var) {
        x.bind(c, solver.trail);
        solver.state = [data, pos + 1];
        return cont(pos + 1);
      } else if (x === c) {
        solver.state = [data, pos + 1];
        return cont(v);
      } else if (_.isString(x)) {
        if (x.length === 1) {
          return solver.failcont(v);
        } else {
          throw new ExpressionError(x);
        }
      } else {
        throw new TypeError(x);
      }
    };
  });

  exports.followChar = special(1, 'followChar', function(solver, cont, x) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return solver.failcont(v);
      }
      trail = solver.trail;
      x = trail.deref(x);
      c = data[pos];
      if (x instanceof Var) {
        throw new TypeError(x);
      } else if (x === c) {
        return cont(pos);
      } else if (_.isString(x)) {
        if (x.length === 1) {
          return solver.failcont(v);
        } else {
          throw new ValueError(x);
        }
      } else {
        throw new TypeError(x);
      }
    };
  });

  exports.notFollowChar = special(1, 'notfollowChar', function(solver, cont, x) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return solver.failcont(v);
      }
      trail = solver.trail;
      x = trail.deref(x);
      c = data[pos];
      if (x instanceof Var) {
        throw new TypeError(x);
      } else if (x === c) {
        return solver.failcont(pos);
      } else if (_.isString(x)) {
        if (x.length === 1) {
          return cont(v);
        } else {
          throw new ValueError(x);
        }
      } else {
        throw new TypeError(x);
      }
    };
  });

  exports.followChars = special(1, 'followChars', function(solver, cont, chars) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      chars = trail.deref(chars);
      if (chars instanceof Var) {
        throw new TypeError(chars);
      }
      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return solver.failcont(v);
      }
      trail = solver.trail;
      c = data[pos];
      if (__indexOf.call(chars, c) >= 0) {
        return cont(pos);
      } else if (!_.isString(chars)) {
        throw new TypeError(chars);
      } else {
        return solver.failcont(pos);
      }
    };
  });

  exports.notFollowChars = special(1, 'notFollowChars', function(solver, cont, chars) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      chars = trail.deref(chars);
      if (chars instanceof Var) {
        throw new TypeError(chars);
      }
      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return solver.failcont(v);
      }
      trail = solver.trail;
      c = data[pos];
      if (__indexOf.call(chars, c) >= 0) {
        return solver.failcont(pos);
      } else if (!_.isString(chars)) {
        throw new TypeError(chars);
      } else {
        return cont(pos);
      }
    };
  });

  exports.charWhen = special(1, 'charWhen', function(solver, cont, test) {
    return function(v) {
      var c, data, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos >= data.length) {
        return solver.failcont(false);
      }
      c = data[pos];
      if (test(c)) {
        solver.state = [data, pos + 1];
        return cont(c);
      } else {
        return solver.failcont(c);
      }
    };
  });

  exports.charBetween = function(start, end) {
    return exports.charWhen(function(c) {
      return (start < c && c < end);
    });
  };

  exports.charIn = function(set) {
    return exports.charWhen(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digit = exports.charWhen(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digit1_9 = exports.charWhen(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lower = exports.charWhen(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.upper = exports.charWhen(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letter = exports.charWhen(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetter = exports.charWhen(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDight = exports.charWhen(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspace = exports.charIn(' \t');

  exports.whitespace = exports.charIn(' \t\r\n');

  exports.newline = exports.charIn('\r\n');

  exports.spaces = special(0, 'spaces', function(solver, cont) {
    return function(v) {
      var c, data, length, p, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      length = data.length;
      if (pos >= length) {
        return solver.failcont(false);
      }
      c = data[pos];
      if (c !== ' ') {
        return solver.failcont(c);
      }
      p = pos + 1;
      while (p < length && data[p] === ' ') {
        p++;
      }
      solver.state = [data, p];
      return cont(p - pos);
    };
  })();

  exports.spaces0 = special(0, 'spaces', function(solver, cont) {
    return function(v) {
      var c, data, length, p, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      length = data.length;
      if (pos >= length) {
        return cont(0);
      }
      c = data[pos];
      if (c !== ' ') {
        return cont(c);
      }
      p = pos + 1;
      while (p < length && data[p] === ' ') {
        p++;
      }
      solver.state = [data, p];
      return cont(p - pos);
    };
  })();

  exports.stringWhile = special(1, 'stringWhile', function(solver, cont, test) {
    return function(v) {
      var c, data, length, p, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      length = data.length;
      if (pos === length) {
        return solver.failcont(false);
      }
      c = data[pos];
      if (!test(c)) {
        return solver.failcont(c);
      }
      p = pos + 1;
      while (p < length && test(data[p])) {
        p++;
      }
      solver.state = [data, p];
      return cont(data.slice(pos, p));
    };
  });

  exports.stringBetween = function(start, end) {
    return exports.stringWhile(function(c) {
      return (start < c && c < end);
    });
  };

  exports.stringIn = function(set) {
    return exports.stringWhile(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digits = exports.stringWhile(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digits1_9 = exports.stringWhile(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lowers = exports.stringWhile(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.uppers = exports.stringWhile(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letters = exports.stringWhile(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetters = exports.stringWhile(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDights = exports.stringWhile(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspaces = exports.stringIn(' \t');

  exports.whitespaces = exports.stringIn(' \t\r\n');

  exports.newlinespaces = exports.stringIn('\r\n');

  exports.stringWhile0 = special(1, 'stringWhile0', function(solver, cont, test) {
    return function(v) {
      var c, data, length, p, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      length = data.length;
      if (pos === length) {
        return cont('');
      }
      c = data[pos];
      if (!test(c)) {
        return cont('');
      }
      p = pos + 1;
      while (p < length && test(data[p])) {
        p++;
      }
      solver.state = [data, p];
      return cont(data.slice(pos, p));
    };
  });

  exports.stringBetween0 = function(start, end) {
    return exports.stringWhile0(function(c) {
      return (start < c && c < end);
    });
  };

  exports.stringIn0 = function(set) {
    return exports.stringWhile0(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digits0 = exports.stringWhile0(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digits1_90 = exports.stringWhile0(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lowers0 = exports.stringWhile0(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.uppers0 = exports.stringWhile0(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letters0 = exports.stringWhile0(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetters0 = exports.stringWhile0(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDights0 = exports.stringWhile0(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspaces0 = exports.stringIn0(' \t');

  exports.whitespaces0 = exports.stringIn0(' \t\r\n');

  exports.newlines0 = exports.stringIn0('\r\n');

  exports.number = exports.float = special(1, 'float', function(solver, cont, arg) {
    return function(v) {
      var length, p, pos, text, value, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      if ((!'0' <= (_ref2 = text[pos]) && _ref2 <= '9') && text[pos] !== '.') {
        return solver.failcont(v);
      }
      p = pos;
      while (p < length && ('0' <= (_ref3 = text[p]) && _ref3 <= '9')) {
        p++;
      }
      if (p < length && text[p] === '.') {
        p++;
      }
      while (p < length && ('0' <= (_ref4 = text[p]) && _ref4 <= '9')) {
        p++;
      }
      if (p < length - 1 && (_ref5 = text[p], __indexOf.call('eE', _ref5) >= 0)) {
        p++;
        p++;
      }
      while (p < length && ('0' <= (_ref6 = text[p]) && _ref6 <= '9')) {
        p++;
      }
      if (text[{
        pos: p
      }] === '.') {
        return solver.failcont(v);
      }
      arg = solver.trail.deref(arg);
      value = eval(text[{
        pos: p
      }]);
      if (arg instanceof Var) {
        arg.bind(value, solver.trail);
        solver.state = [data, p];
        return cont(value);
      } else {
        if (_.isNumber(arg)) {
          if (arg === value) {
            solver.state = [data, p];
            return cont(arg);
          } else {
            return solver.failcont(v)(s);
          }
        } else {
          throw new exports.TypeError(arg);
        }
      }
    };
  });

  exports.literal = special(1, 'literal', function(solver, cont, arg) {
    return function(v) {
      var i, length, length2, p, pos, text, _ref1;

      arg = solver.trail.deref(arg);
      if (arg instanceof Var) {
        throw new exports.TypeError(arg);
      }
      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      i = 0;
      p = pos;
      length2 = arg.length;
      while (i < length2 && p < length && arg[i] === text[p]) {
        i++;
        p++;
      }
      if (i === length2) {
        solver.state = [text, p];
        return cont(p);
      } else {
        return solver.failcont(p);
      }
    };
  });

  exports.followLiteral = special(1, 'followLiteral', function(solver, cont, arg) {
    return function(v) {
      var i, length, length2, p, pos, text, _ref1;

      arg = solver.trail.deref(arg);
      if (arg instanceof Var) {
        throw new exports.TypeError(arg);
      }
      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      i = 0;
      p = pos;
      length2 = arg.length;
      while (i < length2 && p < length && arg[i] === text[p]) {
        i++;
        p++;
      }
      if (i === length2) {
        return cont(p);
      } else {
        return solver.failcont(p);
      }
    };
  });

  exports.notFollowLiteral = special(1, 'followLiteral', function(solver, cont, arg) {
    return function(v) {
      var i, length, length2, p, pos, text, _ref1;

      arg = solver.trail.deref(arg);
      if (arg instanceof Var) {
        throw new exports.TypeError(arg);
      }
      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      i = 0;
      p = pos;
      length2 = arg.length;
      while (i < length2 && p < length && arg[i] === text[p]) {
        i++;
        p++;
      }
      if (i === length2) {
        return solver.failcont(p);
      } else {
        return cont(p);
      }
    };
  });

  exports.quoteString = special(1, 'quoteString', function(solver, cont, quote) {
    return function(v) {
      var char, length, p, pos, string, text, _ref1;

      string = '';
      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      quote = solver.trail.deref(quote);
      if (arg instanceof Var) {
        throw new exports.TypeError(arg);
      }
      if (text[pos] !== quote) {
        return solver.failcont(v);
      }
      p = pos + 1;
      while (p < length) {
        char = text[p];
        p++;
        if (char === '\\') {
          p++;
        } else if (char === quote) {
          string = text.slice(pos + 1, p);
          break;
        }
      }
      if (p === length) {
        return solver.failcont(v);
      }
      solver.state = [data, p];
      return cont(string);
    };
  });

  dqstring = exports.quoteString('"');

  sqstring = exports.quoteString("'");

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
