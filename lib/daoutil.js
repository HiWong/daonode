// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, StateMachine, TOKEN_ADD, TOKEN_ADD2, TOKEN_AND, TOKEN_ARROW, TOKEN_BACKQUOTE, TOKEN_BACKQUOTE2, TOKEN_BACKQUOTE3, TOKEN_BITNOT, TOKEN_BITXOR, TOKEN_BLOCKCOMMENTBEGIN, TOKEN_CASE, TOKEN_CATCH, TOKEN_CLASS, TOKEN_COLON, TOKEN_COLONEQ, TOKEN_CONTINUE, TOKEN_DEBUGGER, TOKEN_DEFAULT, TOKEN_DELETE, TOKEN_DIV, TOKEN_DO, TOKEN_DOT, TOKEN_DOT2, TOKEN_DOT3, TOKEN_DOUBLEQUOTE, TOKEN_DOUBLEQUOTE2, TOKEN_DOUBLEQUOTE3, TOKEN_ELSE, TOKEN_EQ, TOKEN_EQ2, TOKEN_EQ3, TOKEN_FINALLY, TOKEN_FUNCTION, TOKEN_GE, TOKEN_GT, TOKEN_IF, TOKEN_IN, TOKEN_INSTANCEOF, TOKEN_LBRACE, TOKEN_LBRACKET, TOKEN_LE, TOKEN_LET, TOKEN_LINECOMMENTBEGIN, TOKEN_LOGICAND, TOKEN_LOGICNOT, TOKEN_LOGICOR, TOKEN_LOOP, TOKEN_LPAREN, TOKEN_LSHIFT, TOKEN_LT, TOKEN_MUL, TOKEN_NE, TOKEN_NEW, TOKEN_NOT, TOKEN_OR, TOKEN_PASS, TOKEN_QUOTE, TOKEN_QUOTE2, TOKEN_QUOTE3, TOKEN_RBRACE, TOKEN_RETURN, TOKEN_RPAREN, TOKEN_RSHIFT, TOKEN_SEMICOLON, TOKEN_SUB, TOKEN_SUB2, TOKEN_SWITCH, TOKEN_THIS, TOKEN_THROW, TOKEN_TRY, TOKEN_TYPEOF, TOKEN_UNTIL, TOKEN_VAR, TOKEN_VOID, TOKEN_WHEN, TOKEN_WHILE, TOKEN_WITH, Trail, TypeError, Var, util, _i, _ref, _ref1, _results,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  util = require("./util");

  _ref1 = (function() {
    _results = [];
    for (_i = 1; _i <= 255; _i++){ _results.push(_i); }
    return _results;
  }).apply(this), TOKEN_BLOCKCOMMENTBEGIN = _ref1[0], TOKEN_LINECOMMENTBEGIN = _ref1[1], TOKEN_QUOTE = _ref1[2], TOKEN_QUOTE2 = _ref1[3], TOKEN_QUOTE3 = _ref1[4], TOKEN_DOUBLEQUOTE = _ref1[5], TOKEN_DOUBLEQUOTE2 = _ref1[6], TOKEN_DOUBLEQUOTE3 = _ref1[7], TOKEN_BACKQUOTE = _ref1[8], TOKEN_BACKQUOTE2 = _ref1[9], TOKEN_BACKQUOTE3 = _ref1[10], TOKEN_LPAREN = _ref1[11], TOKEN_RPAREN = _ref1[12], TOKEN_LBRACKET = _ref1[13], TOKEN_RPAREN = _ref1[14], TOKEN_LBRACE = _ref1[15], TOKEN_RBRACE = _ref1[16], TOKEN_COLON = _ref1[17], TOKEN_SEMICOLON = _ref1[18], TOKEN_DOT = _ref1[19], TOKEN_DOT2 = _ref1[20], TOKEN_DOT3 = _ref1[21], TOKEN_ARROW = _ref1[22], TOKEN_EQ = _ref1[23], TOKEN_EQ2 = _ref1[24], TOKEN_EQ3 = _ref1[25], TOKEN_NE = _ref1[26], TOKEN_GT = _ref1[27], TOKEN_GE = _ref1[28], TOKEN_LE = _ref1[29], TOKEN_LT = _ref1[30], TOKEN_COLONEQ = _ref1[31], TOKEN_ADD = _ref1[32], TOKEN_ADD2 = _ref1[33], TOKEN_SUB = _ref1[34], TOKEN_SUB2 = _ref1[35], TOKEN_MUL = _ref1[36], TOKEN_DIV = _ref1[37], TOKEN_LSHIFT = _ref1[38], TOKEN_RSHIFT = _ref1[39], TOKEN_BITNOT = _ref1[40], TOKEN_BITXOR = _ref1[41], TOKEN_LOGICNOT = _ref1[42], TOKEN_LOGICAND = _ref1[43], TOKEN_LOGICOR = _ref1[44], TOKEN_IF = _ref1[45], TOKEN_ELSE = _ref1[46], TOKEN_SWITCH = _ref1[47], TOKEN_THIS = _ref1[48], TOKEN_CLASS = _ref1[49], TOKEN_RETURN = _ref1[50], TOKEN_PASS = _ref1[51], TOKEN_TRY = _ref1[52], TOKEN_CATCH = _ref1[53], TOKEN_FINALLY = _ref1[54], TOKEN_WHILE = _ref1[55], TOKEN_UNTIL = _ref1[56], TOKEN_DO = _ref1[57], TOKEN_WHEN = _ref1[58], TOKEN_LET = _ref1[59], TOKEN_CASE = _ref1[60], TOKEN_DEBUGGER = _ref1[61], TOKEN_DEFAULT = _ref1[62], TOKEN_DELETE = _ref1[63], TOKEN_IN = _ref1[64], TOKEN_INSTANCEOF = _ref1[65], TOKEN_NEW = _ref1[66], TOKEN_THROW = _ref1[67], TOKEN_FUNCTION = _ref1[68], TOKEN_CONTINUE = _ref1[69], TOKEN_VOID = _ref1[70], TOKEN_VAR = _ref1[71], TOKEN_WITH = _ref1[72], TOKEN_TYPEOF = _ref1[73], TOKEN_LOOP = _ref1[74], TOKEN_AND = _ref1[75], TOKEN_NOT = _ref1[76], TOKEN_OR = _ref1[77];

  exports.binaryOperator = function(solver, cont) {
    var c, c1, length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        solver.parsercursor = pos + 1;
        return cont(util.ADD);
      case '-':
        solver.parsercursor = pos + 1;
        return cont(util.SUB);
      case '*':
        solver.parsercursor = pos + 1;
        return cont(util.MUL);
      case '/':
        solver.parsercursor = pos + 1;
        return cont(util.DIV);
      case '%':
        solver.parsercursor = pos + 1;
        return cont(util.MOD);
      case '=':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.EQ);
        } else {
          return solver.failcont(pos);
        }
        break;
      case '!':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.NE);
        } else {
          return solver.failcont(pos);
        }
        break;
      case '>':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.GE);
        } else if (c1 === '>') {
          solver.parsercursor = pos + 2;
          return cont(util.RSHIFT);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.gt);
        }
        break;
      case '<':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.le);
        } else if (c1 === '<') {
          solver.parsercursor = pos + 2;
          return cont(util.LSHIFT);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.lt);
        }
    }
  };

  exports.unaryOperator = function(solver, cont) {
    var c, c1, length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.INC);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.pos);
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.DEC);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.NEG);
        }
        break;
      case '!':
        solver.parsercursor = pos + 1;
        return cont(util.NOT);
      case '~':
        solver.parsercursor = pos + 1;
        return cont(util.BITNOT);
      default:
        return solver.failcont(pos);
    }
  };

  exports.suffixOperator = function(solver, cont) {
    var c, c1, length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.INC);
        } else {
          return solver.failcont(pos);
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.DEC);
        } else {
          return solver.failcont(pos);
        }
        break;
      default:
        return solver.failcont(pos);
    }
  };

  exports.program = function(solver, cont) {
    var length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return cont(null);
    } else {
      return programBody(solver, cont);
    }
  };

  exports.programBody = function(solver, cont) {
    var exps, pos, stmt, text, _ref2;

    exps = [];
    while (1) {
      stmt = statement(solver, cont);
      if (stmt[0] === sexpression.COMMENT) {
        continue;
      }
      _ref2 = solver.state, text = _ref2[0], pos = _ref2[1];
      if (pos === text.length) {
        break;
      }
    }
    if (exps.length === 0) {
      return null;
    } else {
      exps.unshift(sexpression.BEGIN);
      return exps;
    }
  };

  exports.statement = function(solver, cont) {
    var exp, token;

    solver.token = token = readStartToken(solver, cont);
    switch (token) {
      case SYM_RETURN:
        exp = expression(solver, cont);
        return [util.RETURN, exp];
      case SYM_PASS:
        passStatement(solver, cont);
        return void 0;
      case SYM_BLOCKCOMMENT:
        return blockComment(solver, cont);
      case SYM_LINECOMMENT:
        return lineComment(solver, cont);
      case SYM_IF:
        return orp(andp(testExpression(solver, cont)));
      default:
        return expression(solver, cont);
    }
  };

  exports.expression = function(solver, cont) {
    return assignExpr(solver, cont);
  };

  StateMachine = (function() {
    var add, constructor, match;

    function StateMachine() {}

    constructor = function(items) {
      var item, _j, _len, _results1;

      if (items == null) {
        items = [];
      }
      this.index = 0;
      this.stateMap = {};
      this.stateMap[0] = {};
      this.tagMap = {};
      _results1 = [];
      for (_j = 0, _len = items.length; _j < _len; _j++) {
        item = items[_j];
        _results1.push(this.add(item[0], item[1]));
      }
      return _results1;
    };

    add = function(word, tag) {
      var c, length, newState, state, _j, _len, _ref2;

      length = word.length;
      _ref2 = word.slice(0, length - 1);
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        c = _ref2[_j];
        if (__indexOf.call(this.stateMap[state], c) >= 0) {
          state = Math.abs(this.stateMap[state][c]);
        } else {
          newState = this.index++;
          this.stateMap[state][c] = newState;
          this.stateMap[newState] = {};
          state = newState;
        }
      }
      c = word[-1];
      if (__indexOf.call(this.stateMap[state], c) >= 0) {
        if (this.stateMap[state][c] > 0) {
          return this.stateMap[state][c] = -this.stateMap[state][c];
        }
      } else {
        newState = this.new_state++;
        this.stateMap[state][c] = -newState;
        this.stateMap[newState] = {};
        return this.tagMap[newState] = tag;
      }
    };

    match = function(text, i) {
      var c, length, state, succeedState;

      state = 0;
      succeedState;
      length = string.length;
      while (i < length) {
        c = text[i];
        state = this.stateMap[state][c];
        if (state === null) {
          if (succeedState) {
            return this.tagMap[succeedState];
          } else {
            return null;
          }
        } else if (state < 0) {
          i++;
          state = -state;
          succeedState = state;
        }
      }
    };

    return StateMachine;

  })();

}).call(this);

/*
//@ sourceMappingURL=daoutil.map
*/
