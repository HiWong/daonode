''' some basic utilities for solve dao expression.'''

'''code for compilation:
alpha convert
-> cps convert
-> optimize
-> tail recursive convert
-> javascriptize
-> generate code
'''

I = require 'utils'
I.at "solvebase.Solutions compile.compileToJSFile"
I.use "compilebase: Environment, Compiler"
I.at "command.element"
I.use "compilebase: CompileTypeError, VariableNotBound, import_names"
il = I.from "dao: interlang"

prelude = '''
          # generated file from compiled daonode expression.
          from dao.builtins import *
          from dao.command import LogicVar as DaoLogicVar
          from dao.command import Var as DaoVar
          from dao.solvebase import Solver, NoSolution
          from dao.solvebase import deref, get_value, LogicVar, DummyVar
          from dao.solvebase import Cons, nil
          from dao.solvebase import UnquoteSplice, ExpressionWithCode
          from dao.solvebase import Macro, MacroFunction, MacroRules
          from dao.solve import eval as eval_exp
          from dao.command import BuiltinFunctionCall
          from dao import interlang as il
          '''

if import_names
  prelude += "from dao.compilebase import %s\n"%', '.join(import_names)
  prelude += '\nsolver = Solver()\n\n'

compile_to_pyfile = (exp, env) ->
  code = compile_to_python(exp, env)
  file = open('f:\dao_all\dao\dao\tests\compiled.py', 'w')
  file.write(code)
  file.close()

compile_to_python = (exp, env, done=None) ->
  '''assemble steps from dao expression to python code'''
  original_exp = exp
  compiler = Compiler()
  if done is None then done = il.Done(compiler.new_variableiable(il.ConstLocalVar('v')))
  compiler.exit_block_cont_map = {}
  compiler.continue_block_cont_map = {}
  compiler.protect_cont = done
  if env is None then env = Environment()
  exp = element(exp)
  exp = exp.alpha(env, compiler)
  exp = exp.cps(compiler, done)
  exp.analyse(compiler)
  env = Environment()
  exp = exp.optimize(env, compiler)
  #exp = exp.tail_recursive_convert()
  fun = compiler.new_variableiable(il.ConstLocalVar('compiled_dao_fun'))
  exp = il.Function(fun(), exp)
  exp = il.begin(exp.pythonize(env, compiler)[0])
  if isinstance(exp, il.Begin)
    exp = exp.statements[0]
  exp.body = exp.body.replace_return_with_pyyield()
  compiler = Compiler()
  result = exp.to_code(compiler)
  return prelude + result

solve = (exp, env) ->
  compileToJSFile exp, env
  compiled = require '../bin/compiled'
  Solutions(exp, compiled.fun())

evald = (exp, env) ->  solve(exp, env).next()

class BaseCommand

class DaoStopIteration  extends Exception

class DaoUncaughtThrow  extends Exception
  constructor: (@tag) ->

class  DaoSyntaxError  extends Exception

class DaoError  extends Exception
  constructor: (@message) ->
  toString: () -> @message

class NoSolution
  constructor: (@exp) ->
  toString: () -> @exp.toString()

class Solutions
  constructor: (@exp, @solutions) ->
  next: () ->
    try @solutions.next()
    catch StopIteration
      throw NoSolution(@exp)

class Bindings extends dict
  __getitem__:  (variable) ->
    try return dict.__getitem__(variable)
    catch e then return variable

  __setitem__: (variable, value) -> dict.__setitem__(variable, value)

  __delitem__: (variable) ->
    try dict.__delitem__(variable)
    catch e then KeyError ->

  copy() -> Bindings(dict.copy())

  deref(exp, bindings) ->
    try exp_deref = exp.deref
    catch e then return exp
    exp_deref(bindings)

  get_value(exp, memo, bindings) ->
    try exp_getvalue = exp.getvalue
    catch e then return exp
    return exp_getvalue(memo, bindings)

class LogicVar extends object
  constructor: (@name) ->

  deref(bindings) ->
    # todo:
    # how to shorten the binding chain? need to change solver.fail_cont.
    # deref(solver) can help
    while 1
      next = bindings[@]
      if not isinstance(next, LogicVar) or next==@
        return next
      else result = next

  getvalue(memo, bindings) ->
    try return memo[@]
    catch e
      result = LogicVar.deref(bindings)
      if isinstance(result, LogicVar)
        memo[@] = result
        return result
      try result_getvalue = result.getvalue
      catch e
        memo[@] = result
        return result
      return result_getvalue(memo, bindings)

  unify(x, y, solver) ->
    solver.bindings[x] = y
    return true

  __eq__: (x, y) -> x.__class__==y.__class__ and x.name==y.name
  __hash__: () ->  hash(@name)
  toString: () ->  "%s"%@name

class DummyVar extends LogicVar
  deref: (bindings) -> @

class Cons
  constructor: (@head, @tail) ->

  unify(other, solver) ->
    if @__class__!=other.__class__
      return solver.fail_cont(false)
    if solver.unify(@head, other.head)
      if solver.unify(@tail, other.tail)
        return true
    return solver.fail_cont(false)

  match(other) ->
    if @__class__!=other.__class__ then return false
    return match(@head, other.head) and match(@tail, other.tail)

  unify_rule_head(other, env, subst) ->
    if @__class__!=other.__class__ then return
    for _ in unify_rule_head(@head, other.head, env, subst)
      for _ in unify_rule_head(@tail, other.tail, env, subst)
        pyyield true

  copy_rule_head(env) ->
    head = copy_rule_head(@head, env)
    tail = copy_rule_head(@tail, env)
    if head==@head and tail==@tail then return @
    return Cons(head, tail)

  getvalue(memo, env) ->
    head = get_value(@head, memo, env)
    tail = get_value(@tail, memo, env)
    return Cons(head, tail)

  take_value(env) ->
    head = take_value(@head, env)
    tail = take_value(@tail, env)
    if head==@head and tail==@tail then return @
    return Cons(head, tail)

  copy(memo) ->  Cons(copy(@head, memo), copy(@tail, memo))

  closure(env) ->
    head = closure(@head, env)
    tail = closure(@tail, env)
    if head==@head and tail==@tail
      return @
    return Cons(head, tail)

  __eq__(other) ->  @__class__==other.__class__ and @head==other.head and @tail==other.tail

  __iter__() ->
    tail = @
    while 1
      pyyield tail.head
      if tail.tail is nil then return
      else if isinstance(tail.tail, Cons)
        tail = tail.tail
      else
        pyyield tail.tail
        return
  __len__ = () ->  len([e for e in @])
  toString: () ->  "L(#{' '.join([repr(e) for e in @])})"

cons = Cons

class Nil
  alpha(env, compiler) -> il.Nil()

  __len__ = () ->  0

  __iter__() -> if 0 then pyyield

  toString: () ->  'nil'

nil = Nil()

conslist(elements...) ->
  result = nil
  for term in reversed(elements)
    result = Cons(term, result)
  return result

cons2tuple:(item) ->
  if not isinstance(item, Cons) and not isinstance(item, list)  and not isinstance(item, tuple)
    return item
  return tuple(cons2tuple(x) for x in item)

class UnquoteSplice
  constructor: (Qitem) ->

  toString: () ->  ',@%s'%@item

class ExpressionWithCode
  constructor: (@exp, @fun) ->
  __eq__(x, y) ->  (x.__class__==y.__class__ and x.exp==y.exp) or x.exp==y

  __iter__() ->  iter(@exp)

  toString: () -> repr(@exp)

class Macro

class MacroFunction extends Macro
  constructor: (@fun) ->

  __call__(args...) ->  @fun(args...)

class MacroRules extends Macro
  constructor: (@fun) ->

  __call__(args...) -> @fun(args...)

  default_end_cont(v) -> throw NoSolution(v)

class Solver
  constructor: () ->
    @bindings = Bindings() # for logic variableiableiable, unify
    @parse_state = None
    @catch_cont_map = {}
    @cut_cont = @cut_or_cont = @fail_cont = default_end_cont

  unify: (x, y) ->
    x = deref(x, @bindings)
    y = deref(y, @bindings)
    try  x_unify = x.unify
    catch e
      try  y_unify = y.unify
      catch e
        if x is y then return true
      return @fail_cont(false)
    return y_unify(x, @)
    return x_unify(y, @)

  find_catch_cont: (tag) ->
    try cont_stack = @catch_cont_map[tag]
    catch e then throw DaoUncaughtThrow(tag)
    return cont_stack.pop()

class CompileError extends Exception

class CompileTypeError  extends CompileError
  constructor:(@exp) ->
  toString: () -> '%s'%repr(@exp)

class ArityError extends CompileError

class VariableNotBound extends CompileError
  constructor:(@variable) ->
  toString: () -> '%s'%repr(@variable)

class DaoNotImplemented extends CompileError
  constructor:(@message) ->
  toString: () -> @message

class Environment
    '''environment for compile, especilly for alpha convert, block/exit/continue'''
    constructor:(@outer) -> @bindings = {}
    extend: () -> Environment()

    __getitem__: (variable) ->
      try  return @bindings[variable]
      catch e
        result = @outer
        while result is not None
          try return @bindings[variable]
          catch e then result = @outer
        throw new VariableNotBound(variable)

    __setitem__: (variable, value) ->  @bindings[variable] = value

    toString: () ->
      result = ''
      while x isnt None
        result += repr(@bindings)
        x = @outer
      return result

class Compiler
  constructor:(indent_space='  ', language='python') ->
    @newvariable_map = {} #{'name':index}

    # for block/exit/continue
    @block_label_stack = []
    @exit_block_cont_map = {}
    @next_block_cont_map = {}

    # for optimization
    @ref_count = {} # variable's reference count
    @called_count = {} # lambda's reference count
    @occur_count = {}
    @recursive_call_path = []

    @lamda_stack = []
    @recusive_variables_stack = [set()]

    # for code generation
    @language = language # object language
    @indent_space = indent_space # indent width for python code

  new_variable: (variable) ->
    try
      suffix = str(@newvariable_map[variable.name])
      @newvariable_map[variable.name] += 1
      return variable.__class__(variable.name+suffix)
    catch e
      @newvariable_map[variable.name] = 1
      return variable

  get_inner_block_label: () ->
    if @block_label_stack
      return @block_label_stack[-1][1]
    else
      throw make_new  BlockError("should not escape from top level outside of all block.")

  get_block_label: (old_label) ->
    for i in range(len(@block_label_stack))
      if old_label==@block_label_stack[-(i+1)][0]
        return @block_label_stack[-(i+1)][1]
      throw BlockError("Block %s is not found."%old_label)

  indent: (code, level=1) ->
    '''python's famous indent'''
    lines = code.split('\n')
    lines = tuple(@indent_space*level + line for line in lines)
    return '\n'.join(lines)

MAX_EXTEND_CODE_SIZE = 10

import_names = []

register_fun(name, fun) ->
  name = new_func_name(name)
  fun.func_name = name
  globals()[name] = fun
  import_names.append(name)
  return fun

new_func_name_map = {}

new_func_name(name) ->
  try
    suffix = str(new_func_name_map[name])
    new_func_name_map[name] += 1
    return name+suffix
  catch e
    new_func_name_map[name] = 1
    return name

#from dao.compilebase import CompileTypeError, VariableNotBound
#import dao.interlang as il

element = (exp)->
  if isinstance(exp, Element) then exp
  else
    try type_map[type(exp)](exp)
    catch e then throw make_new CompileTypeError(exp)

class Atom extends Element
  constructor: (@item) ->
  alpha: (env, compiler) -> @
  cps: (compiler, cont) ->  cont(@interlang())
  quasiquote: (compiler, cont) -> cont(@interlang())
  subst: (bindings) -> @
  interlang: ( ) ->  il.Atom(@item)
  __eq__: (x, y) ->  x.__class__==y.__class__ and x.item==y.item
  to_code: (compiler) -> "#{@__class__.__name__}(#{@item})"
  toString: ( ) ->  '%s'%@item

class Integer extends Atom
  __eq__(x, y) -> Atom.__eq__(x, y) or (isinstance(y, int) and x.item==y)
  interlang: ( ) -> il.Integer(@item)

class Float extends Atom
  __eq__: (x, y) -> Atom.__eq__(x, y) or (isinstance(y, float) and x.item==y)
  interlang: ( ) ->  il.Float(@item)

class String extends Atom
  __eq__: (x, y) ->  Atom.__eq__(x, y) or (isinstance(y, str) and x.item==y)
  interlang: ( ) ->  il.String(@item)

class List extends Atom
  __eq__: (x, y) ->  Atom.__eq__(x, y) or (isinstance(y, list) and x.item==y)
  interlang: ( ) -> il.List(@item)

class Dict extends Atom
  __eq__: (x, y) ->  Atom.__eq__(x, y) or (isinstance(y, dict) and x.item==y)
  interlang: ( ) ->  il.Dict(@item)

class Bool extends Atom
  __eq__: (x, y) ->  Atom.__eq__(x, y) or (isinstance(y, bool) and x.item==y)
  interlang: ( ) ->  il.Bool(@item)

class Symbol extends Atom
  __eq__: (x, y) ->  classeq(x, y) and x.item==y.item
  interlang: ( ) ->  il.Symbol(@item)

class Klass extends Atom
  toString: ( ) ->  'Klass(%s)'%(@item)
  interlang: ( ) ->  il.Klass(@item)

class PyFunction extends Atom
  toString: ( ) ->  'PyFunction(%s)'%(@item)
  interlang: ( ) ->  il.PyFunction(@item)

TRUE = Bool(true)
FALSE = Bool(false)
NONE = Atom(None)

make_tuple(value) -> Tuple(tuple(element(x) for x in value)...)

class Tuple extends Atom
  constructor: (items...)-> @item = items
  interlang: ( ) ->  il.Tuple(tuple(x.interlang() for x in @item)...)
  to_code(compiler) -> "#{@__class__.__name__}(#{', '.join([repr(x) for x in @item])})"
  __iter__: ( ) ->  iter(@item)
  toString: ( ) ->  "#{@__class__.__name__}(#{@item})"

class Var extends Element
  constructor: (@name) ->
  __call__: (args...) -> Apply(tuple(element(arg) for arg in args))
  alpha: (env, compiler) -> env[@]
  subst: (bindings) ->
    try bindings[@]
    catch e then return @
  cps: (compiler, cont) -> cont(@interlang())
  cps_convert_unify: (x, y, compiler, cont) ->
    try y.cps_convert_unify
    catch e
      x = x.interlang()
      y = y.interlang()
      x1 = compiler.new_var(il.ConstLocalVar(x.name))
      return il.begin(
                       il.Assign(x1, il.Deref(x)), #for LogicVar, could be optimized when generate code.
                       il.If(il.IsLogicVar(x1),
                             il.begin(il.SetBinding(x1, y),
                                      il.append_failcont(compiler, il.DelBinding(x1)),
                                      cont(il.TRUE)),
                             il.If(il.Eq(x1, y), cont(il.TRUE), il.failcont(il.TRUE))))
    x = x.interlang()
    y = y.interlang()
    x1 = compiler.new_var(il.ConstLocalVar(x.name))
    y1 = compiler.new_var(il.ConstLocalVar(y.name))
    return il.begin(
                     il.Assign(x1, il.Deref(x)), #for LogicVar, could be optimized when generate code.
                     il.Assign(y1, il.Deref(y)),
                     il.If(il.IsLogicVar(x1),
                           il.begin(il.SetBinding(x1, y1),
                                    il.append_failcont(compiler, il.DelBinding(x1)),
                                    cont(il.TRUE)),
                           il.begin(
                                     il.If(il.IsLogicVar(y1),
                                           il.begin(il.SetBinding(y1, x1),
                                                    il.append_failcont(compiler, il.DelBinding(y1)),
                                                    cont(il.TRUE)),
                                           il.If(il.Eq(x1, y1), cont(il.TRUE), il.failcont(il.TRUE))))))

  cps_call: (compiler, cont, args) ->
    # see The 90 minute Scheme to C compiler by Marc Feeley
    throw make_new CompileTypeError(@)

    fun = compiler.new_var(il.ConstLocalVar('fun'))
    vars = tuple(compiler.new_var(il.ConstLocalVar('a'+repr(i))) for i in range(len(args)))
    body = il.Apply(fun, [cont]+vars)
    for var1, item in reversed(zip(vars, args))
      body = item.cps(compiler, il.clamda(var1, body))
      v = compiler.new_var(il.ConstLocalVar('v'))
      macro_args1 = tuple(il.ExpressionWithCode(arg, il.Lamda([], arg.cps(compiler, il.clamda(v, v))))  for arg in args)
      macro_args2 = il.macro_args macro_args1
    return @cps(compiler, il.clamda(fun,
                                    il.If(il.IsMacro(fun),
                                          il.If(il.IsMacroRules(fun),
                                                il.Apply(fun, [cont, macro_args2]),
                                                il.Apply(fun, [cont]+macro_args1)),
                                          body)))

  interlang: ( ) ->  il.Var(@name)
  free_vars: ( ) ->  set([@])
  to_code(compiler) -> "DaoVar('%s')"%@name
  __eq__: (x, y) ->  classeq(x, y) and x.name==y.name
  hash: ( ) ->  hash(@name)
  toString: ( ) ->  "#{@__class__.__name__}('#{@name}')"

class Const extends Var
  interlang: ( ) ->  il.ConstLocalVar(@name)

class LamdaVar extends Var
  cps_call:(compiler, cont, args) ->
    #fun = compiler.new_var(il.ConstLocalVar('fun'))
    fun = @interlang()
    vars = tuple(compiler.new_var(il.ConstLocalVar('a'+repr(i)))  for i in range(len(args)))
    body = il.Apply(fun, [cont]+vars)
    for var1, item in reversed(zip(vars, args))
      body = item.cps(compiler, il.clamda(var1, body))
    v = compiler.new_var(make_new il.ConstLocalVar('v'))
    return @cps(compiler, il.clamda(fun,body))

class MacroVar extends Var
  cps_call:(compiler, cont, args) ->
    fun = @interlang()
    k = compiler.new_var(il.ConstLocalVar('cont'))
    v = compiler.new_var(il.ConstLocalVar('v'))
    #macro_args = tuple(il.Lamda((), arg.cps(compiler, il.clamda(v, v)))
    #for arg in args)
    macro_args = tuple(il.Lamda([k], arg.cps(compiler, k)) for arg in args)
    return @cps(compiler, il.clamda(fun, il.Apply(fun, [cont]+macro_args)))

class ConstLamdaVar extends LamdaVar #, Const)
  interlang: ( ) ->  il.ConstLocalVar(@name)

class ConstMacroVar extends MacroVar #, Const):
  interlang: ( ) ->  il.ConstLocalVar(@name)

class RecursiveFunctionVar extends ConstLamdaVar
  interlang: ( ) ->  il.RecursiveVar(@name)

class RecursiveMacroVar extends ConstMacroVar
  interlang: ( ) ->  il.RecursiveVar(@name)

class LogicVar extends Var
  alpha(env, compiler) -> @
  interlang: ( ) ->  il.LogicVar(@name)
  cps(compiler, cont) -> cont(il.LogicVar(@name))
  to_code(compiler) -> "DaoLogicVar('%s')"%@name
  __eq__: (x, y) ->  classeq(x, y) and x.name==y.name
  toString: ( ) ->  "DaoLogicVar('%s')"%@name

class DummyVar extends LogicVar
  interlang: ( ) ->  il.DummyVar(@name)
  cps(compiler, cont) -> cont(il.Deref(il.DummyVar(@name)))
  to_code(compiler) -> "DaoDummyVar('%s')"%@name
  cons(head, tail) -> Cons(element(head), element(tail))

class Cons extends Element
  constructor: (@head, @tail) ->

  alpha(env, compiler) -> Cons(@head.alpha(env, compiler),
                               @tail.alpha(env, compiler))

  cps(compiler, cont) -> cont(@interlang())
  interlang: ( ) ->  il.Cons(@head.interlang(), @tail.interlang())
  cps_convert_unify(x, y, compiler, cont) -> cps_convert_unify(x, y, compiler, cont)

  unify_rule_head(other, env, subst) ->
    if @__class__!=other.__class__ then return
    for _ in unify_rule_head(@head, other.head, env, subst)
      for _ in unify_rule_head(@tail, other.tail, env, subst)
        pyield true

  copy_rule_head(env) ->
    head = copy_rule_head(@head, env)
    tail = copy_rule_head(@tail, env)
    if head==@head and tail==@tail then return @
    return Cons(head, tail)

  getvalue(env) ->
    head = getvalue(@head, env)
    tail = getvalue(@tail, env)
    if head==@head and tail==@tail
      return @
    return Cons(head, tail)

  copy(memo) -> Cons(copy(@head, memo), copy(@tail, memo))

  __eq__(other) -> @__class__==other.__class__ and @head==other.head and @tail==other.tail

  __iter__: ( ) ->
    tail = @
    while 1
      pyield tail.head
      if tail.tail is nil then return
      else if isinstance(tail.tail, Cons)
        tail = tail.tail
      else
        pyield tail.tail
        return

  __len__: ( ) ->  len([e for e in @])

  toString: ( ) ->  "L(#{' '.join([repr(e) for e in @])})"

class Nil extends Element
  alpha(env, compiler) -> @
  interlang: ( ) ->  il.nil
  __len__: ( ) ->  0
  __iter__: ( ) -> if 0 then pyield

  toString: ( ) ->  'nil'

nil = make_new Nil()

conslist(elements...) ->
  result = nil
  for term in reversed(elements)
    result = Cons(element(term), result)
  return result

cons2tuple(item) ->
  if not isinstance(item, Cons) and not isinstance(item, list)  and not isinstance(item, tuple)
    return item
  return tuple(cons2tuple(x) for x in item)

cps_convert_unify_two_var(x, y, compiler, cont) ->
  x = x.interlang()
  y = y.interlang()
  x1 = compiler.new_var(il.ConstLocalVar(x.name))
  y1 = compiler.new_var(il.ConstLocalVar(y.name))
  return il.begin(
                   il.Assign(x1, il.Deref(x)), #for LogicVar, could be optimized when generate code.
                   il.Assign(y1, il.Deref(y)),
                   il.If(il.IsLogicVar(x1),
                         il.begin(il.SetBinding(x1, y1),
                                  il.append_failcont(compiler, il.DelBinding(x1)),
                                  cont(il.TRUE)),
                         il.begin(
                                   il.If(il.IsLogicVar(y1),
                                         il.begin(il.SetBinding(y1, x1),
                                                  il.append_failcont(compiler, il.DelBinding(y1)),
                                                  cont(il.TRUE)),
                                         il.If(il.Unify(x1, y1), cont(il.TRUE), il.failcont(il.TRUE))))))

cps_convert_unify_one_var(x, y, compiler, cont) ->
  x = x.interlang()
  y = y.interlang()
  x1 = compiler.new_var(il.ConstLocalVar(x.name))
  return il.begin(
                   il.Assign(x1, il.Deref(x)), #for LogicVar, could be optimized when generate code.
                   il.If(il.IsLogicVar(x1),
                         il.begin(il.SetBinding(x1, y),
                                  il.append_failcont(compiler, il.DelBinding(x1)),
                                  cont(il.TRUE)),
                         il.If(il.Unify(x1, y), cont(il.TRUE), il.failcont(il.TRUE))))

cps_convert_unify(x, y, compiler, cont) ->
  if isinstance(x, Var)
    if isinstance(y, Var)
      return cps_convert_unify_two_var(x, y, compiler, cont)
    else
      return cps_convert_unify_one_var(x, y, compiler, cont)
  else
    if isinstance(y, Var)
      return cps_convert_unify_two_var(y, x, compiler, cont)
    else
      if isinstance(x, Cons) and isinstance(y, Cons)
        v = compiler.new_var(il.ConstLocalVar('v'))
        return cps_convert_unify(x.head, y.head, compiler, il.clamda(v,
                                                                     cps_convert_unify(x.tail, y.tail, compiler, cont)))
      else
        if x==y then cont(il.TRUE)
        else il.failcont(il.FALSE)

class Apply extends Element
  constructor: (@caller, @args) ->
  alpha(env, compiler) ->  @__class__(@caller.alpha(env, compiler),  tuple(arg.alpha(env, compiler) for arg in @args))
  # see The 90 minute Scheme to C compiler by Marc Feeley
  cps(compiler, cont) ->  @caller.cps_call(compiler, cont, @args)
  subst(bindings) -> @__class__(@caller.subst(bindings),
                                tuple(arg.subst(bindings) for arg in @args))
  toString: ( ) ->  "#{@caller}(#{', '.join([repr(x) for x in @args])})"

class Command extends Element


class CommandCall extends Element
  constructor: (@fun, @args) ->
  subst: (bindings) -> @__class__(@fun,  tuple(arg.subst(bindings) for arg in @args))

  quasiquote:(compiler, cont) ->
    result = compiler.new_var(il.LocalVar('result'))
    vars = tuple(compiler.new_var(il.ConstLocalVar('a'+repr(i))) for i in range(len(@args)))
    t = tuple(
               il.If(il.Isinstance(var1, il.Klass('UnquoteSplice')),
                     il.AddAssign(result, il.Call(il.Symbol('list'), il.Attr(var1, il.Symbol('item')))),
                     il.ListAppend(result, var1)
                    ) for var1 in vars+[cont(il.Call(il.Klass(@__class__.__name__), il.QuoteItem(@fun), il.MakeTuple(result)))]
    body = [il.Assign(result, il.empty_list)]+t)
    fun = il.begin(body...)
    for var1, arg in reversed(zip(vars, @args))
      fun = arg.quasiquote(compiler, il.clamda(var1, fun))
    return fun

  __eq__: (x, y) ->  classeq(x, y) and x.fun==y.fun and x.args==y.args
  toString: ( ) ->  "#{@fun}(#{ ', '.join([repr(x) for x in @args])})"

class Special extends Command
  constructor: (@fun) ->
  __call__(args...) ->
    args = tuple(element(arg) for arg in args)
    return SpecialCall(args)
  toString: ( ) ->  @fun.__name__

special = Special

quasiquote_args: (args) ->
  if not args then pyield []
  else if len(args)==1
    for x in @quasiquote(args[0])
      try pyield x.unquote_splice
      catch e then pyield [x]
  else
    for x in @quasiquote(args[0])
      for y in @quasiquote_args(args[1..])
        try x = x.unquote_splice
        catch e then x = [x]
        pyield x+y

class SpecialCall extends CommandCall
  constructor: (@command, @args) -> @fun = command.fun

  alpha(env, compiler) -> @__class__(@command, tuple(arg.alpha(env, compiler) for arg in @args))

  cps(compiler, cont) -> @fun(compiler, cont, @args...)
  to_code(compiler) -> "#{@fun.__name__}(#{', '.join([x.to_code(compiler) for x in @args])})"

  free_vars: ( ) ->
    result = set()
    for arg in @args then  result |= arg.free_vars()
    return result

  toString: ( ) ->  "#{@fun.__name__}(#{', '.join(tuple(repr(x) for x in @args))})"

class BuiltinFunction extends Command
  is_statement: false
  constructor: (@name, @fun) ->

  __call__:(args...) ->
    args = tuple(element(arg) for arg in args)
    return BuiltinFunctionCall(args)

  cps: (compiler, cont) -> il.Lamda((params), @fun.fun(params...))
  analyse: (compiler) -> @
  subst: (bindings) -> @
  optimize: (env, compiler) -> @
  pythonize: (env, compiler) -> [[], false]
  toString: ( ) ->  @name

class BuiltinFunctionCall extends CommandCall
  is_statement: false
  alpha:(env, compiler) -> @__class__(@fun, tuple(arg.alpha(env, compiler) for arg in @args))

  cps:(compiler, cont) ->
    #see The 90 minute Scheme to C compiler by Marc Feeley
    args = @args
    vars = tuple(compiler.new_var(il.ConstLocalVar('a'+repr(i))) for i in range(len(args)))
    fun = cont(@fun.fun(vars...))
    for var1, arg in reversed(zip(vars, args))
      fun = arg.cps(compiler, il.Clamda(var1, fun))
    return fun

# unquote to interlang level
  analyse: (compiler) ->
  optimize: (env, compiler) -> @
  interlang: ( ) ->  @
  free_vars: ( ) ->
    result = set()
    for arg in @args then result |= arg.free_vars()
    return result

  pythonize: (env, compiler) -> [[@], false]
  to_code: (compiler) -> "#{@fun.name}(#{', '.join([x.to_code(compiler) for x in @args])})"
  toString: ( ) ->  "#{@fun.name}(#{', '.join([x.to_code(compiler) for x in @args])})"
  assign: (var1, exp) -> Assign(var1, element(exp))

class MultiAssignToConstError
  constructor: (@const) ->
  toString: ( ) ->  repr(@const)

class Assign extends CommandCall
  constructor: (@var1, @exp) ->
  subst: (bindings) -> Assign(@var1, @exp.subst(bindings))
  alpha: (env, compiler) ->
    try
      var1 = env[@var1]
    catch VariableNotBound
      env[@var1] = var1 = compiler.new_var(@var1)
      if isinstance(var1, Const)
        var1.assigned = true
        return Assign(var1, @exp.alpha(env, compiler))
    if isinstance(var1, Const) and var1.assigned
      throw make_new MultiAssignToConstError(var1)
      return Assign(var1, @exp.alpha(env, compiler))

  cps: (compiler, cont) ->
    v = compiler.new_var(il.ConstLocalVar('v'))
    return @exp.cps(compiler,
                    il.clamda(v, il.Assign(@var1.interlang(), v), cont(v)))

  __eq__: (x, y) ->  classeq(x, y) and x.var1==y.var1 and x.exp==y.exp
  to_code: (compiler) ->  repr(@)
  toString: ( ) ->  "assign#{@var1}, #{@exp})"
  direct_interlang: (exps...) ->  DirectInterlang(il.begin(exps...))

class DirectInterlang extends Element
  constructor: (@body) ->
  alpha: (env, compiler) ->  @
  cps: (compiler, cont) ->  cont(@body)

  @special
  expression_with_code: (compiler, cont, exp) ->
    v = compiler.new_var(il.ConstLocalVar('v'))
    return cont(il.ExpressionWithCode(exp, il.Lamda([], exp.cps(compiler, il.clamda(v, v)))))

    type_map = {int:Integer, float: Float, str:String, unicode: String
      tuple: make_tuple, list:List, dict:Dict,
      bool:Bool
    }     #type(lambda:1):PyFunction  type(None) : Atom

###############################################################################
# interlang
# element.py
#from dao.base import classeq
#from dao import base
#
#from dao.compilebase import CompileTypeError #VariableNotBound, CompileTypeError

#true == 1
#false==0
unknown = -1

element(exp) ->
  if isinstance(exp, base.Element) then exp
  else
    try type_map[type(exp)](exp)
    catch e then throw make_new CompileTypeError(exp)

no_side_effects(exp) ->
  fun: ( ) ->  false
  exp.side_effects = fun
  return exp

optimize_args: (args, env, compiler) ->
  result = []
  for arg in args
    arg = arg.optimize(env, compiler)
    if arg is not None
      result.append(arg)
  return tuple(result)

  pythonize_args:(args, env, compiler) ->
    # used in Apply, Return, Yield, VirtualOpteration
    result = []
    exps = []
    has_statement = false
    for arg in args
      [exps2, has_statement1] = arg.pythonize(env, compiler)
      has_statement = has_statement or has_statement1
      if exps2[-1].is_statement
        result.append(NONE)
        exps += exps2
      else
        result.append(exps2[-1])
        exps += exps2[..-1]
        return [exps, result, has_statement]

class Element extends base.Element
  has_side_effects: true
  is_statement: false
  tail_recursive_convert: ( ) ->  @
  find_assign_lefts: ( ) ->  set()
  replace_return_with_yield: ( ) ->  @
  interlang: ( ) ->  @
  __eq__: (x, y) ->  classeq(x, y)
  toString: ( ) ->  @__class__.__name__

class Atom extends Element
  constructor: (@item) ->
  find_assign_lefts: ( ) ->  set()
  analyse(compiler) ->
  side_effects: ( ) ->  false
  subst(bindings) ->  @
  optimize(env, compiler) ->  @
  replace_assign(compiler) ->  @
  tail_recursive_convert: ( ) ->  @
  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  pythonize(env, compiler) ->  [[@], false]
  code_size: ( ) ->  1
  to_code(compiler) ->  repr(@item)
  free_vars: ( ) ->  set()
  bool: ( ) -> if @item then true  else false
  __eq__: (x, y) ->  classeq(x, y) and x.item==y.item
  __hash__: ( ) ->  hash(@item)
  toString: ( ) ->  '%s'%@item

class ConstAtom extends Atom

class Integer extends ConstAtom
  __eq__: (x, y) ->  ConstAtom.__eq__(x, y) or (isinstance(y, int) and x.item==y)

class Float extends ConstAtom
  __eq__: (x, y) ->  ConstAtom.__eq__(x, y) or (isinstance(y, float) and x.item==y)

class String extends ConstAtom
  __eq__: (x, y) ->  ConstAtom.__eq__(x, y) or (isinstance(y, str) and x.item==y)

class Bool extends ConstAtom
  __eq__: (x, y) ->  ConstAtom.__eq__(x, y) or (isinstance(y, bool) and x.item==y)

class Symbol extends ConstAtom
  to_code: (compiler) ->  @item

class Klass extends ConstAtom
  to_code: (compiler) ->  @item
  toString: ( ) ->  'il.Klass(%s)'%(@item)

class PyFunction extends ConstAtom
  to_code: (compiler) ->  @item.func_name
  toString: ( ) ->  'il.PyFunction(%s)'%(@item)


TRUE = Bool(true)
FALSE = Bool(false)
NONE = Atom(None)

make_tuple = (item) ->  Tuple(tuple(element(x) for x in item)...)

class Tuple extends ConstAtom
  constructor: (@item...) ->
  find_assign_lefts: ( ) ->  set()
  analyse: (compiler) ->
    for x in @item then x.analyse(compiler)
  side_effects: ( ) ->  false
  subst: (bindings) ->  Tuple(tuple(x.subst(bindings) for x in @item)...)
  code_size: ( ) ->  sum([x.code_size() for x in @item])
  optimize: (env, compiler) ->  Tuple(tuple(x.optimize(env, compiler) for x in @item)...)
  to_code: (compiler) ->
    if len(@item)!=1 then  "(#{', '.join([x.to_code(compiler) for x in @item])})"
    else  "(#{@item[0].to_code(compiler)}, )"
  __eq__: (x, y) ->  classeq(x, y) and x.item==y.item
  toString: ( ) ->  "il.#{@__class__.__name__}(#{@item})"

class MutableAtom extends Atom

class List extends MutableAtom
  __eq__: (x, y) ->  (classeq(x, y) and x.item==y.item) or ((isinstance(y, list) and x.item==y))

class Dict extends MutableAtom
  __eq__: (x, y) ->  Atom.__eq__(x, y) or (isinstance(y, dict) and x.item==y)
  macro_args: (item) ->  MacroArgs(item)

class MacroArgs extends Element
  constructor: (@item) ->
  find_assign_lefts: ( ) ->  set()
  analyse: (compiler) -> for x in @item then x.analyse(compiler)
  optimize: (env, compiler) ->  MacroArgs(optimize_args(@item, env, compiler))
  side_effects: ( ) ->  false
  free_vars: ( ) ->
    result = set()
    for x in @item then  result |= x.free_vars()
    return result

  subst: (bindings) ->  MacroArgs(tuple(x.subst(bindings) for x in @item))

  pythonize: (env, compiler) ->
    has_statement = false
    exps = []
    args = []
    for arg in @item
      [exps1, has_statement1] = arg.pythonize(env, compiler)
      has_statement = has_statement or has_statement1
      exps += exps1[..-1]
      args.append(exps1[-1])
      exps.append(MacroArgs(tuple(args)))
    return [tuple(exps), has_statement]

  code_size: ( ) ->  sum([x.code_size() for x in @item])

  to_code: (compiler) ->
    if len(@item)!=1
      return '(%s)'% ', '.join([x.to_code(compiler) for x in @item])
    else return '(%s, )'%@item[0].to_code(compiler)

  __eq__: (x, y) ->  classeq(x, y) and x.item==y.item
  toString: ( ) ->  "il.#{@__class__.__name__}(#{@item})"


class Return extends Element
  @is_statement: true
  constructor: (@args...) ->
  analyse(compiler) ->  for arg in @args then  arg.analyse(compiler)
  code_size: ( ) ->  sum([code_size(x) for x in @args])
  side_effects: ( ) ->  false
  free_vars: ( ) ->
    result = set()
    for x in @args then  result |= x.free_vars()
    return result

  subst(bindings) -> @__class__(tuple(arg.subst(bindings) for arg in @args)...)

  optimize(env, compiler) ->
  if len(@args)==1 and isinstance(@args[0], Return)
    return @__class__(@args[0].args...)
  else
    for arg in @args
      if isinstance(arg, Return)  then throw make_new CompileError
    return @__class__(optimize_args(@args, env, compiler)...)

  pythonize(env, compiler) ->
    if len(@args)==1 and isinstance(@args[0], Begin)
      return Begin(@args[0].statements[..-1]+[Return(@args[0].statements[-1])]).pythonize(env, compiler)
    else if len(@args)==1 and isinstance(@args[0], If)
      return If(@args[0].test, Return(@args[0].then), Return(@args[0].else_)).pythonize(env, compiler)
    [exps, args, has_statement] = pythonize_args(@args, env, compiler)
    return [exps+[@__class__(args...)], true]

  to_code(compiler) ->   "return #{', '.join([x.to_code(compiler) for x in @args])}"
  insert_return_statement: ( ) ->  Return(@args...)
  replace_return_with_yield: ( ) ->  Begin([Yield(@args...), Return()])
  __eq__: (x, y) ->  classeq(x, y) and x.args==y.args
  toString: ( ) ->  "il.Return(#{','.join([repr(x) for x in @args])})"

class Yield extends Return
  to_code(compiler) ->   "pyield #{', '.join([x.to_code(compiler) for x in @args])}"
  insert_return_statement: ( ) ->  @
  toString: ( ) ->  "il.Yield(#{', '.join([repr(x) for x in @args])})"

class Try extends Element
  constructor: (@test, @body) ->
  find_assign_lefts: ( ) ->  @body.find_assign_lefts()
  analyse(compiler) ->
    @test.analyse(compiler)
    @body.analyse(compiler)

  code_size: ( ) ->  3 + @test.code_size() + @body.code_size()
  side_effects: ( ) ->  not @test.side_effects() and not @body.side_effects()
  subst(bindings) ->  Try(@test.subst(bindings), @body.subst(bindings))
  optimize(env, compiler) ->  Try(@test.optimize(env, compiler), @body.optimize(env, compiler))
  insert_return_statement: ( ) ->
    result = Try(@test, @body.insert_return_statement())
    result.is_statement = true
    return result

  replace_return_with_yield: ( ) ->
    result = Try(@test,  @body.replace_return_with_yield())
    result.is_statement = true
    return result

  pythonize(env, compiler) ->
    [test, has_statement1] = @test.pythonize(env, compiler)
    [body, has_statement2] = @body.pythonize(env, compiler)
    result = Try(test[-1], begin(body...))
    return [test[..-1]+[result], true]

  to_code(compiler) ->  "try\n#{compiler.indent(@test.to_code(compiler))}\ncatch e\n#{compiler.indent(@body.to_code(compiler))}\n"

  __eq__: (x, y) ->  classeq(x, y) and x.test==y.test and x.body==y.body
  toString: ( ) ->  "il.Try(#{@test}, #{ @body})"

begin(exps...) ->
  result = []
  length = len(exps)
  for i, e in enumerate(exps)
    if isinstance(e, Begin)
      result += e.statements
    else if e==[] then  continue
    else
      if e==NONE and i!=length-1 then continue
      else result.append(e)
    if len(result)==0 then return_statement
    else if len(result)==1 then return result[0]
    else Begin(tuple(result))

class Begin extends Element
  is_statement = true
  constructor: (@statements) ->
  find_assign_lefts: ( ) ->
    result = set()
    for exp in @statements
      result |= exp.find_assign_lefts()
    return result

  side_effects: ( ) ->  true
  subst(bindings) ->  Begin(tuple(x.subst(bindings) for x in @statements))

  free_vars: ( ) ->
  result = set()
  for exp in @statements
    result |= exp.free_vars()
  return result

  code_size: ( ) ->  1
  analyse(compiler) -> for x in @statements then x.analyse(compiler)

  optimize(env, compiler) ->
    result = []
    for arg in @statements
      arg1 = arg.optimize(env, compiler)
      if arg1 is not None
        result.append(arg1)
      if result
        return begin(((x for x in result[..-1] if not isinstance(x, Atom))+[result[-1]])...)
      else return_statement

  remove: (exp) ->
    for i, stmt in enumerate(@statements)
      if stmt is exp then break
      else return @
    return begin((@statements[..i]+@statements[i+1..])...)

  insert_return_statement: ( ) ->
    inserted = @statements[-1].insert_return_statement()
    return begin((@statements[..-1]+[inserted])...)

  replace_return_with_yield: ( ) ->  Begin(tuple(exp.replace_return_with_yield() for exp in @statements))

  pythonize: (env, compiler) ->
    result = []
    has_any_statement = false
    for exp in @statements
      [exps2, any_statement] = exp.pythonize(env, compiler)
    has_any_statement = has_any_statement or any_statement
    result += exps2
    return [result, has_any_statement or len(result)>1]

  to_code(compiler) ->   '\n'.join([x.to_code(compiler) for x in @statements])
  __eq__: (x, y) ->  classeq(x, y) and x.statements==y.statements
  toString: ( ) ->  'il.begin(%s)'%'\n '.join([repr(x) for x in @statements])

class PassStatement extends Element
  is_statement = true

  constructor: ( ) ->
  code_size: ( ) ->  0
  side_effects: ( ) ->  false
  analyse(compiler) ->
  optimize(env, compiler) -> _statement
  pythonize(env, compiler) ->  [[@], true]
  insert_return_statement: ( ) ->  @
  replace_return_with_yield: ( ) ->  @
  subst(bindings) ->  @
  __eq__: (x, y) ->  classeq(x, y)
  to_code(compiler) ->  'pass'
  toString: ( ) ->  'il.pass_statement'

pass_statement = PassStatement()

class Nil extends Element
  is_statement: false
  constructor: ( ) ->
  code_size: ( ) ->  0
  side_effects: ( ) ->  false
  analyse(compiler) ->
  optimize(env, compiler) ->  nil
  pythonize(env, compiler) ->  [[@], true]
  insert_return_statement: ( ) ->  @
  replace_return_with_yield: ( ) ->  @
  subst(bindings) ->  @
  __eq__: (x, y) ->  classeq(x, y)
  to_code(compiler) ->  'nil'
  toString: ( ) ->  'il.nil'

nil = Nil()

type_map = {int:Integer, float: Float, str:String, unicode: String
  tuple: make_tuple, list:List, dict:Dict
  bool:Bool
}
type_map[type(None)] = Atom

########################################################
#

#from dao.base import classeq
#
#from dao.compilebase import MAX_EXTEND_CODE_SIZE
#from dao.compilebase import VariableNotBound, CompileTypeError
#
#from element import pythonize_args, optimize_args
#from element import Element, begin, Return, Begin
#from element import NONE, unknown, make_tuple, Tuple, ConstAtom, Tuple, List

lamda(params, body...) ->  Lamda(params, begin(body...))

class Lamda extends Element
  constructor: (@params, @body) -> @has_pythonized = false
  make_new(params, body) ->  @__class__(params, body)
  __call__(args...) ->  Apply(args)
  find_assign_lefts: ( ) ->  @body.find_assign_lefts()
  analyse(compiler) ->
    compiler.lamda_stack.append(@)
    @body.analyse(compiler)
    compiler.lamda_stack.pop()
  code_size: ( ) ->  @body.code_size()+len(@params)+2
  side_effects: ( ) ->  false

  subst(bindings) ->
    result = @make_new(@params, @body.subst(bindings))
    return result

  optimize(env, compiler) ->
    env = env.extend()
    body = @body.optimize(env, compiler)
    result = @make_new(@params, body)
    return result

  optimize_apply(env, compiler, args) ->
    #1. ((lambda () body))  =>  body
    if len(@params)==0
      return @body.optimize(env, compiler)

    #2. (lamda x: ...x...)(y) => (lambda : ... y ...)()
    bindings = {}
    [new_params, new_args] = [[], []]
    for i, p in enumerate(@params)
      arg = args[i]
      if arg.side_effects()
        new_params += [p]
        new_args += [arg]
        continue
      else
        ref_count = compiler.ref_count.get(p, 0)
      if ref_count==0 then continue
      else if ref_count==1
        bindings[p] = arg
      else
        if arg.code_size()*ref_count>MAX_EXTEND_CODE_SIZE
          # a(...y...), and a is (lamda ...x...: ...x...),
          #then convert as above if code size is ok.
          new_params += [p]
          new_args += [arg]
        else
          bindings[p] = arg

    if new_params
      if bindings
        return Apply(@make_new(new_params, @body.subst(bindings).optimize(env, compiler)),
                     tuple(arg.optimize(env, compiler) for arg in new_args))
      else
        if len(new_params)!=len(@params)
          Apply(@make_new(new_params, @body.subst(bindings).optimize(env, compiler)),
                tuple(arg.optimize(env, compiler) for arg in new_args))
        else  Apply(@make_new(new_params, @body.optimize(env, compiler)),
                    optimize_args(new_args, env, compiler))
    else
      if bindings then @body.subst(bindings).optimize(env, compiler)
      else  @body.optimize(env, compiler)

  insert_return_statement: () ->  Return(@)

  pythonize: (env, compiler) ->
    if @has_pythonized then return [[@name], false]
    [body_exps, body_has_any_statement] = @body.pythonize(env, compiler)
    global_vars = begin(body_exps...).find_assign_lefts()-set(@params)
    global_vars = set(x for x in global_vars when isinstance(x, Var) and not isinstance(x, LocalVar)  and not isinstance(x, SolverVar))
    if global_vars
      body_exps = [GlobalDecl(global_vars)]+body_exps
      if not body_has_any_statement
        return [[@make_new(@params, begin(body_exps...))], false]
      else
        @has_pythonized = true
        name = compiler.new_var(LocalVar('fun'))
        body = begin(body_exps...).insert_return_statement()
        @name = name
        return [[Function(name, @params, body), name], true]

  to_code: (compiler) -> "lambda #{', '.join(tuple(x.to_code(compiler) for x in @params))}: "  + '%s'%@body.to_code(compiler)

  free_vars: ( ) ->  @body.free_vars()-set(@params)
  bool: ( ) ->  true
  __eq__: (x, y) ->  classeq(x, y) and x.params==y.params and x.body==y.body
  __hash__: ( ) ->  hash(id(@))
  toString: ( ) ->  "il.Lamda((#{', '.join([repr(x) for x in @params])}), \n#{repr(@body)})"

class RulesLamda extends Lamda
  constructor: (@params, @body) ->  @has_pythonized = false
  __call__(args...) ->  Apply(tuple(element(x) for x in args))

  optimize_apply(env, compiler, args) ->  Lamda.optimize_apply(env, compiler, args)

  to_code(compiler) -> "lambda #{@params[0].to_code(compiler)}, #{@params[1].to_code(compiler)}: " + @body.to_code(compiler)

clamda(v, body...) ->  Clamda(v, begin(body...))

class Clamda extends Lamda
  constructor: (v, @body) ->
    @has_pythonized = false
    @params = [v]
    @name = None

  make_new(params, body) ->  @__class__(params[0], body)

  optimize_apply:(env, compiler, args) ->
    [param, arg] = [@params[0], args[0]]
    if not arg.side_effects()
      body = @body.subst({param: arg}).optimize(env, compiler)
      return body
    else
      ref_count = compiler.ref_count.get(param, 0)
      if ref_count==0 then begin(arg, @body).optimize(env, compiler)
      else begin(Assign(param, arg), @body).optimize(env, compiler)

  __call__(arg) ->
    if arg.side_effects() then begin(Assign(@params[0], arg), @body)
    else
      bindings = {}
      bindings[@params[0]] = arg
      @body.subst(bindings)

  toString: ( ) ->  "il.Clamda(#{@params[0]}, \n#{ repr(@body)})"

class EqualCont
  @is_statement: false
  __call__(body) ->  body
  subst(bindings) ->  @
  analyse(compiler) ->
  code_size: ( ) ->  1
  side_effects: ( ) ->  false
  optimize(env, compiler) ->  @
  pythonize(env, compiler) ->  [[@], false]
  to_code(compiler) ->  'lambda v:v'
  toString: ( ) ->  'EqualCont'

equal_cont = EqualCont()

class Done extends Clamda
  constructor: (param) ->
    @has_pythonized = false
    @params = [param]
    @body = param

  make_new(params, body) ->  @__class__(@params[0])
  __call__(args...) ->
    bindings = {}
    bindings[@params[0]] = args[0]
    @body.subst(bindings)
  replace_assign: (bindings) ->  @
  toString: ( ) ->  "il.Done(#{@params[0]}, #{repr(@body)})"

class Function extends Lamda
  '''recursive Function'''
  is_statement: true
  constructor: (name, params, body) ->

class Lamda
  constructor: (params, body) -> @name = name
  make_new(params, body) ->  @__class__(@name, params, body)

  optimize(env, compiler) ->
    env = env.extend()
    body = @body.optimize(env, compiler)
    result = @make_new(@params, body)
    return result

  optimize_apply(env, compiler, args) ->
    result = Lamda.optimize_apply(env, compiler, args)
    return result

  pythonize(env, compiler) ->
    if @has_pythonized then return [[@name], false]
    [body_exps, has_any_statement] = @body.pythonize(env, compiler)
    global_vars = @find_assign_lefts()-set(@params)
    global_vars = set(x for x in global_vars when isinstance(x, Var) and not isinstance(x, LocalVar) and not isinstance(x, SolverVar))
    if global_vars then  body_exps = [GlobalDecl(global_vars)]+body_exps
    if not body_exps[-1].is_statement
      body_exps = body_exps[..-1] + [Return(body_exps[-1])]
    else body_exps = body_exps[..-1] + [body_exps[-1].insert_return_statement()]

    @has_pythonized = true
    return [[@make_new(@params, begin(body_exps...)), @name], true]

  to_code(compiler) -> "  #{@name}(#{', '.join(tuple(x.to_code(compiler) for x in @params))}):\n"  + compiler.indent(@body.to_code(compiler))

  toString: ( ) ->  "il.Function(#{@name}, #{', '.join([repr(x) for x in @params])})\n, #{repr(@body)})"

cfunction(name, v, body...) ->  CFunction(name, v, begin(body...))

class CFunction extends Function
  is_statement: true
  is_fun: true
  constructor: (name, v, body) ->
  make_new(params, body) ->  @__class__(@name, params[0], body)
  optimize_apply(env, compiler, args) ->
    new_env = env.extend()
    bindings = {}
    bindings[@params[0]] = args[0]
    body = @body.subst(bindings)
    body = body.optimize(new_env, compiler)
    result = CFunction(@name, @params[0], body)(NONE)
    return result
  toString: ( ) ->  "il.CFunction(#{@name}, #{@params[0]}, \n#{repr(@body)})"

class RulesDict extends Element
  constructor: (arity_body_map) ->
    @arity_body_map = arity_body_map
    @to_coded = false

  analyse: (compiler) ->
    try @seen  catch e then  @seen = true
    compiler.occur_count[@] = compiler.occur_count.setdefault(0)+1
    for arity, body in @arity_body_map.items()
      body.analyse(compiler)

  subst: (bindings) ->
    @arity_body_maparity_body_map = {arity:body.subst(bindings) for arity, body in @arity_body_map.items()}
    return @

  side_effects: ( ) ->  false
  free_vars: ( ) ->
    result = set()
    for arity, body in @arity_body_map.items()
      result |= body.free_vars()
    return result

  optimize: (env, compiler) ->  @
  pythonize: (env, compiler) ->  [[@], false]
  bool: ( ) ->  true

  to_code: (compiler) ->
    if @to_coded then  return @name.to_code(compiler)
    else
      @to_coded = true
      ss = "#{arity}: #{funcname.to_code(compiler)}" for arity, funcname in @arity_body_map.items()
      return "{#{', '.join(ss)}}"

  toString: ( ) ->  'RulesDict(%s)'%@arity_body_map

class Macro

class MacroLamda extends Lamda #, Macro):
  optimize_apply: (env, compiler, args) ->
    #args = (args[0], Tuple(*args[1:]))
    result = Lamda.optimize_apply(env, compiler, args)
    return result

  pythonize: (env, compiler) ->
    [body_exps, body_has_any_statement] = @body.pythonize(env, compiler)
    global_vars = @find_assign_lefts()-set(@params)
    global_vars = set(x for x in global_vars when isinstance(x, Var)  and not isinstance(x, LocalVar)  and not isinstance(x, SolverVar))
    if global_vars
      body_exps = [GlobalDecl(global_vars)]+body_exps
      if not body_has_any_statement
        return [[MacroFunction(Lamda(@params, begin(body_exps...)))], false]
      else
        name = compiler.new_var(LocalVar('fun'))
        body = begin(body_exps...).insert_return_statement()
        return [[Function(name, @params, body), MacroFunction(name)], true]

  toString: ( ) ->  "il.MacroLamda((#{', '.join([repr(x) for x in @params])}), \n#{repr(@body)})"

class MacroRules extends Lamda #, Macro):
  optimize_apply: (env, compiler, args) ->
    result = Lamda.optimize_apply(env, compiler, args)
    return result

  pythonize: (env, compiler) ->
    [body_exps, body_has_any_statement] = @body.pythonize(env, compiler)
    global_vars = @find_assign_lefts()-set(@params)
    global_vars = set()
    for x in global_vars
      if isinstance(x, Var) and not isinstance(x, LocalVar)  and not isinstance(x, SolverVar)
        global_vars.add(x)
    if global_vars
      body_exps = [GlobalDecl(global_vars)]+body_exps
    if not body_has_any_statemen
      return [[MacroRulesFunction(@make_new(@params, begin(body_exps...)))], false]
    else
    name = compiler.new_var(LocalVar('fun'))
    body = begin(body_exps...).insert_return_statement()
    return [[Function(name, @params, body), MacroRulesFunction(name)], true]

class MacroFunction extends Element
  constructor: (@fun) ->
  to_code: (compiler) ->  'MacroFunction(%s)'%@fun.to_code(compiler)
  toString: ( ) ->  'MacroFunction(%s)'%@fun

class MacroRulesFunction extends Element
  constructor: (@fun) ->
  to_code: (compiler) ->  'MacroRules(%s)'%@fun
  toString: ( ) ->  'MacroRulesFunction(%s)'%@fun

class GlobalDecl extends Element
  constructor: (@args) ->
  side_effects: ( ) ->  false
  to_code: (compiler) ->  "global %s" % (', '.join([x.to_code(compiler) for x in @args]))
  toString: ( ) ->  'GlobalDecl(%s)'%@args

class Apply extends Element
  is_statement: false
  constructor: (@caller, @args) ->
  find_assign_lefts: (exp) ->  set()

  analyse: (compiler) ->
    compiler.called_count[@caller] = compiler.called_count.setdefault(@caller, 0)+1
    @caller.analyse(compiler)
    for arg in @args
      arg.analyse(compiler)

  code_size: ( ) ->  @caller.code_size()+sum([x.code_size() for x in @args])

  side_effects: ( ) ->
    if isinstance(@caller, Lamda)
      if @caller.body.side_effects() then  return true
      else if isinstance(@caller, Var) then  return true
      else if @caller.has_side_effects() then return true
      else return false # after cps, all of value have been solved before called,
  # so have no side effects.

  subst: (bindings) ->  @__class__(@caller.subst(bindings),
                                   tuple(arg.subst(bindings) for arg in @args))

  free_vars: ( ) ->
    result = @caller.free_vars()
    for exp in @args
      result |= exp.free_vars()
    return result

  optimize: (env, compiler) ->
    args = optimize_args(@args, env, compiler)
    if isinstance(@caller, Var)
      if @caller not in compiler.recursive_call_path
        caller = @caller.optimize(env, compiler)
        if isinstance(caller, Lamda)
          compiler.recursive_call_path.append(@caller)
          result = caller.optimize_apply(env, compiler, args)
          compiler.recursive_call_path.pop()
          return result
        else
          return @__class__(caller, args)
      else
        return @__class__(@caller, args)
    else if isinstance(@caller, Lamda)
      return @caller.optimize_apply(env, compiler, args)
    else
      caller = @caller.optimize(env, compiler)
      if isinstance(caller, Lamda)
        return caller.optimize_apply(env, compiler, args)
      else
        return @__class__(caller, args)

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  pythonize: (env, compiler) ->
    [exps, has_statement] = @caller.pythonize(env, compiler)
    caller = exps[-1]
    exps = exps[..-1]
    [exps2, args, has_statement2] = pythonize_args(@args, env, compiler)
    return [exps+exps2+[@__class__(caller,args)], has_statement or has_statement2]

  to_code: (compiler) ->
    if isinstance(@caller, Lamda)
      return "(%s)"%@caller.to_code(compiler) + '(%s)'%', '.join([x.to_code(compiler) for x in @args])
    else
      return @caller.to_code(compiler) + '(%s)'%', '.join([x.to_code(compiler) for x in @args])

  bool: ( ) ->  unknown
  __eq__: (x, y) ->  classeq(x, y) and x.caller==y.caller and x.args==y.args
  toString: ( ) ->  "#{@caller}(#{', '.join([repr(x) for x in @args])})"

class ExpressionWithCode extends Element
  constructor: (@exp, @fun) ->
  analyse: (compiler) -> @fun.analyse(compiler)
  side_effects: ( ) ->  false
  subst: (bindings) ->  ExpressionWithCode(@exp, @fun.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->  @fun.free_vars()
  optimize: (env, compiler) ->  ExpressionWithCode(@exp, @fun.optimize(env, compiler))

  pythonize: (env, compiler) ->
    [exps, has_statement] = @fun.pythonize(env, compiler)
    if has_statement then [[exps[0], ExpressionWithCode(@exp, exps[1])], true]
    else [[ExpressionWithCode(@exp, exps[0])], false]

  __eq__: (x, y) ->  classeq(x, y) and x.exp==y.exp
  to_code: (compiler) ->  "ExpressionWithCode((#{@exp.to_code(compiler)}), (#{ @fun.to_code(compiler)}))"
  toString: ( ) ->  "ExpressionWithCode(#{@exp}, #{@fun})"

class Var extends Element
  is_statement: false

  constructor: (@name) ->
  find_assign_lefts: ( ) ->  set()
  analyse: (compiler) -> compiler.ref_count[@] = compiler.ref_count.setdefault(0)+1
  code_size: ( ) ->  1
  side_effects: ( ) ->  false
  subst: (bindings) ->
    try bindings[@]
    catch e then @
  optimize: (env, compiler) ->
    try env[@]
    catch e then  @
  replace_assign: (compiler) ->
    try env[@]
    catch e then @
  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  pythonize: (env, compiler) ->  [[@], false]
  to_code: (compiler) ->  @name
  __eq__: (x, y) ->  classeq(x, y) and x.name==y.name
  __call__: (args...) ->  Apply(args)
  free_vars: ( ) ->  set([@])
  bool: ( ) ->  unknown
  __hash__: ( ) ->  hash(@name)
  toString: ( ) ->  @name

class RecursiveVar extends Var
class LocalVar extends Var
class ConstLocalVar extends LocalVar

class SolverVar extends Var
  constructor: (name) -> @name = 'solver.'+name
  toString: ( ) ->  'il.%s'%@name.split('.')[1]

class LogicVar extends Element
  is_statement: false

  constructor: (@name) ->
  find_assign_lefts: (exp) ->  set()
  analyse: (compiler) ->
  subst: (bindings) ->  @
  free_vars: ( ) ->  set()
  side_effects: ( ) ->  false
  optimize: (env, compiler) ->  @
  replace_assign: (compiler) ->  @
  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  pythonize: (env, compiler) -> [[@], false]

  deref: (bindings) ->
    # todo:
    # how to shorten the binding chain? need to change solver.fail_cont.
    # deref(solver) can help
    self = @
    while 1
      next = bindings[self]
      if not isinstance(next, LogicVar) or next==self
        return next
      else  self = next

  to_code: (compiler) ->   "LogicVar('%s')"%@name
  toString: ( ) ->  "LogicVar(%s)"%@name

class DummyVar extends LogicVar
  to_code: (compiler) ->   "DummyVar('%s')"%@name

class Assign extends Element
  is_statement: true

  constructor: (@var1, @exp) ->
  find_assign_lefts: ( ) ->  set([@var1])
  analyse: (compiler) -> @exp.analyse(compiler)
  insert_return_statement: ( ) ->  begin(Return(@var1))
  code_size: ( ) ->  code_size(@exp)+2
  side_effects: ( ) ->  true
  subst: (bindings) ->  Assign(@var1, @exp.subst(bindings))
  free_vars: ( ) ->  @exp.free_vars()
  right_value: ( ) ->  @exp

  optimize: (env, compiler) ->
    exp = @exp.optimize(env, compiler)
    result = Assign(@var1, exp)
    if isinstance(@var1, ConstLocalVar)
      if isinstance(exp, ConstAtom) or isinstance(exp, Cons) or isinstance(exp, ExpressionWithCode) or isinstance(exp, Lamda)
        env[@var1] = exp
        return None
      else if isinstance(exp, RulesDict)
        env[@var1] = exp
        exp.name = @var1
        return result
    return result

  pythonize: (env, compiler) ->
    if not @var1.name.startswith('solver.')
      if isinstance(@exp, Function)
        @exp.name = @var1
      fun = @exp
    else if isinstance(@exp, Lamda) and not isinstance(@exp, MacroLamda)
      fun = Function(@var1, @exp.params, @exp.body)
    else
      fun = None
    if fun is not None
      result = fun.pythonize(env, compiler)
      if isinstance(result[0][-1], Var)
        result = [result[0][..-1], result[1]]
      return result
    [exps, has_statement] = @exp.pythonize(env, compiler)
    if exps[-1].is_statement then [exps+[Assign(@var1, NONE)], true]
    else [exps[..-1]+[Assign(@var1, exps[-1])], true]

  to_code: (compiler) ->
    if isinstance(@exp, RulesDict) and @exp.to_coded then ''
    else "#{@var1.to_code(compiler)} = #{@exp.to_code(compiler)}"

  __eq__: (x, y) ->  classeq(x, y) and x.var1==y.var1 and x.exp==y.exp

  toString: ( ) ->  "#il.Assign(#{@var1}, #{@exp})"

class AssignFromList extends Element
  is_statement: true

  constructor: (args...) ->
    @vars = args[..-1]
    @value = args[-1]

  side_effects: ( ) ->  true

  analyse: (compiler) ->
    for var1 in @vars
      var1.analyse(compiler)
    @value.analyse(compiler)

  subst: (bindings) ->  AssignFromList((tuple(var1.subst(bindings) for var1 in @vars)+[@value.subst(bindings)])...)

  code_size: ( ) ->  1

  free_vars: ( ) ->
    result = set(@vars)
    result |= @value.free_vars()
    return result

  optimize: (env, compiler) ->
    value = @value.optimize(env, compiler)
    if isinstance(value, Tuple) or isinstance(value, List)
      if len(value.item)!=len(@vars)
        throw make_new DaoCompileError
      else
        for var1, v in zip(@vars, value.item)
          if isinstance(var1, ConstLocalVar)
            env[var1] = v
          else
            assigns.append(Assign(var1, v))
        if assigns
          return begin(tuple(Assign(var1, v))...)
        else return None
      return AssignFromList((@vars+[value])...)

  find_assign_lefts: ( ) ->  set(@vars)

  pythonize: (env, compiler) ->
    [value_exps, has_statement1] = @value.pythonize(env, compiler)
    return [value_exps[..-1]+[AssignFromList((@vars+[value_exps[-1]])...)], true]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->  false

  to_code: (compiler) ->  "#{', '.join([x.to_code(compiler) for x in @vars])} = #{@value.to_code(compiler)}"

  toString: ( ) ->  "il.AssignFromList(#{@vars}, #{@value})"

if_(test, then_, else_) -> If(element(test), element(then_), element(else_))

class If extends Element
  constructor: (@test, @then_, @else_) ->
    if else_==pseudo_else then @is_statement = true

  find_assign_lefts: ( ) ->  @then_.find_assign_lefts() | @else_.find_assign_lefts()

  analyse(compiler) ->
    @test.analyse(compiler)
    @then_.analyse(compiler)
    @else_.analyse(compiler)

  code_size: ( ) ->  3 + @test.code_size() +
  @then_.code_size() +
  @else_.code_size()

  side_effects: ( ) ->  not @test.side_effects() and
  not @then_.side_effects() and
  not @else_.side_effects()

  subst: (bindings) ->  If(@test.subst(bindings),
                           @then_.subst(bindings),
                           @else_.subst(bindings))

  free_vars: ( ) ->
    result = set()
    result |= @test.free_vars()
    result |= @then_.free_vars()
    result |= @else_.free_vars()
    return result

  optimize(env, compiler) ->
    test = @test.optimize(env, compiler)
    test_bool = test.bool()
    if test_bool==true
      then_ = @then_.optimize(env, compiler)
    if isinstance(then_, If) and then_.test==test # (if a (if a b c) d)
      then_ = then_.then_
      return then_
    else if test_bool==false
      else_ = @else_.optimize(env, compiler)
    if isinstance(else_, If) and else_.test==test # (if a b (if a c d))
      else_ = else_.else_
      return else_
    then_ = @then_.optimize(env, compiler)
    else_ = @else_.optimize(env, compiler)
    if isinstance(then_, If) and then_.test==test # (if a (if a b c) d)
      then_ = then_.then_
    if isinstance(else_, If) and else_.test==test # (if a b (if a c d))
      else_ = else_.else_
      return If(test, then_, else_)

  insert_return_statement: ( ) ->
    result = If(@test,
                @then_.insert_return_statement(),
                @else_.insert_return_statement())
    result.is_statement = true
    return result

  replace_return_with_yield: ( ) ->
    result = If(@test,
                @then_.replace_return_with_yield(),
                @else_.replace_return_with_yield())
    result.is_statement = true
    return result

  pythonize(env, compiler) ->
    [test, has_statement1] = @test.pythonize(env, compiler)
    [then_, has_statement2] = @then_.pythonize(env, compiler)
    [else_, has_statement3] = @else_.pythonize(env, compiler)
    if_ = If(test[-1], begin(then_...), begin(else_...))
    if_.is_statement = if_.is_statement or has_statement2 or has_statement3
    return [test[..-1]+[if_], has_statement1 or if_.is_statement]

  to_code(compiler) ->
    if @is_statement
      result = "if #{@test.to_code(compiler)}: \n#{compiler.indent(@then_.to_code(compiler))}\n"
    if @else_!=pseudo_else
      result += 'else\n%s\n'% compiler.indent(@else_.to_code(compiler))
      return result
    else "(#{@then_.to_code(compiler)} if #{@test.to_code(compiler)} \nelse #{ @else_.to_code(compiler)})"
  __eq__: (x, y) ->  classeq(x, y) and x.test==y.test and x.then==y.then and x.else_==y.else_

  toString: ( ) ->
    if @else_!=pseudo_else then  "il.If(#{@test}, \n#{@then_}, \n#{else_})"
    else  "il.If(#{@test}, \n#{@then_})"

if2(test, then_) ->  If(test, then_, pseudo_else)

class PseudoElse extends ConstAtom
  constructor: ( ) ->
  code_size: ( ) ->  0
  insert_return_statement: ( ) ->  @
  replace_return_with_yield: ( ) ->  @
  to_code(compiler) ->  ''
  __eq__: (x, y) ->  classeq(x, y)
  toString: ( ) ->  'il.pseudo_else'

pseudo_else = PseudoElse()

class Cons extends ConstAtom
  constructor: (@head, @tail) ->
  code_size: ( ) ->  1
  insert_return_statement: ( ) ->  @
  replace_return_with_yield: ( ) ->  @
  to_code(compiler) ->  "Cons(#{@head.to_code(compiler)}, #{@tail.to_code(compiler)})"
  __eq__: (x, y) ->  classeq(x, y) and x.head==y.head and x.tail==y.tail
  toString: ( ) ->  "il.Cons(#{@head}, #{@tail})"

while_(test, exps...) -> While(test, begin([x for x in exps]...))

class While extends Element
  constructor: (@test, @body) ->
  find_assign_lefts: ( ) ->  @body.find_assign_lefts()
  analyse(compiler) ->
    @test.analyse(compiler)
    @body.analyse(compiler)
  free_vars: ( ) ->  @test.free_vars() | @body.free_vars()
  code_size: ( ) ->  3 + @test.code_size() +@body.code_size()
  side_effects: ( ) ->  not @test.side_effects() and not @body.side_effects()
  subst(bindings) ->  While(@test.subst(bindings), @body.subst(bindings))

  optimize(env, compiler) ->
    free_vars = @free_vars()
    test = @test.optimize(env, compiler)
    body = @body.optimize(env, compiler)
    result = While(test,body)
    return result

  insert_return_statement: ( ) ->
    result = While(@test,
                   @body.insert_return_statement())
    result.is_statement = true
    return result

  replace_return_with_yield: ( ) ->
    result = While(@test,
                   @body.replace_return_with_yield())
    result.is_statement = true
    return result

  pythonize(env, compiler) ->
    [test, has_statement1] = @test.pythonize(env, compiler)
    [body, has_statement2] = @body.pythonize(env, compiler)
    result = While(test[-1], begin(body...))
    [test[..-1]+[result], true]

  to_code(compiler) ->  "while #{@test.to_code(compiler)}:\n#{compiler.indent(@body.to_code(compiler))}\n"

  __eq__: (x, y) ->  classeq(x, y) and x.test==y.test and x.body==y.body
  toString: ( ) ->  "il.While(#{@test}, \n#{@body})"
  for_(var1, range, exps...) ->
    return For(element(var1), element(range), begin([x for x in exps]...))

class For extends Element
  constructor: (@var1, @range, @body) ->
  find_assign_lefts: ( ) ->  @body.find_assign_lefts()
  analyse:(compiler) ->
    @var1.analyse(compiler)
    @range.analyse(compiler)
    @body.analyse(compiler)

  code_size: ( ) ->  3 + @var1.code_size() + @range.code_size() + @body.code_size()
  side_effects: ( ) ->  not @var1.side_effects() and not @range.side_effects() and not @body.side_effects()
  subst(bindings) ->  For(@var1.subst(bindings), @range.subst(bindings), @body.subst(bindings))
  free_vars: ( ) ->  @var1.free_vars() | @range.free_vars() | @body.free_vars()
  optimize(env, compiler) ->
    free_vars = @free_vars()
    assigns = []
    for var1 in free_vars
      value = env[var1]
      if value is None then continue
      assigns.append(Assign(var1, value))
      del env[var1]
    return begin((tuple(assigns) + [For(@var1, @range.optimize(env, compiler), @body.optimize(env, compiler))])...)

  insert_return_statement: ( ) ->  For(@var1, @range, @body.insert_return_statement())
  replace_return_with_yield: ( ) ->  For(@var1, @range, @body.replace_return_with_yield())

  pythonize(env, compiler) ->
    [var1, has_statement1] = @var1.pythonize(env, compiler)
    [range, has_statement1] = @range.pythonize(env, compiler)
    [body, has_statement2] = @body.pythonize(env, compiler)
    return [[For(var1[-1], range[-1], begin(body...))], true]

  to_code(compiler) ->  "for #{@var1.to_code(compiler)} in #{@range.to_code(compiler)}:\n#{compiler.indent(@body.to_code(compiler))}\n"
  __eq__: (x, y) ->  classeq(x, y) and x.var1==y.var1 and x.range==y.range and x.body==y.body
  toString: ( ) ->  "il.For(#{@var1}, #{@range}, #{@body})"

#####################################
# vop.py

#import operator
#
#from dao.base import classeq
#
#from dao.compilebase import MAX_EXTEND_CODE_SIZE
#from dao.compilebase import VariableNotBound, CompileTypeError
#from element import Element, Begin, begin, Return, Yield
#from element import Atom, Integer, Bool, MacroArgs, Tuple, Dict, List , element
#from element import pythonize_args, FALSE, NONE, Symbol, no_side_effects, unknown, ConstAtom
#from lamda import Apply, optimize_args, clamda, Lamda, Macro, MacroRules, RulesDict
#from lamda import Var, LocalVar, ConstLocalVar, SolverVar, LogicVar, Assign, ExpressionWithCode#, ValueAssignBox

class BinaryOperation extends Element
  constructor: (@name, @operator, @operator_fun, @has_side_effects=true) ->
  analyse: (compiler) ->  @
  subst: (bindings) ->  @
  optimize: (env, compiler) ->  @
  code_size: ( ) ->  1
  pythonize: (env, compiler) ->  [[@], false]
  to_code: (compiler) ->  @operator
  __call__: (args...) ->  BinaryOperationApply(args)
  __eq__: (x, y) ->  classeq(x, y) and x.operator==y.operator
  __hash__: ( ) ->  hash(@operator)
  toString: ( ) ->  "il.#{@name}"

add = BinaryOperation('add', '+', operator.add, false)
sub = BinaryOperation('sub', '-', operator.sub, false)
mul = BinaryOperation('mul', '*', operator.mul, false)
div = BinaryOperation('div', '/', operator.div, false)
IsNot = BinaryOperation('is_not', 'is not', operator.is_not, false)
And = BinaryOperation('and', 'and', operator.and_, false)
Or = BinaryOperation('or', 'or', operator.or_, false)

Lt = BinaryOperation('Lt', '<', operator.lt, false)
Le = BinaryOperation('Le', '<=', operator.le, false)
Eq = BinaryOperation('Eq', '==', operator.eq, false)
Ne = BinaryOperation('Ne', '!=', operator.ne, false)
Ge = BinaryOperation('Ge', '>=', operator.ge, false)
Gt = BinaryOperation('Gt', '>', operator.gt, false)

and_(exps...) ->  if len(exps) is 2 then And(exps...)  else And(exps[0], and_(exps[1..]...))

or_(exps...) ->  if len(exps) is 2 then Or(exps...)  else Or(exps[0], or_(exps[1...]))

class BinaryOperationApply extends Apply
  is_statement: false
  constructor: (@caller, @args) ->

  analyse(compiler) ->
    compiler.called_count[@caller] = compiler.called_count.setdefault(@caller, 0)+1
    @caller.analyse(compiler)
    for arg in @args
      arg.analyse(compiler)

  code_size: ( ) ->  @caller.code_size()+sum([x.code_size() for x in @args])

  side_effects: ( ) ->
    if isinstance(@caller, Var)  then true
    else if @caller.has_side_effects then return true
    else  return false # after cps, all of value have been solved before called,
  # so have no side effects.

  subst(bindings) ->  @__class__(@caller.subst(bindings),
                                 tuple(arg.subst(bindings) for arg in @args))

  optimize(env, compiler) ->
    caller = @caller
    args = optimize_args(@args, env, compiler)
    for arg in args
      if not isinstance(arg, Atom) then  break
      else element(caller.operator_fun(tuple(arg.item for arg in args))...)
    return @__class__(caller, args)

  insert_return_statement: ( ) ->  Return(@)

  pythonize(env, compiler) ->
    [exps, args, has_statement] = pythonize_args(@args, env, compiler)
    [exps+[@__class__(@caller, args)], has_statement]

  free_vars: ( ) ->
    result = set()
    for arg in @args
      result |= arg.free_vars()
    return result

  to_code(compiler) ->
    if not @caller.operator[0].isalpha()
      return "(#{@args[0].to_code(compiler)})#{ @caller.to_code(compiler)}(#{@args[1].to_code(compiler)})"
    else"(#{@args[0].to_code(compiler)}) #{@caller.to_code(compiler)} (#{ @args[1].to_code(compiler)})"

  toString: ( ) ->  "#{@caller}(#{', '.join([repr(arg) for arg in @args])})"

class VirtualOperation extends Element
  constructor: (args...) ->
    if @arity>=0
      assert len(args)==@arity,  "#{@__class__.__name__} should have #{@__class__.arity} arguments."
    @args = args

  __call__: (args...) ->  Apply(args)
  find_assign_lefts: ( ) ->  set()
  side_effects: ( ) ->  true
  analyse: (compiler) -> for arg in @args then arg.analyse(compiler)
  subst: (bindings) ->  @__class__(tuple(x.subst(bindings) for x in @args)...)
  code_size: ( ) ->  1
  optimize(env, compiler) ->
    if @has_side_effects then  @__class__(optimize_args(@args, env,compiler)...)

    args = optimize_args(@args, env,compiler)
    free_vars = set()
    for arg in args
      free_vars |= arg.free_vars()
    for var1 in free_vars
      assign = None
      try assign = env[var1]
      catch e
        if assign is not None then assign.dont_remove()
        result = @__class__(args...)
    return result

  bool: ( ) ->  unknown
  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  pythonize: (env, compiler) ->
    [exps, args, has_statement] = pythonize_args(@args, env, compiler)
    try self_is_statement = @is_statement
    catch e then self_is_statement = false
    return [exps+@__class__(args...), self_is_statement or has_statement]

  to_code: (compiler) ->
    if isinstance(@__class__.code_format, str)
      if @__class__.arity==0 then @__class__.code_format
      else if @__class__.arity!=-1
        @__class__.code_format % tuple(x.to_code(compiler) for x in @args)
      else
        @__class__.code_format % (', '.join([x.to_code(compiler) for x in @args]))
    else
      @__class__.code_format(compiler)

  __eq__: (x, y) ->  classeq(x, y) and x.args==y.args
  __hash__: ( ) ->  hash(@__class__.__name__)

  free_vars: ( ) ->
    result = set()
    for arg in @args
      result |= arg.free_vars()
    return result

  toString: ( ) ->
    try if @arity==0 then "il.#{@__class__.__name__}"
    catch e then "il.#{@__class__.__name__}(#{', '.join([repr(x) for x in @args])})"

class Deref extends Element
  constructor: (@item) ->
  side_effects: ( ) ->  false
  analyse(compiler) -> @item.analyse(compiler)
  subst(bindings) ->  Deref(@item.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->  @item.free_vars()
  optimize(env, compiler) ->
    item = @item.optimize(env, compiler)
    if isinstance(item, Atom) or isinstance(item, Lamda) then item
    if isinstance(item, Deref) then return item
    return Deref(item)

  pythonize(env, compiler) ->
    [exps, has_statement] = @item.pythonize(env, compiler)
    return [exps[..-1]+[@__class__(exps[-1])], has_statement]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  to_code(compiler) ->   "deref(#{@item.to_code(compiler)}, solver.bindings)"
  toString: ( ) ->  "il.Deref(#{@item})"

class EvalExpressionWithCode extends Element
  constructor: (@item) ->
  side_effects: ( ) ->  true
  analyse(compiler) -> @item.analyse(compiler)
  subst(bindings) ->  EvalExpressionWithCode(@item.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->  @item.free_vars()
  optimize(env, compiler) ->
    item = @item.optimize(env, compiler)
    if isinstance(item, Var)
      return EvalExpressionWithCode(item)
    else if isinstance(item, ExpressionWithCode)
      return item.fun.body.optimize(env, compiler)
    else return item

  pythonize(env, compiler) ->
    [exps, has_statement] = @item.pythonize(env, compiler)
    return [exps[..-1]+[@__class__(exps[-1])], has_statement]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  to_code(compiler) ->   "(#{@item.to_code(compiler)}).fun()"
  toString: ( ) ->  "il.EvalExpressionWithCode(#{@item})"

class Len extends Element
  constructor: (@item) ->
  side_effects: ( ) ->  false
  analyse(compiler) -> @item.analyse(compiler)
  subst(bindings) ->  Len(@item.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->  @item.free_vars()
  optimize(env, compiler) ->
    item = @item.optimize(env, compiler)
    if isinstance(item, Atom) or isinstance(item, MacroArgs)
      return Integer(len(item.item))
    return Len(item)

  pythonize(env, compiler) ->
    [exps, has_statement] = @item.pythonize(env, compiler)
    return [exps[..-1]+[Len(exps[-1])], has_statement]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  to_code(compiler) ->   'len(%s)'%@item.to_code(compiler)
  toString: ( ) ->  'il.Len(%s)'%@item

class In extends Element
  constructor: (@item, @container) ->
  side_effects: ( ) ->  false
  analyse: (compiler) ->
    @item.analyse(compiler)
    @container.analyse(compiler)
  subst: (bindings) ->  In(@item.subst(bindings), @container.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->
    result = set()
    result |= @item.free_vars()
    result |= @container.free_vars()
    return result

  optimize(env, compiler) ->
    item = @item.optimize(env, compiler)
    container = @container.optimize(env, compiler)
    if isinstance(item, Atom)
      if isinstance(container, Atom)
        return Bool(item.value in container.value)
      else if isinstance(container, RulesDict)
        return Bool(item.item in container.arity_body_map)
    return In(item, container)

  pythonize(env, compiler) ->
    [exps1, has_statement1] = @item.pythonize(env, compiler)
    [exps2, has_statement2] = @container.pythonize(env, compiler)
    return [exps1[..-1]+exps2[..-1]+[In(exps1[-1], exps2[-1])], has_statement1 or has_statement2]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->
    if isinstance(@item, Atom)
      if isinstance(@container, Atom)
        return @item.value in @container.value
      else if isinstance(@container, RulesDict)
        return [@item.value, @container.arity_body_map]
    return unknown

  to_code: (compiler) ->   "(#{@item.to_code(compiler)}) in (#{@container.to_code(compiler)})"
  toString: ( ) ->  "il.In(#{@item}, #{@container})"

class GetItem extends Element
  constructor: (@container, @index) ->
  side_effects: ( ) ->  false
  analyse: (compiler) ->
    @index.analyse(compiler)
    @container.analyse(compiler)
  subst: (bindings) ->  GetItem(@container.subst(bindings), @index.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->
    result = set()
    result |= @index.free_vars()
    result |= @container.free_vars()
    return result

  optimize: (env, compiler) ->
    index = @index.optimize(env, compiler)
    container = @container.optimize(env, compiler)
    if isinstance(index, Atom)
      if isinstance(container, Atom)
        return element(container.item[index.item])
    else if isinstance(container, RulesDict)
      return element(container.arity_body_map[index.item])
      #try
      #return element(container.arity_body_map[index.item])
      #catch e
      #return GetItem(container, index)
    else if isinstance(container, MacroArgs)
      return container.item[index.item]
    return GetItem(container, index)

  pythonize(env, compiler) ->
    [container_exps, has_statement1] = @container.pythonize(env, compiler)
    [index_exps, has_statement2] = @index.pythonize(env, compiler)
    return [container_exps[..-1]+index_exps[..-1]+[GetItem(container_exps[-1], index_exps[-1])], has_statement1 or has_statement2]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->
    if isinstance(@index, Atom)
      if isinstance(@container, Atom)
        return Bool(bool(@container.value[@index.value]))
    else if isinstance(@container, RulesDict)
      return Bool(bool(@container.arity_body_map[@index.value]))
    return unknown
  to_code(compiler) ->   "(#{@container.to_code(compiler)})[#{@index.to_code(compiler)}]"
  toString: ( ) ->  "il.GetItem(#{@container}, #{@index})"

class ListAppend extends Element
  is_statement: false

  constructor: (@container, @value) ->
  side_effects: ( ) ->  true
  analyse(compiler) ->
    @value.analyse(compiler)
    @container.analyse(compiler)
  subst(bindings) ->  ListAppend(@container.subst(bindings), @value.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->
    result = set()
    result |= @value.free_vars()
    result |= @container.free_vars()
    return result
  optimize(env, compiler) ->
    value = @value.optimize(env, compiler)
    return ListAppend(@container, value)

  find_assign_lefts: ( ) ->  if isinstance(@container, Var) then set([@container]) else set()

  pythonize(env, compiler) ->
    [container_exps, has_statement1] = @container.pythonize(env, compiler)
    [value_exps, has_statement2] = @value.pythonize(env, compiler)
    return [container_exps[..-1]+value_exps[..-1]+[ListAppend(container_exps[-1], value_exps[-1])],
            has_statement1 or has_statement2]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->  false
  to_code(compiler) ->   "#{@container.to_code(compiler)}.append(#{@value.to_code(compiler)})"
  toString: ( ) ->  "il.ListAppend(#{@container}, #{@value})"

catch_cont_map = SolverVar('catch_cont_map')

class PushCatchCont extends Element
  is_statement: false

  constructor: (@tag, @cont) ->
  side_effects: ( ) ->  true

  analyse(compiler) ->
    @tag.analyse(compiler)
    @cont.analyse(compiler)

  subst(bindings) ->  PushCatchCont(@tag.subst(bindings), @cont.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->
    result = set([catch_cont_map])
    result |= @tag.free_vars()
    result |= @cont.free_vars()
    return result

  optimize(env, compiler) ->
    tag = @tag.optimize(env, compiler)
    cont = @cont.optimize(env, compiler)
    return PushCatchCont(tag, cont)

  pythonize(env, compiler) ->
    [tag_exps, has_statement1] = @tag.pythonize(env, compiler)
    [cont_exps, has_statement2] = @cont.pythonize(env, compiler)
    return [tag_exps[..-1]+cont_exps[..-1]+[PushCatchCont(tag_exps[-1], cont_exps[-1])], true]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->  false
  to_code(compiler) ->  "solver.catch_cont_map.setdefault(#{@tag}, []).append(#{@cont})"
  toString: ( ) ->  "il.PushCatchCont(#{@tag}, #{@cont})"

class SetBinding extends Element
  is_statement: true
  constructor: (@var1, @value) ->
  side_effects: ( ) ->  true

  analyse(compiler) ->
    @var1.analyse(compiler)
    @value.analyse(compiler)

  subst(bindings) ->  SetBinding(@var1.subst(bindings), @value.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->  @value.free_vars()

  optimize(env, compiler) ->
    value = @value.optimize(env, compiler)
    return SetBinding(@var1, value)

  pythonize(env, compiler) ->
    var1 = @var1.item if isinstance(@var1, Deref) else @var1
    [var_exps, has_statement1] = [[var1], false]
    [value_exps, has_statement2] = @value.pythonize(env, compiler)
    return [var_exps[..-1]+value_exps[..-1]+[SetBinding(var_exps[-1], value_exps[-1])], true]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->  false
  to_code(compiler) ->  "solver.bindings[#{@var1.to_code(compiler)}] = #{ @value.to_code(compiler)}"
  toString: ( ) ->  "il.SetBinding(#{@var1}, #{@value})"

class FindCatchCont extends Element
  is_statement = false

  constructor: (@tag) ->
  side_effects: ( ) ->  true
  __call__(value) ->  Apply([value])
  analyse(compiler) -> @tag.analyse(compiler)
  subst(bindings) ->  FindCatchCont(@tag.subst(bindings))
  code_size: ( ) ->  1
  free_vars: ( ) ->
    result = set([catch_cont_map])
    result |= @tag.free_vars()
    return result

  optimize(env, compiler) ->
    tag = @tag.optimize(env, compiler)
    return FindCatchCont(tag)

  pythonize(env, compiler) ->
    [tag_exps, has_statement1] = @tag.pythonize(env, compiler)
    return [tag_exps[..-1]+[FindCatchCont(tag_exps[-1])], true]

  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->  false
  to_code: (compiler) ->  "solver.find_catch_cont(#{@tag})"
  toString: ( ) ->  "il.FindCatchCont(#{@tag})"
  AddAssign(var1, value) ->  Assign(var1, BinaryOperationApply(add, [var1, value]))

class IsMacro extends Element
  constructor: (@item) ->
  side_effects: ( ) ->  false
  free_vars: ( ) ->  @item.free_vars()
  analyse: (compiler) -> @item.analyse(compiler)
  subst: (bindings) ->  @__class__(@item.subst(bindings))
  code_size: ( ) ->  1
  optimize: (env, compiler) ->  @__class__(@item.optimize(env, compiler))
  pythonize: (env, compiler) ->
    [exps, has_statement] = @item.pythonize(env, compiler)
    return [exps[..-1]+[@__class__(exps[-1])], has_statement]
  insert_return_statement: ( ) ->  Return(@)
  replace_return_with_yield: ( ) ->  @
  bool: ( ) ->
    if isinstance(@item, Macro) then true
    else if isinstance(@item, Lamda) then false
    else thenn unknown

  to_code: (compiler) ->   "isinstance(#{@item.to_code(compiler)}, Macro)"%
  toString: ( ) ->  "il.IsMacro(#{@item})"

class IsMacroRules extends IsMacro
  bool: ( ) ->
    if isinstance(@item, MacroRules) then true
    else if isinstance(@item, Lamda) then false
    else unknown

  to_code: (compiler) ->   "isinstance(#{item.to_code(compiler)}, MacroRules)"
  toString: ( ) ->  "il.IsMacroRules(#{@item})"
vop(name, arity, code_format, has_side_effects) ->
  class Vop extends VirtualOperation
    name: name
    __name__: name
    arity: arity
    code_format: code_format
    is_statement: false
    has_side_effects: has_side_effects
  return Vop

class VirtualOperation2 extends VirtualOperation
  insert_return_statement: ( ) ->  Begin((Return()))
  replace_return_with_yield: ( ) ->  @

vop2(name, arity, code_format, has_side_effects) ->
  class Vop extends VirtualOperation2
    __name__:name
    name: name
    arity: arity
    code_format: code_format
    is_statement: true
    has_side_effects: has_side_effects
  return Vop

class LogicOperation extends VirtualOperation
class BinaryLogicOperation extends VirtualOperation
class UnaryLogicOperation extends VirtualOperation

Call_to_code(compiler) ->  "(#{@args[0].to_code(compiler)})(#{', '.join([x.to_code(compiler) for x in @args[1..]])})"
Call = vop('Call', -1, Call_to_code, true)

Attr = vop('Attr', 2, '%s.%s', false)

AttrCall_to_code(compiler) ->  "#{@args[0].to_code(compiler)}(#{', '.join([x.to_code(compiler) for x in @args[1..]])})"
AttrCall = vop('AttrCall', -1, AttrCall_to_code, true)

SetItem = vop2('SetItem', 3, '(%s)[%s] = %s', true)
#  SetItem(item, key, value) ->  Assign(GetItem(item, key), value)

Slice2 = vop('Slice2', 2, '%s:%s', false)

Not = vop('Not', 1, "not %s", false)

Isinstance = vop('Isinstance', 2, "isinstance(%s, %s)", false)

empty_list = List([])

empty_dict = Dict({})

RaiseTypeError = vop2('RaiseTypeError', 1, 'throw make_new %s', true)

RaiseException = vop2('RaiseException', 1, 'throw make_new %s', true)

QuoteItem_to_code(compiler) ->  '%s'%repr(@args[0])
QuoteItem = vop('QuoteItem', 1, QuoteItem_to_code, false)

UnquoteSplice = vop('UnquoteSplice', 1, "UnquoteSplice(%s)", false)

MakeTuple = vop('MakeTuple', 1, 'tuple(%s)', false)

Cle = vop('Cle', 3, '(%s) <= (%s) <= (%s)', false)

Cge = vop('Cge', 3, '(%s) >= (%s) >= (%s)', false)

failcont = SolverVar('fail_cont')

SetFailCont(cont) ->  Assign(failcont, cont)

append_failcont(compiler, exps...) ->
  v =  compiler.new_var(ConstLocalVar('v'))
  fc = compiler.new_var(ConstLocalVar('fc'))
  return Begin(
                Assign(fc, failcont),
                SetFailCont(
                             clamda(v,
                                    SetFailCont(fc),
                                    begin(exps...),
                                    fc(v)))
              )

cut_cont = SolverVar('cut_cont')

SetCutCont(cont) ->  Assign(cut_cont, cont)

cut_or_cont = SolverVar('cut_or_cont')

SetCutOrCont(cont) ->  Assign(cut_or_cont, cont)

IsLogicVar = vop('IsLogicVar', 1, 'isinstance(%s, LogicVar)', false)


DelBinding = vop2('DelBinding', 1, 'del solver.bindings[%s]', true)
DelItem = vop2('DelItem', 2, 'del %s[%s]', true)


GetValue = vop('GetValue', 1, 'get_value(%s, {}, solver.bindings)', false)

parse_state = SolverVar('parse_state')
SetParseState(state) ->  Assign(parse_state, state)

Unify = vop('Unify', 2, 'solver.unify(%s, %s)', false)
Nil = vop('Nil', 0, 'nil', false)
nil = Nil()


bindings = SolverVar('bindings')
SetBindings(bindings1) ->  Assign(bindings, bindings1)

ConsHead = vop('ConsHead', 1, '(%s).head', false)
ConsTail = vop('ConsTail', 1, '(%s).tail', false)

Optargs = vop('Optargs', 1, '*%s', false)

Continue = vop('Continue', 0, "continue\n", false)
continue_ = Continue()

Prin = vop2('Prin', 1, "print %s,", true)
PrintLn = vop2('PrintLn', 1, "print %s", true)

DelListItem = vop2('DelListItem', 2, 'del %s[%s]', true)

MakeList = vop('MakeList', 1, '[%s]', false)


Copy = vop('Copy', 1, '(%s).copy()', false)

Assert = vop('Assert', 1, 'assert %s', false)
Int = Symbol('int')

Format_to_code(compiler) ->  "#{@args[0].to_code(compiler)}%#{', '.join(x.to_code(compiler) for x in @args[1..])}"

Format = vop('Format', -1,Format_to_code, false)

Concat_to_code(compiler) ->  '%s'%''.join([arg.to_code(compiler) for arg in @args])
Concat = vop('Concat', -1, Concat_to_code, false)

Format_to_code(compiler) ->  "file(#{@args[0].to_code(compiler)}, #{', '.join(x.to_code(compiler) for x in @args[1...])})"

OpenFile = vop('OpenFile', -1, Format_to_code, true)
CloseFile = vop('CloseFile', 1, "%s.close()", true)
ReadFile = vop('ReadFile', 1, '%s.read()', true)
Readline = vop('ReadLine', 1, '%s.readline()', true)
Readlines = vop('Readlines', 1, '%s.readlines()', true)
WriteFile = vop('WriteFile', 2, '%s.write(%s)', true)

######################################
# builtins

