// Generated by CoffeeScript 1.6.2
(function() {
  var ArgumentError, Trail, Var, andp, binaryPredicate, callfc, core, findall1, findall2, general, il, macro, notunifyFun, notunifyList, notunifyListFun, orp, orpFun, runner, special, unaryPredicate, unifyFun, unifyList, unifyListFun, _,
    __slice = [].slice;

  _ = require('underscore');

  ArgumentError = (core = require("../core")).ArgumentError;

  il = require("../interlang");

  general = require("./general");

  special = core.special;

  macro = core.macro;

  Trail = core.Trail;

  Var = core.Var;

  exports.succeed = special(0, 'succeed', function(compiler, cont) {
    return il["return"](cont.call(true));
  })();

  exports.fail = special(0, 'fail', function(compiler, cont) {
    return il["return"](il.failcont.call(false));
  })();

  exports.prependFailcont = special(1, 'setFailcont', function(compiler, cont, fun) {
    return function(v) {
      var fc;

      fc = compiler.failcont;
      compiler.failcont = function(v) {
        fun();
        return fc(v);
      };
      return cont(v);
    };
  });

  exports.andp = andp = special(null, 'andp', function() {
    var args, compiler, cont;

    compiler = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return compiler.expsCont(args, cont);
  });

  orpFun = function() {
    var args, compiler, cont, fc, length, orcont, state, trail, x, xcont, y, ycont;

    compiler = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return compiler.cont(args[0], cont);
    } else if (length === 2) {
      x = args[0];
      y = args[1];
      xcont = compiler.cont(x, cont);
      ycont = compiler.cont(y, cont);
    } else {
      x = args[0];
      y = args.slice(1);
      xcont = compiler.cont(x, cont);
      ycont = orpFun.apply(null, [compiler, cont].concat(__slice.call(y)));
    }
    trail = state = fc = null;
    orcont = il.clamda(v, il.undotrail(trail), il.assign(il.state, state), il.setfailcont(fc), il["return"](ycont.call(v)));
    return il.clamda(v, il.assign(trail, il["new"](il.symbol(Trail)), state = compiler.state, fc = compiler.failcont, compiler.trail = trail, compiler.failcont = orcont, [xcont, null]));
  };

  exports.orp = orp = special(null, 'orp', orpFun);

  exports.cutable = special(1, 'cutable', function(compiler, cont, x) {
    var cc, xcont;

    cc = null;
    xcont = compiler.cont(x, function(v) {
      compiler.cutCont = cc;
      return [cont, v];
    });
    return function(v) {
      cc = compiler.cutCont;
      return xcont(null);
    };
  });

  exports.cut = special(0, 'cut', function(compiler, cont) {
    return function(v) {
      compiler.failcont = compiler.cutCont;
      return cont(v);
    };
  })();

  exports.ifp = special([2, 3], 'ifp', function(compiler, cont, test, action, else_) {
    var actionCont, cc, ccCont, elseCont, resultCont;

    cc = null;
    ccCont = function(v) {
      compiler.cutCont = cc;
      return cont(v);
    };
    actionCont = compiler.cont(action, ccCont);
    resultCont = compiler.cont(test, function(v) {
      compiler.failcont = compiler.cutCont;
      return actionCont(v);
    });
    if (else_ != null) {
      elseCont = compiler.cont(else_, ccCont);
      return function(v) {
        var fc, state, trail;

        cc = compiler.cutCont;
        trail = new Trail;
        state = compiler.state;
        fc = compiler.failcont;
        compiler.failcont = function(v) {
          trail.undo();
          compiler.state = state;
          compiler.failcont = function(v) {
            compiler.failcont = fc;
            return fc(v);
          };
          return elseCont(v);
        };
        return resultCont(v);
      };
    } else {
      return function(v) {
        cc = compiler.cutCont;
        return resultCont(v);
      };
    }
  });

  exports.notp = special(1, 'notp', function(compiler, cont, x) {
    var fc, mycont;

    fc = null;
    mycont = compiler.cont(x, function(v) {
      compiler.failcont = fc;
      return [fc, v];
    });
    return function(v) {
      var state, trail;

      trail = compiler.trail;
      compiler.trail = new Trail;
      fc = compiler.failcont;
      state = compiler.state;
      compiler.failcont = function(v) {
        compiler.trail.undo();
        compiler.trail = trail;
        compiler.state = state;
        compiler.failcont = fc;
        return [cont, v];
      };
      return mycont(v);
    };
  });

  exports.repeat = special(0, 'repeat', function(compiler, cont) {
    return function(v) {
      compiler.failcont = cont;
      return [cont, null];
    };
  })();

  exports.findall = function(exp, result, template) {
    if (result === void 0) {
      return findall1(exp);
    } else {
      return findall2(exp, result, template);
    }
  };

  findall1 = special(1, 'findall', function(compiler, cont, exp) {
    var fc, findallDone, findnext;

    fc = null;
    findnext = compiler.cont(exp, function(v) {
      return compiler.failcont(v);
    });
    findallDone = function(v) {
      compiler.failcont = fc;
      return [cont, v];
    };
    return function(v) {
      fc = compiler.failcont;
      compiler.failcont = findallDone;
      return [findnext, v];
    };
  });

  findall2 = special(3, 'findall', function(compiler, cont, exp, result, template) {
    var fc, findallDone, findnext, result1;

    result1 = null;
    fc = null;
    findnext = compiler.cont(exp, function(v) {
      result1.push(compiler.trail.getvalue(template));
      return compiler.failcont(v);
    });
    findallDone = function(v) {
      compiler.failcont = fc;
      return [cont, v];
    };
    return function(v) {
      result1 = [];
      result.bind(result1, compiler.trail);
      fc = compiler.failcont;
      compiler.failcont = findallDone;
      return [findnext, v];
    };
  });

  exports.once = special(1, 'once', function(compiler, cont, x) {
    var cont1, fc;

    fc = null;
    cont1 = compiler.cont(x, function(v) {
      compiler.failcont = fc;
      return cont(v);
    });
    return function(v) {
      fc = compiler.failcont;
      return [cont1, null];
    };
  });

  exports.is_ = special(2, 'is_', function(compiler, cont, vari, exp) {
    return compiler.cont(exp, function(v) {
      vari.bind(v, compiler.trail);
      return [cont, true];
    });
  });

  exports.bind = special(2, 'bind', function(compiler, cont, vari, term) {
    return function(v) {
      vari.bind(compiler.trail.deref(term), compiler.trail);
      return [cont, true];
    };
  });

  exports.unifyFun = unifyFun = function(compiler, cont, x, y) {
    return function(v) {
      if (compiler.trail.unify(x, y)) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    };
  };

  exports.unify = special(2, 'unify', unifyFun);

  exports.notunifyFun = notunifyFun = function(compiler, cont, x, y) {
    return function(v) {
      if (!compiler.trail.unify(x, y)) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    };
  };

  exports.notunify = special(2, 'notunify', notunifyFun);

  exports.unifyListFun = unifyListFun = function(compiler, cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        compiler.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (!compiler.trail.unify(xs[i], ys[i])) {
            return compiler.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.unifyList = unifyList = special(2, 'unifyList', unifyListFun);

  exports.notunifyListFun = notunifyListFun = function(compiler, cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        compiler.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (compiler.trail.unify(xs[i], ys[i])) {
            return compiler.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.notunifyList = notunifyList = special(2, 'notunifyList', notunifyListFun);

  exports.rule = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname_rule';
    }
    return macro(arity, name, function() {
      var args, body, clauses, head, i, length, result;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clauses = fun.apply(null, args);
      length = clauses.length;
      if (length === 0) {
        return succeed;
      }
      result = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = length - 1; _i < _ref; i = _i += 2) {
          head = clauses[i];
          body = clauses[i + 1];
          _results.push(andp(unifyList(head, args), body));
        }
        return _results;
      })();
      if (length - Math.floor(length / 2) * 2 === 1) {
        result.push(clauses[length - 1]);
      }
      return orp.apply(null, result);
    });
  };

  runner = function(compiler, cont) {
    return function(v) {
      var _ref;

      while (!compiler.done) {
        _ref = cont(v), cont = _ref[0], v = _ref[1];
      }
      compiler.done = false;
      return v;
    };
  };

  callfc = require("./lisp").callfc;

  exports.callfc = callfc;

  exports.truep = special(1, 'truep', function(compiler, cont, fun, x) {
    return compiler.cont(x, function(x1) {
      if (x1) {
        return cont(x1);
      } else {
        return compiler.failcont(x1);
      }
    });
  });

  exports.falsep = special(1, 'falsep', function(compiler, cont, fun, x) {
    return compiler.cont(x, function(x1) {
      if (!x1) {
        return cont(x1);
      } else {
        return compiler.failcont(x1);
      }
    });
  });

  exports.unaryPredicate = unaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(1, name, function(compiler, cont, x) {
      return compiler.cont(x, function(x1) {
        var result;

        result = fun(x1);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      });
    });
  };

  exports.binaryPredicate = binaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(2, name, function(compiler, cont, x, y) {
      var x1, ycont;

      x1 = null;
      return ycont = compiler.cont(y, function(y1) {
        var result;

        result = fun(x1, y1);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      }, compiler.cont(x, function(v) {
        x1 = v;
        return ycont(null);
      }));
    });
  };

  exports.eqp = binaryPredicate(function(x, y) {
    return x === y;
  });

  exports.nep = binaryPredicate(function(x, y) {
    return x !== y;
  });

  exports.ltp = binaryPredicate(function(x, y) {
    return x < y;
  });

  exports.lep = binaryPredicate(function(x, y) {
    return x <= y;
  });

  exports.gtp = binaryPredicate(function(x, y) {
    return x > y;
  });

  exports.gep = binaryPredicate(function(x, y) {
    return x >= y;
  });

  exports.ternaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(3, name, function(compiler, cont, x, y, z) {
      var ycont, zcont;

      zcont = compiler.cont(z, function(z) {
        var result;

        result = fun(x, y, z);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      });
      return ycont = compiler.cont(y, function(v) {
        y = v;
        return zcont(null);
      }, compiler.cont(x, function(v) {
        x = v;
        return ycont(null);
      }));
    });
  };

  exports.functionPredicate = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(arity, name, function() {
      var args, compiler, cont;

      compiler = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return compiler.argsCont(args, function(params) {
        var result;

        result = fun.apply(null, params);
        if (result) {
          return cont(result);
        } else {
          return compiler.failcont(result);
        }
      });
    });
  };

  exports.between = special(3, 'between', function(compiler, cont, fun, x, y, z) {
    var y1, ycont, z1, zcont;

    y1 = z1 = null;
    zcont = compiler.cont(z, function(zz) {
      var fc, y11;

      if (x1 instanceof core.Var) {
        throw core.TypeError(x);
      } else if (y1 instanceof core.Var) {
        throw new core.TypeError(y);
      }
      if (y1 instanceof core.Var) {
        y11 = y1;
        fc = compiler.failcont;
        compiler.failcont = function(v) {
          y11++;
          if (y11 > z1) {
            return fc(v);
          } else {
            y1.bind(y11, compiler.trail);
            return cont(y11);
          }
        };
        y1.bind(y11, compiler.trail);
        return cont(y11);
      } else {
        if ((x1 <= y1 && y1 <= z1)) {
          return cont(true);
        } else {
          return compiler.failcont(false);
        }
      }
    });
    ycont = compiler.cont(y, function(v) {
      y1 = v;
      return zcont(null);
    });
    return compiler.cont(x, function(v) {
      var x1;

      x1 = v;
      return ycont(null);
    });
  });

  exports.rangep = special(2, 'rangep', function(compiler, cont, x, y) {
    var x1, ycont;

    x1 = null;
    ycont = compiler.cont(y, function(y) {
      var fc, result;

      if (x1 instanceof core.Var) {
        throw core.TypeError(x);
      } else if (y1 instanceof core.Var) {
        throw new core.TypeError(y);
      } else if (x1 > y1) {
        return compiler.failcont(false);
      }
      result = x1;
      fc = compiler.failcont;
      compiler.failcont = function(v) {
        result++;
        if (result > y1) {
          return fc(v);
        } else {
          return cont(result);
        }
      };
      return cont(result);
    });
    return compiler.cont(x, function(v) {
      x1 = v;
      return ycont(null);
    });
  });

  exports.varp = special(1, 'varp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {
      if (x1 instanceof core.Var) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    });
  });

  exports.nonvarp = special(1, 'notvarp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {
      if (!(x1 instanceof core.Var)) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    });
  });

  exports.freep = special(1, 'freep', function(compiler, cont, x) {
    return function(v) {
      if (compiler.trail.deref(x) instanceof Var) {
        return cont(true);
      } else {
        return compiler.failcont(false);
      }
    };
  });

  exports.numberp = special(1, 'numberp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isNumber(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.stringp = special(1, 'stringp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isString(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.atomp = special(1, 'atomp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isNumber(x1) || _.isString(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.listp = special(1, 'listp', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, _.isArray(x1) ? cont(true) : compiler.failcont(false));
  });

  exports.callablep = special(1, 'callablep', function(compiler, cont, x) {
    return compiler.cont(x, function(x1) {}, x1 instanceof core.Apply ? cont(true) : compiler.failcont(false));
  });

}).call(this);

/*
//@ sourceMappingURL=logic.map
*/
