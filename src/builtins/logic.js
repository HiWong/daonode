// Generated by CoffeeScript 1.6.2
(function() {
  var Trail, binaryPredicate, macro, notunifyFun, notunifyList, notunifyListFun, orp_fun, solve, solver, special, unaryPredicate, unifyFun, unifyList, unifyListFun,
    __slice = [].slice;

  solve = require("../../src/solve");

  solver = solve.solver;

  special = solve.special;

  macro = solve.macro;

  Trail = solve.Trail;

  exports.succeed = special('succeed', function(cont) {
    return cont;
  })();

  exports.fail = special('fail', function(cont) {
    return function() {
      return solver.failcont();
    };
  })();

  exports.andp = special('andp', function() {
    var args, cont;

    cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return solver.expsCont(args, cont);
  });

  exports.cutable = special('cutable', function(cont, x) {
    return function() {
      var cc;

      cc = solver.cutCont;
      return solver.cont(x, function() {
        solver.cutCont = cc;
        return cont();
      })(null);
    };
  });

  exports.cut = special('cut', function(cont) {
    return function() {
      solver.failcont = solver.cutCont;
      return cont();
    };
  })();

  exports.ifp = special('ifp', function(cont, test, action, else_) {
    return function() {
      var actionCont, cc, elseCont, fc, fc2, newCont, state, trail;

      cc = solver.cutCont;
      newCont = function() {
        solver.cutCont = cc;
        return cont();
      };
      actionCont = solver.cont(action, newCont);
      elseCont = solver.cont(else_, newCont);
      if (else_) {
        trail = new Trail;
        state = solver.state;
        fc = solver.failcont;
        fc2 = function() {
          solver.failcont = fc2;
          return fc();
        };
        solver.failcont = function() {
          trail.undo();
          solver.state = state;
          solver.failcont = fc2;
          return elseCont();
        };
      }
      return solver.cont(test, function() {
        solver.failcont = solver.cutCont;
        return actionCont();
      });
    };
  });

  exports.orp = special('orp', function(cont, x, y) {
    var xcont, ycont;

    xcont = solver.cont(x, cont);
    ycont = solver.cont(y, cont);
    return function() {
      var fc, state, trail;

      trail = new Trail;
      state = solver.state;
      fc = solver.failcont;
      solver.failcont = function() {
        trail.undo();
        solver.state = state;
        solver.failcont = fc;
        return ycont;
      };
      solver.trail = trail;
      return xcont;
    };
  });

  orp_fun = function() {
    var args, cont, length, x, xcont, y, ycont;

    cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else if (length === 2) {
      x = args[0];
      y = args[1];
      xcont = solver.cont(x, cont);
      ycont = solver.cont(y, cont);
    } else {
      x = args[0];
      y = args.slice(1);
      xcont = solver.cont(x, cont);
      ycont = orp_fun.apply(null, [cont].concat(__slice.call(y)));
    }
    return (function(xcont, ycont) {
      return function() {
        var fc, state, trail;

        trail = new Trail;
        state = solver.state;
        fc = solver.failcont;
        solver.failcont = function() {
          trail.undo();
          solver.state = state;
          solver.failcont = fc;
          return ycont;
        };
        solver.trail = trail;
        return xcont;
      };
    })(xcont, ycont);
  };

  exports.orp = special('orp', orp_fun);

  exports.notp = special('notp', function(cont, x) {
    return function(v) {
      var fc, state, trail;

      trail = solver.trail;
      solver.trail = new Trail;
      fc = solver.failcont;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return [cont, v];
      };
      return solver.cont(x, function(v) {
        solver.failcont = fc;
        return [fc, v];
      })(v);
    };
  });

  exports.repeat = special('repeat', function(cont) {
    return function(v) {
      solver.failcont = cont;
      return [cont, null];
    };
  })();

  exports.call = special('call', function() {
    var args, cont;

    cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return solver.argsCont(args, function(params, solver) {
      var goal, _ref;

      goal = params[0];
      return solver.cont((_ref = goal.caller).callable.apply(_ref, goal.args.concat(params.slice(1))), cont)(null);
    });
  });

  exports.findall = special('findall', function(cont, exp) {
    var findallcont;

    findallcont = solver.cont(exp, function(v) {
      return [solver.failcont, v];
    });
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return [cont, v];
      };
      return [findallcont, v];
    };
  });

  exports.xfindall = special('findall', function(cont, exp) {
    var findallcont;

    findallcont = solver.cont(exp, solver.failcont);
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return [cont, v];
      };
      return [findallcont, v];
    };
  });

  exports.once = special('once', function(cont, x) {
    return function(v) {
      var fc;

      fc = solver.failcont;
      return [
        solver.cont(x, function(v) {
          solver.failcont = fc;
          return [cont, v];
        }), null
      ];
    };
  });

  exports.is_ = special('is_', function(cont, vari, exp) {
    return solver.cont(exp, function(v) {
      vari.bind(v, solver.trail);
      return [cont, true];
    });
  });

  exports.unifyFun = unifyFun = function(cont, x, y) {
    return function(v) {
      if (solver.trail.unify(x, y)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    };
  };

  exports.unify = special('unify', unifyFun);

  exports.notunifyFun = notunifyFun = function(cont, x, y) {
    return function(v) {
      if (!solver.trail.unify(x, y)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    };
  };

  exports.notunify = special('notunify', notunifyFun);

  exports.unifyListFun = unifyListFun = function(cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (!solver.trail.unify(xs[i], ys[i])) {
            return solver.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.unifyList = unifyList = special('unifyList', unifyListFun);

  exports.notunifyListFun = notunifyListFun = function(cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (solver.trail.unify(xs[i], ys[i])) {
            return solver.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.notunifyList = notunifyList = special('notunifyList', notunifyListFun);

  exports.rule = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname_rule';
    }
    return macro(name, function() {
      var args, body, clauses, head, i;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clauses = fun.apply(null, args);
      clauses = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = clauses.length; _i < _ref; i = _i += 2) {
          head = clauses[i];
          body = clauses[i + 1];
          _results.push(andp(unifyList(head, args), body));
        }
        return _results;
      })();
      return orp.apply(null, clauses);
    });
  };

  exports.callfc = special('callfc', function(cont, fun) {
    return function(v) {
      var result;

      result = fun(solver.failcont)[1];
      solver.done = false;
      return cont(result);
    };
  });

  exports.truep = special('truep', function(cont, fun, x) {
    return solver.cont(x, function(x1) {
      if (x1) {
        return cont(x1);
      } else {
        return solver.failcont(x1);
      }
    });
  });

  exports.falsep = special('falsep', function(cont, fun, x) {
    return solver.cont(x, function(x1) {
      if (!x1) {
        return cont(x1);
      } else {
        return solver.failcont(x1);
      }
    });
  });

  exports.unaryPredicate = unaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(name, function(cont, x) {
      return solver.cont(x, function(x1) {
        var result;

        result = fun(x1);
        if (result) {
          return cont(result);
        } else {
          return solver.failcont(result);
        }
      });
    });
  };

  exports.binaryPredicate = binaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(name, function(cont, x, y) {
      return solver.cont(x, function(x1) {
        return solver.cont(y, function(y1) {
          var result;

          result = fun(x1, y1);
          if (result) {
            return cont(result);
          } else {
            return solver.failcont(result);
          }
        });
      });
    });
  };

  exports.eqp = binaryPredicate(function(x, y) {
    return x === y;
  });

  exports.nep = binaryPredicate(function(x, y) {
    return x !== y;
  });

  exports.ltp = binaryPredicate(function(x, y) {
    return x < y;
  });

  exports.lep = binaryPredicate(function(x, y) {
    return x <= y;
  });

  exports.gtp = binaryPredicate(function(x, y) {
    return x > y;
  });

  exports.gep = binaryPredicate(function(x, y) {
    return x >= y;
  });

  exports.ternaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(name, function(cont, x, y, z) {
      return solver.cont(x, function(x1) {
        return solver.cont(y, function(y1) {
          return solver.cont(z, function(z1) {
            var result;

            result = fun(x1, y1, z1);
            if (result) {
              return cont(result);
            } else {
              return solver.failcont(result);
            }
          });
        });
      });
    });
  };

  exports.functionPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(name, function() {
      var args, cont;

      cont = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return solver.argsCont(args, function(params) {
        var result;

        result = fun.apply(null, params);
        if (result) {
          return cont(result);
        } else {
          return solver.failcont(result);
        }
      });
    });
  };

  exports.between = special('between', function(cont, fun, x, y, z) {
    return solver.cont(x, function(x1) {
      return solver.cont(y, function(y1) {
        return solver.cont(z, function(z1) {
          var fc, result, y11;

          if (x1 instanceof dao.Var) {
            throw dao.TypeError(x);
          } else if (y1 instanceof dao.Var) {
            throw new dao.TypeError(y1);
          }
          if (y1 instanceof dao.Var) {
            y11 = y1;
            fc = solver.failcont;
            solver.failcont = function(v) {
              y11++;
              if (y11 > z1) {
                return fc(v);
              } else {
                y1.bind(y11, solver.trail);
                return cont(y11);
              }
            };
            y1.bind(y11, solver.trail);
            return cont(y11);
          } else {
            result = (x1 <= y1 && y1 <= z1);
            if (result) {
              return cont(true);
            } else {
              return solver.failcont(false);
            }
          }
        });
      });
    });
  });

  exports.rangep = special('between', function(cont, fun, x, y) {
    return solver.cont(x, function(x1) {
      return solver.cont(y, function(y1) {
        var fc, result;

        if (x1 instanceof dao.Var) {
          throw dao.TypeError(x);
        } else if (y1 instanceof dao.Var) {
          throw new dao.TypeError(y);
        } else if (x1 > y1) {
          return solver.failcont(false);
        }
        result = x1;
        fc = solver.failcont;
        solver.failcont = function(v) {
          result++;
          if (result > y1) {
            return fc(v);
          } else {
            return cont(result);
          }
        };
        return cont(result);
      });
    });
  });

  exports.varp = special('varp', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (x1 instanceof dao.Var) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.nonvarp = special('varp', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (!(x1 instanceof dao.Var)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.numberp = special('numberp', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (_.isNumber(x1)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.stringp = special('stringp', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (_.isString(x1)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.atomp = special('atomp', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (_.isNumber(x1) || _.isString(x1)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.arrayp = special('arrayp', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (_.isArray(x1)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.callablep = special('callablep', function(cont, x) {
    return solver.cont(x, function(x1) {
      if (x1 instanceof dao.Apply) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

}).call(this);

/*
//@ sourceMappingURL=logic.map
*/
