// Generated by CoffeeScript 1.6.2
(function() {
  var add, assign, begin, core, eq, eval_, funcall, if_, inc, jsfun, jsobject, lamda, macall, macro, print_, qq, quote, solve, string, suffixinc, uq, uqs, vari, xexports, _ref;

  solve = (core = require('../core')).solve;

  _ref = require('../util'), string = _ref.string, begin = _ref.begin, quote = _ref.quote, assign = _ref.assign, print_ = _ref.print_, jsobject = _ref.jsobject, funcall = _ref.funcall, macall = _ref.macall, lamda = _ref.lamda, macro = _ref.macro, jsfun = _ref.jsfun, if_ = _ref.if_, add = _ref.add, eq = _ref.eq, inc = _ref.inc, suffixinc = _ref.suffixinc, eval_ = _ref.eval_, qq = _ref.qq, uq = _ref.uq, uqs = _ref.uqs;

  vari = function(name) {
    return name;
  };

  xexports = {};

  xexports.Test = {
    "test fun2": function(test) {
      var f, m;

      f = function(x) {
        if (x === 0) {
          return print_(x);
        }
      };
      m = fun2(1, f);
      test.equal(solve(m(sub(5, 1))), null);
      return test.done();
    }
  };

  exports.Test = {
    "test 1": function(test) {
      test.equal(solve(1), 1);
      return test.done();
    },
    "test begin": function(test) {
      test.equal(solve(begin(1, 2)), 2);
      return test.done();
    },
    "test quote": function(test) {
      test.equal(solve(quote(1)), 1);
      return test.done();
    },
    "test vari assign": function(test) {
      var x;

      x = 'x';
      test.equal(solve(begin(assign(x, 1), x)), 1);
      test.equal(solve(begin(assign(x, 1), inc(x))), 2);
      test.equal(solve(begin(assign(x, 1), suffixinc(x))), 1);
      return test.done();
    },
    "test js vari": function(test) {
      var console_log;

      console_log = 'console.log';
      test.equal(solve(console_log), console.log);
      return test.done();
    },
    "test jsfun": function(test) {
      var console_log, x;

      console_log = 'console.log';
      test.equal(solve(funcall(jsfun(console_log), 1)), null);
      test.equal(solve(print_(1, 2)), null);
      x = vari('x');
      test.equal(solve(begin(assign(x, 1), print_(x))), null);
      return test.done();
    },
    "test vop: add, eq": function(test) {
      test.equal(solve(add(1, 1)), 2);
      test.equal(solve(eq(1, 1)), true);
      test.equal(solve(begin(eq(1, 1), add(1, 1))), 2);
      return test.done();
    },
    "test lambda": function(test) {
      var x, y;

      x = 'x';
      y = 'y';
      test.equal(solve(funcall(lamda([x], 1), 1)), 1);
      test.equal(solve(funcall(lamda([x, y], add(x, y)), 1, 1)), 2);
      return test.done();
    }
  };

  xexports.Test = {
    "test macro": function(test) {
      var x, y, z;

      x = 'x';
      y = 'y';
      z = 'z';
      test.equal(solve(macall(macro([x], 1), print_(1))), 1);
      test.equal(solve(macall(macro([x], x), print_(1))), null);
      test.equal(solve(macall(macro([x, y, z], if_(x, y, z)), eq(1, 1), print_(1), print_(2))), null);
      return test.done();
    },
    "test eval_ quote": function(test) {
      test.equal(solve(eval_(quote(1), string('f:/daonode/lib/compiler/test/compiled2.js'))), 1);
      test.equal(solve(eval_(quote(print_(1)), string('f:/daonode/lib/compiler/test/compiled2.js'))), null);
      return test.done();
    },
    "test quasiquote": function(test) {
      var a;

      test.equal(solve(qq(1)), 1);
      a = add(1, 2);
      test.deepEqual(solve(qq(a)), a);
      test.deepEqual(solve(qq(uq(a))), 3);
      test.deepEqual(solve(qq(uqs([1, 2]))), [1, 2]);
      test.deepEqual(solve(qq(add(uqs([1, 2])))), a);
      return test.done();
    }
  };

  xexports.Test = {
    "test macro": function(test) {
      var same;

      same = macro(function(x) {
        return 1;
      });
      test.equal(solve(same(print_(1))), 1);
      same = macro(function(x) {
        return x;
      });
      test.equal(solve(same(print_(1))), null);
      test.equal(solve(same(print_(1))), null);
      return test.done();
    },
    "test macro 1": function(test) {
      var m;

      m = macro(1, function(x) {
        if (x === 0) {
          return print_(x);
        } else {
          return begin(print_(x), m(x - 1));
        }
      });
      test.equal(solve(m(5)), null);
      return test.done();
    },
    "test builtin function": function(test) {
      var f, same;

      same = fun(1, function(x) {
        return x;
      });
      test.equal(solve(same(1)), 1);
      add = fun(2, function(x, y) {
        return x + y;
      });
      test.equal(solve(add(1, 2)), 3);
      f = function(x) {
        if (x === 0) {
          return x;
        } else {
          return f(x - 1);
        }
      };
      f = fun(1, recursive('f', f));
      test.equal(solve(f(1)), 0);
      return test.done();
    }
  };

  xexports.Test = {
    "test var bind unify trail": function(test) {
      var trail, x;

      trail = new Trail;
      x = 'x';
      test.equal(x.binding, x);
      x.bind(1, trail);
      test.ok(trail.unify(1, x));
      test.ok(!trail.unify(2, x));
      trail.undo();
      test.ok(trail.unify(x, 2));
      return test.done();
    },
    "test macro": function(test) {
      var m;

      m = macro(0, 'a', function() {});
      m();
      return test.done();
    },
    "test proc,aka online function in dao": function(test) {
      var a;

      a = proc(0, 'a', function() {
        var i;

        i = 0;
        return add(1, 2);
      });
      test.equal(solve(begin(a(), a())), 3);
      test.equal(solve(begin(a(), add(1, 1))), 2);
      return test.done();
    },
    "test macro tofun": function(test) {
      var orpm;

      orpm = macro(2, function(x, y) {
        return orp(x, y);
      });
      test.equal(solve(orpm(print_(1), print_(2))), null);
      test.equal(solve(tofun(orpm)(print_(1), print_(2))), null);
      test.equal(solve(tofun(orpm)(quote(print_(1)), quote(print_(2)))), null);
      return test.done();
    },
    "test macro 2": function(test) {
      var m, x, _;

      _ = dummy('_');
      m = macro(0, function() {
        return print_(1);
      });
      x = m();
      test.equal(solve(andp(x, x)), null);
      test.equal(core.status, core.SUCCESS);
      return test.done();
    },
    "test recursive macro2": function(test) {
      var m, _;

      _ = dummy('_');
      m = macro(0, function() {
        return orp(andp(char(_), print_(_), m()), succeed);
      });
      test.equal(solve(andp(settext('abc'), m())), null);
      test.equal(core.status, core.SUCCESS);
      return test.done();
    },
    "test recursive macro1": function(test) {
      var m;

      m = macro(1, function(x) {
        if (x === 0) {
          return print_(x);
        } else {
          return begin(print_(x), m(x - 1));
        }
      });
      test.equal(solve(m(5)), null);
      test.equal(core.status, core.SUCCESS);
      return test.done();
    }
  };

}).call(this);

/*
//@ sourceMappingURL=testCore.map
*/
