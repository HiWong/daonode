// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, core, debug, general, if_, if_fun, iff_fun, il, macro, not_, special, _,
    __slice = [].slice;

  _ = require('underscore');

  core = require("../core");

  il = require("../interlang");

  general = require("./general");

  special = core.special;

  macro = core.macro;

  debug = core.debug;

  exports.quote = special(1, 'quote', function(compiler, cont, exp) {
    return il["return"](cont.call(exp));
  });

  exports.eval_ = special(1, 'eval', function(compiler, cont, exp) {
    var v;

    v = compiler.vari('v');
    return compiler.cont(exp, il.clamda(v, compiler.cont(v, cont)));
  });

  exports.assign = special(2, 'assign', function(compiler, cont, item, exp) {
    var v;

    v = compiler.vari('v');
    return compiler.cont(exp, il.clamda(v, il.assign(item.interlang(), v), il["return"](cont.call(v))));
  });

  exports.begin = special(null, 'begin', function() {
    var compiler, cont, exps;

    compiler = arguments[0], cont = arguments[1], exps = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return compiler.expsCont(exps, cont);
  });

  if_fun = function(compiler, cont, test, then_, else_) {
    var v;

    v = compiler.vari('v');
    return compiler.cont(test, il.clamda(v, il.if_(v, compiler.cont(then_, cont), compiler.cont(else_, cont))));
  };

  exports.if_ = if_ = special([2, 3], 'if_', if_fun);

  iff_fun = function(compiler, cont, clauses, else_) {
    var length, test, then_, v, _ref, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new exports.TypeError(clauses);
    } else if (length === 1) {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      return if_fun(compiler, cont, test, then_, else_);
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      v = compiler.vari('v');
      return compiler.cont(test, il.clamda(v, il.if_(v, compiler.cont(then_, cont), iff_fun(compiler, cont, clauses.slice(1), else_))));
    }
  };

  exports.iff = special(-2, 'iff', iff_fun);

  exports.block = block = special(null, 'block', function() {
    var body, compiler, cont, continues, defaultContinues, defaultExits, exits, f, fun, label, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

    compiler = arguments[0], cont = arguments[1], label = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    exits = (_ref = (_base = compiler.exits)[label]) != null ? _ref : _base[label] = [];
    exits.push(cont);
    defaultExits = (_ref1 = (_base1 = compiler.exits)['']) != null ? _ref1 : _base1[''] = [];
    defaultExits.push(cont);
    continues = (_ref2 = (_base2 = compiler.continues)[label]) != null ? _ref2 : _base2[label] = [];
    f = compiler.vari('block' + label);
    fun = il.clamda(compiler.vari('v'), null);
    continues.push(f);
    defaultContinues = (_ref3 = (_base3 = compiler.continues)['']) != null ? _ref3 : _base3[''] = [];
    defaultContinues.push(f);
    fun.body = compiler.expsCont(body, cont);
    exits.pop();
    if (exits.length === 0) {
      delete compiler.exits[label];
    }
    continues.pop();
    if (continues.length === 0) {
      delete compiler.continues[label];
    }
    defaultExits.pop();
    defaultContinues.pop();
    return il.begin(il.assign(f, fun), il["return"](f.apply([null])));
  });

  exports.break_ = break_ = special([0, 1, 2], 'break_', function(compiler, cont, label, value) {
    var exitCont, exits;

    if (label == null) {
      label = '';
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !_.isString(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !_.isString(label)) {
      value = label;
      label = '';
    }
    exits = compiler.exits[label];
    if (!exits || exits === []) {
      throw new Error(label);
    }
    exitCont = exits[exits.length - 1];
    return compiler.cont(value, compiler.protect(exitCont));
  });

  exports.continue_ = continue_ = special([0, 1], 'continue_', function(compiler, cont, label) {
    var continueCont, continues;

    if (label == null) {
      label = '';
    }
    continues = compiler.continues[label];
    if (!continues || continues === []) {
      throw new Error(label);
    }
    continueCont = continues[continues.length - 1];
    return il["return"](compiler.protect(continueCont).call(null));
  });

  not_ = general.not_;

  exports.loop_ = macro(null, 'loop', function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  });

  exports.while_ = macro(null, 'while_', function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  });

  exports.until_ = macro(null, 'until_', function() {
    var body, label, test, _i;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), test = arguments[_i++];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  });

  exports.catch_ = special(-1, 'catch_', function() {
    var compiler, cont, forms, formsCont, tag, v, v2;

    compiler = arguments[0], cont = arguments[1], tag = arguments[2], forms = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    v = compiler.vari('v');
    v2 = compiler.vari('v');
    formsCont = compiler.expsCont(forms, il.clamda(v2, il.popCatch.apply([v]), il["return"](cont.call(v2))));
    return compiler.cont(tag, il.clamda(v, il.pushCatch.apply([v, cont]), formsCont));
  });

  exports.throw_ = special(2, 'throw_', function(compiler, cont, tag, form) {
    var formCont, v, v2;

    v = compiler.vari('v');
    v2 = compiler.vari('v');
    formCont = il.clamda(v, compiler.cont(form, il.clamda(v2, il["return"](compiler.protect(il.findCatch.apply([v])).call(v2)))));
    return compiler.cont(tag, formCont);
  });

  exports.protect = special(-1, 'protect', function() {
    var cleanup, compiler, cont, form, oldprotect, result, v1, v2;

    compiler = arguments[0], cont = arguments[1], form = arguments[2], cleanup = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    oldprotect = compiler.protect;
    v1 = compiler.vari('v');
    v2 = compiler.vari('v');
    compiler.protect = function(cont) {
      return il.clamda(v1, compiler.expsCont(cleanup, il.clamda(v2, il["return"](oldprotect(cont).call(v1)))));
    };
    result = compiler.cont(form, il.clamda(v1, compiler.expsCont(cleanup, il.clamda(v2, il["return"](cont.call(v1))))));
    compiler.protect = oldprotect;
    return result;
  });

  exports.callcc = special(1, 'callcc', function(compiler, cont, fun) {
    var cc, faked, result, v;

    if (fun.toCode == null) {
      fun = il.fun(fun);
    }
    faked = compiler.vari('faked');
    result = compiler.vari('result');
    v = compiler.vari('v');
    cc = il.clamda(v, il.restore.apply([faked]), il.assign(result, il.getvalue.apply([il.index.apply([il.run.apply([cont, v]), 1])])), il.code("solver.finished = false;"), il["return"](result));
    return il.begin(il.assign(faked, il.fake), il["return"](cont.call(fun.apply([cc]))));
  });

  /*
  # callfc(someFunction(fc) -> body) <br/>
  #current compiler.failcont can be captured in someFunction
  exports.callfc = special(1, 'callfc', (compiler, cont, fun) -> (v) ->
    faked = compiler.fake()
    fc = (v) ->
      compiler.restore(faked)
      result = compiler.run(v,  compiler.failcont)
      compiler.trail.getvalue(result[1])
    cont(fun(fc)))
  
  # 0.1.11 update
  # callcs(someFunction(compiler, faked, kont) -> body) <br/>
  #  the compiler, compiler's current content and current cont can be captured in someFunction
  exports.callcs = special(1, 'callcs', (compiler, cont, fun) -> (v) ->
    cont(fun(compiler, compiler.fake(), cont)))
  
  # lisp style quasiquote/unquote/unquote-slice "`", "," and ",@" 
  exports.quasiquote = exports.qq = special(1, 'quasiquote', (compiler, cont, item) ->
    compiler.quasiquote?(item, cont))
  
  exports.unquote = exports.uq = special(1, 'unquote', (compiler, cont, item) ->
    throw "unquote: too many unquote and unquoteSlice" )
  
  exports.unquoteSlice = exports.uqs = special(1, 'unquoteSlice', (compiler, cont, item) ->
    throw "unquoteSlice: too many unquote and unquoteSlice")
  */


}).call(this);

/*
//@ sourceMappingURL=lisp.map
*/
