// Generated by CoffeeScript 1.6.2
(function() {
  var ObjecttoString, andp, any, assign, begin, bind, block, break_, char, charIn, charWhen, continue_, defaultLabel, funcall, getvalue, greedyany, headList, if_, iff, inc, incp, index, io, isArray, isInteger, isLabel, isNumber, isObject, isString, jsbreak, jscontinue, jsfun, jsfuncall, lambda, lazyany, list, listTail, macro, makeLabel, name, names, newHeadName, not_, orp, orp2, orp3, push, pushp, quasiquote, sideEffect, string, stringIn, stringIn0, stringWhile, stringWhile0, times, unify, uniqueconst, uniquevar, unquote, unquoteSlice, vari, variable, _i, _j, _len, _len1, _ref, _ref1,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ObjecttoString = Object.prototype.toString;

  exports.isNumber = isNumber = function(x) {
    return ObjecttoString.call(x) === '[object Number]';
  };

  exports.isInteger = isInteger = function(x) {
    return ObjecttoString.call(x) === '[object Number]' && x % 1 === 0;
  };

  exports.isString = isString = function(x) {
    return ObjecttoString.call(x) === '[object String]';
  };

  exports.isArray = isArray = function(x) {
    return ObjecttoString.call(x) === '[object Array]';
  };

  exports.isObject = isObject = function(x) {
    return x === Object(x);
  };

  index = 0;

  newHeadName = function(text) {
    var name, names, _i, _len;

    names = text.split(' ');
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      exports[name] = global[name] = index;
    }
    return index++;
  };

  _ref = ['QUOTE SEXPR_HEAD_FIRST', 'EVAL', 'STRING', 'BEGIN', 'NONLOCAL', 'VARIABLE', 'UNIQUEVAR', 'UNIQUECONST', 'ASSIGN', 'AUGMENTASSIGN', 'INC', 'SUFFIXINC', 'DEC', 'SUFFIXDEC', 'INCP', 'SUFFIXINCP', 'DECP', 'SUFFIXDECP', 'IF', 'RETURN', 'JSTHROW', 'SWITCH', 'JSFUN', 'DIRECT', 'PURE', 'EFFECT', 'IO', 'LAMDA', 'MACRO', 'EVALARG', 'ARRAY', 'UARRAY', 'MAKEOBJECT', 'UOBJECT', 'CONS', 'FUNCALL', 'MACROCALL', 'JSFUNCALL', 'FOR', 'FORIN', 'FOROF', 'TRY', 'BLOCK', 'BREAK', 'CONTINUE', 'CATCH', 'THROW', ' UNWINDPROTECT', 'CALLCC', 'CALLFC', 'QUASIQUOTE', 'UNQUOTE', 'UNQUOTESLICE', 'PUSH', 'LIST', 'INDEX', 'HEADLIST', 'LISTTAIL', 'ATTR', 'LENGTH,SLICE,POP', 'INSTANCEOF', 'LOGICVAR', 'DUMMYVAR ', 'UNIFY', 'NOTUNIFY', 'IS', 'BIND', 'GETVALUE', 'SUCCEED', 'FAIL', 'PUSHP', 'ORP', 'ORP2', 'ORP3', 'NOTP', 'NOTP2', 'NOTP3', 'IFP', 'REPEAT', 'CUTABLE', 'CUT', 'FINDALL', 'ONCE', 'PARSE', 'PARSEDATA', 'SETPARSERSTATE', 'SETPARSERDATA', 'SETPARSERCURSOR', 'GETPARSERSTATE', 'GETPARSERDATA', 'GETPARSERCURSOR', 'EOI', 'BOI', 'EOL', 'BOL', 'STEP', 'LEFTPARSERDATA', 'SUBPARSERDATA', 'NEXTCHAR', 'MAY', 'LAZYMAY', 'GREEDYMAY', 'ANY', 'LAZYANY', 'GREEDYANY', 'PARALLEL', 'FOLLOW', 'NOTFOLLOW', 'ADD', 'SUB', 'MUL', 'DIV', 'MOD', 'AND', 'OR', 'NOT', 'BITAND', 'BITOR', 'BITXOR', 'LSHIFT', 'RSHIFT', 'EQ', 'NE', 'LE', 'LT', 'GT', 'GE', 'NEG', 'POSITIVE', 'BITNOT SEXPR_HEAD_LAST'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    names = _ref[_i];
    newHeadName(names);
  }

  vari = function(name) {
    return name;
  };

  exports.vars = function(names) {
    var name, _j, _len1, _ref1, _results;

    _ref1 = split(names, reElements);
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      name = _ref1[_j];
      _results.push(vari(name));
    }
    return _results;
  };

  exports.nonlocal = function() {
    var names;

    names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [NONLOCAL].concat(__slice.call(names));
  };

  exports.variable = variable = function() {
    var names;

    names = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [VARIABLE].concat(__slice.call(names));
  };

  exports.string = string = function(s) {
    return [STRING, s];
  };

  exports.quote = function(exp) {
    return [QUOTE, exp];
  };

  exports.eval_ = function(exp, path) {
    return [EVAL, exp, path];
  };

  exports.begin = begin = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [BEGIN].concat(__slice.call(exps));
  };

  exports.assign = assign = function(left, exp) {
    return [ASSIGN, left, exp];
  };

  exports.addassign = function(left, exp) {
    return [AUGMENTASSIGN, 'add', left, exp];
  };

  exports.subassign = function(left, exp) {
    return [AUGMENTASSIGN, 'sub', left, exp];
  };

  exports.mulassign = function(left, exp) {
    return [AUGMENTASSIGN, 'mul', left, exp];
  };

  exports.divassign = function(left, exp) {
    return [AUGMENTASSIGN, 'div', left, exp];
  };

  exports.modassign = function(left, exp) {
    return [AUGMENTASSIGN, 'mod', left, exp];
  };

  exports.andassign = function(left, exp) {
    return [AUGMENTASSIGN, 'and_', left, exp];
  };

  exports.orassign = function(left, exp) {
    return [AUGMENTASSIGN, 'or_', left, exp];
  };

  exports.bitandassign = function(left, exp) {
    return [AUGMENTASSIGN, 'bitand', left, exp];
  };

  exports.bitorassign = function(left, exp) {
    return [AUGMENTASSIGN, 'bitor', left, exp];
  };

  exports.bitxorassign = function(left, exp) {
    return [AUGMENTASSIGN, 'bitxor', left, exp];
  };

  exports.lshiftassign = function(left, exp) {
    return [AUGMENTASSIGN, 'lshift', left, exp];
  };

  exports.rshiftassign = function(left, exp) {
    return [AUGMENTASSIGN, 'rshift', left, exp];
  };

  exports.if_ = if_ = function(test, then_, else_) {
    return [IF, test, then_, else_];
  };

  exports.iff = iff = function(clauses, else_) {
    var length, test, then_, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new Error("iff clauses should have at least one clause.");
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      if (length === 1) {
        return if_(test, then_, else_);
      } else {
        return if_(test, then_, iff(clauses.slice(1), else_));
      }
    }
  };

  exports.switch_ = function() {
    var clauses, test;

    test = arguments[0], clauses = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [SWITCH, test].concat(__slice.call(clauses));
  };

  exports.return_ = function(value) {
    return [RETURN, value];
  };

  exports.jsthrow = function(value) {
    return [JSTHROW, value];
  };

  exports.array = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [ARRAY].concat(__slice.call(args));
  };

  exports.uarray = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [UARRAY].concat(__slice.call(args));
  };

  exports.cons = function(head, tail) {
    return [CONS, head, tail];
  };

  exports.makeobject = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [MAKEOBJECT].concat(__slice.call(args));
  };

  exports.uobject = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [UOBJECT].concat(__slice.call(args));
  };

  exports.funcall = funcall = function() {
    var args, caller;

    caller = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [FUNCALL, caller].concat(__slice.call(args));
  };

  exports.jsfuncall = jsfuncall = function() {
    var args, caller;

    caller = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [JSFUNCALL, caller].concat(__slice.call(args));
  };

  exports.macall = function() {
    var args, caller;

    caller = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [MACROCALL, caller].concat(__slice.call(args));
  };

  exports.jsobject = function(exp) {
    return [JSOBJECT, exp];
  };

  exports.jsfun = jsfun = function(exp) {
    return [JSFUN, exp];
  };

  exports.print_ = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [JSFUNCALL, io(jsfun('console.log'))].concat(exps);
  };

  exports.direct = function(exp) {
    return [DIRECT, exp];
  };

  exports.pure = io = function(exp) {
    return [PURE, exp];
  };

  exports.effect = sideEffect = function(exp) {
    return [EFFECT, exp];
  };

  exports.io = io = function(exp) {
    return [IO, exp];
  };

  exports.lamda = lambda = function() {
    var body, params;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [LAMDA, params].concat(body);
  };

  exports.macro = macro = function() {
    var body, params;

    params = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [MACRO, params].concat(body);
  };

  exports.qq = quasiquote = function(exp) {
    return [QUASIQUOTE, exp];
  };

  exports.uq = unquote = function(exp) {
    return [UNQUOTE, exp];
  };

  exports.uqs = unquoteSlice = function(exp) {
    return [UNQUOTESLICE, exp];
  };

  isLabel = function(label) {
    return isArray(label) && label.length === 2 && label[0] === 'label';
  };

  exports.makeLabel = makeLabel = function(label) {
    return ['label', label];
  };

  defaultLabel = ['label', ''];

  exports.block = block = function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!isLabel(label)) {
      label = makeLabel('');
      body = [label].concat(body);
    }
    return [BLOCK, label].concat(__slice.call(body));
  };

  exports.break_ = break_ = function(label, value) {
    if (label == null) {
      label = defaultLabel;
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !isLabel(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !isLabel(label)) {
      value = label;
      label = makeLabel('');
    }
    return [BREAK, label, value];
  };

  exports.continue_ = continue_ = function(label) {
    if (label == null) {
      label = defaultLabel;
    }
    return [CONTINUE, label];
  };

  exports.jsbreak = jsbreak = function(label) {
    return [JSBREAK, label];
  };

  exports.jscontinue_ = jscontinue = function(label) {
    return [JSCONTINUE, label];
  };

  exports.loop_ = function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!isLabel(label)) {
      label = defaultLabel;
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  };

  exports.while_ = function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!isLabel(label)) {
      label = defaultLabel;
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  };

  exports.until_ = function() {
    var body, label, test, _j;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _j = arguments.length - 1) : (_j = 1, []), test = arguments[_j++];
    if (!isLabel(label)) {
      label = defaultLabel;
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  };

  exports.dowhile = function() {
    var body, label, test, _j;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _j = arguments.length - 1) : (_j = 1, []), test = arguments[_j++];
    if (!isLabel(label)) {
      label = defaultLabel;
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(test, continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  };

  exports.for_ = function() {
    var body, init, step, test;

    init = arguments[0], test = arguments[1], step = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return [FOR, init, test, step].concat(__slice.call(body));
  };

  exports.forin = function() {
    var body, container, vari;

    vari = arguments[0], container = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return [FORIN, vari, container].concat(__slice.call(body));
  };

  exports.try_ = function(test, catches, final) {
    return [TRY, test, catches, final];
  };

  exports.catch_ = function() {
    var forms, tag;

    tag = arguments[0], forms = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [CATCH, tag].concat(__slice.call(forms));
  };

  exports.throw_ = function(tag, form) {
    return [THROW, tag, form];
  };

  exports.protect = function() {
    var cleanup, form;

    form = arguments[0], cleanup = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return [UNWINDPROTECT, form].concat(__slice.call(cleanup));
  };

  exports.callcc = function(fun) {
    return [CALLCC, fun];
  };

  exports.callfc = function(fun) {
    return [CALLFC, fun];
  };

  exports.inc = inc = function(item) {
    return [INC, item];
  };

  exports.suffixinc = function(item) {
    return [SUFFIXINC, item];
  };

  exports.dec = function(item) {
    return [DEC, item];
  };

  exports.suffixdec = function(item) {
    return [SUFFIXDEC, item];
  };

  exports.incp = incp = function(item) {
    return [INCP, item];
  };

  exports.suffixincp = function(item) {
    return [SUFFIXINCP, item];
  };

  exports.decp = function(item) {
    return [DECP, item];
  };

  exports.suffixdecp = function(item) {
    return [SUFFIXDECP, item];
  };

  exports.add = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [ADD].concat(__slice.call(args));
  };

  exports.sub = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [SUB].concat(__slice.call(args));
  };

  exports.mul = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [MUL].concat(__slice.call(args));
  };

  exports.div = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [DIV].concat(__slice.call(args));
  };

  exports.mod = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [MOD].concat(__slice.call(args));
  };

  exports.and_ = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [AND].concat(__slice.call(args));
  };

  exports.or_ = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [OR].concat(__slice.call(args));
  };

  exports.not_ = not_ = function(x) {
    return [NOT, x];
  };

  exports.bitand = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [BITAND].concat(__slice.call(args));
  };

  exports.bitor = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [BITOR].concat(__slice.call(args));
  };

  exports.bitxor = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [BITXOR].concat(__slice.call(args));
  };

  exports.lsfhift = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [LSHIFT].concat(__slice.call(args));
  };

  exports.rshift = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [RSHIFT].concat(__slice.call(args));
  };

  exports.eq = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [EQ].concat(__slice.call(args));
  };

  exports.ne = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [NE].concat(__slice.call(args));
  };

  exports.le = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [LE].concat(__slice.call(args));
  };

  exports.lt = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [LT].concat(__slice.call(args));
  };

  exports.gt = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [GT].concat(__slice.call(args));
  };

  exports.ge = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [GE].concat(__slice.call(args));
  };

  exports.neg = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [NEG].concat(__slice.call(args));
  };

  exports.bitnot = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [BITNOT].concat(__slice.call(args));
  };

  exports.index = index = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [INDEX].concat(__slice.call(args));
  };

  exports.push = push = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [PUSH].concat(__slice.call(args));
  };

  exports.list = list = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [LIST].concat(__slice.call(args));
  };

  exports.headList = headList = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [HEADLIST].concat(__slice.call(args));
  };

  exports.listTail = listTail = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [LISTTAIL].concat(__slice.call(args));
  };

  exports.pushp = pushp = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [PUSHP].concat(__slice.call(args));
  };

  exports.attr = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [ATTR].concat(__slice.call(args));
  };

  exports.length = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [LENGTH].concat(__slice.call(args));
  };

  exports.slice = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [SLICE].concat(__slice.call(args));
  };

  exports.pop = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [POP].concat(__slice.call(args));
  };

  exports["instanceof"] = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [INSTANCEOF].concat(__slice.call(args));
  };

  exports.concat = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return jsfuncall.apply(null, ['concat'].concat(__slice.call(args)));
  };

  exports.logicvar = function(name) {
    return [LOGICVAR, name];
  };

  exports.dummy = function(name) {
    return [DUMMYVAR, name];
  };

  exports.unify = unify = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [UNIFY].concat(__slice.call(args));
  };

  exports.notunify = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [NOTUNIFY].concat(__slice.call(args));
  };

  exports.succeed = [SUCCEED];

  exports.fail = [FAIL];

  exports.andp = andp = exports.begin;

  exports.orp = orp = function() {
    var exps, length;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    length = exps.length;
    if (length === 0) {
      throw new ArgumentError(exps);
    } else if (length === 1) {
      return exps[0];
    } else if (length === 2) {
      return [ORP].concat(__slice.call(exps));
    } else {
      return [ORP, exps[0], orp.apply(null, exps.slice(1))];
    }
  };

  exports.orp2 = orp2 = function() {
    var exps, length;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    length = exps.length;
    if (length === 0) {
      throw new ArgumentError(exps);
    } else if (length === 1) {
      return exps[0];
    } else if (length === 2) {
      return [ORP2].concat(__slice.call(exps));
    } else {
      return [ORP2, exps[0], orp2.apply(null, exps.slice(1))];
    }
  };

  exports.orp3 = orp3 = function() {
    var exps, length;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    length = exps.length;
    if (length === 0) {
      throw new ArgumentError(exps);
    } else if (length === 1) {
      return exps[0];
    } else if (length === 2) {
      return [ORP3].concat(__slice.call(exps));
    } else {
      return [ORP3, exps[0], orp3.apply(null, exps.slice(1))];
    }
  };

  exports.notp = function(goal) {
    return [NOTP, goal];
  };

  exports.notp2 = function(goal) {
    return [NOTP2, goal];
  };

  exports.notp3 = function(goal) {
    return [NOTP3, goal];
  };

  exports.repeat = [REPEAT];

  exports.cutable = function(goal) {
    return [CUTABLE, goal];
  };

  exports.cut = [CUT];

  exports.once = function(goal) {
    return [ONCE, goal];
  };

  exports.findall = function(goal, result, template) {
    return [FINDALL, goal, result, template];
  };

  exports.is_ = function(vari, exp) {
    return [IS, vari, exp];
  };

  exports.bind = bind = function(vari, term) {
    return [BIND, vari, term];
  };

  exports.getvalue = getvalue = function(term) {
    return [GETVALUE, term];
  };

  exports.parse = function(exp, state) {
    return [PARSE, exp, state];
  };

  exports.parsedata = exports.parsetext = function(exp, data) {
    return [PARSEDATA, exp, data];
  };

  exports.setdata = exports.settext = function(data) {
    return [SETPARSERDATA, data];
  };

  exports.setcursor = function(cursor) {
    return [SETPARSERCURSOR, cursor];
  };

  exports.setstate = function(state) {
    return [SETPARSERSTATE, state];
  };

  exports.getstate = [GETPARSERSTATE];

  exports.getdata = [GETPARSERDATA];

  exports.getcursor = [GETPARSERCURSOR];

  exports.eoi = [EOI];

  exports.boi = [BOI];

  exports.eol = [EOL];

  exports.bol = [BOL];

  exports.step = function(n) {
    return [STEP, n];
  };

  exports.leftdata = [LEFTPARSERDATA];

  exports.subdata = function(length, start) {
    return [SUBPARSERDATA, length, start];
  };

  exports.nextchar = [NEXTCHAR];

  exports.may = function(exp) {
    return [MAY, exp];
  };

  exports.lazymay = function(exp) {
    return [LAZYMAY, exp];
  };

  exports.greedymay = function(exp) {
    return [GREEDYMAY, exp];
  };

  index = 1;

  exports.uniquevar = uniquevar = function(name) {
    return [UNIQUEVAR, name, index++];
  };

  exports.uniqueconst = uniqueconst = function(name) {
    return [UNIQUECONST, name, index++];
  };

  exports.any = any = function(exp, result, template) {
    var result1;

    if (result == null) {
      return [ANY, exp];
    } else {
      result1 = uniqueconst('result');
      return begin(assign(result1, []), any(andp(exp, push(result1, getvalue(template)))), unify(result, result1));
    }
  };

  exports.lazyany = lazyany = function(exp, result, template) {
    var result1;

    if (result == null) {
      return [LAZYANY, exp];
    } else {
      result1 = uniqueconst('result');
      return begin(assign(result1, []), lazyany(andp(exp, push(result1, getvalue(template)))), unify(result, result1));
    }
  };

  exports.greedyany = greedyany = function(exp, result, template) {
    var result1;

    if (result == null) {
      return [GREEDYANY, exp];
    } else {
      result1 = uniqueconst('result');
      return begin(assign(result1, []), greedyany(andp(exp, push(result1, getvalue(template)))), unify(result, result1));
    }
  };

  exports.some = function(exp, result, template) {
    var result1;

    if (result == null) {
      return andp(exp, [ANY, exp]);
    } else {
      result1 = uniqueconst('result');
      return begin(['result'], assign(result1, []), exp, push(result1, getvalue(template)), any(andp(exp, push(result1, getvalue(template)))), unify(result, result1));
    }
  };

  exports.lazysome = function(exp, result, template) {
    var result1;

    if (result == null) {
      return andp(exp, [LAZYANY, exp]);
    } else {
      result1 = uniqueconst('result');
      return begin(assign(result1, []), exp, push(result1, getvalue(template)), lazyany(andp(exp, push(result1, getvalue(template)))), unify(result, result1));
    }
  };

  exports.greedysome = function(exp, result, template) {
    var result1;

    if (result == null) {
      return andp(exp, [GREEDYANY, exp]);
    } else {
      result1 = uniqueconst('result');
      return begin(assign(result1, []), exp, push(result1, getvalue(template)), greedyany(andp(exp, push(result1, getvalue(template)))), unify(result, result1));
    }
  };

  exports.times = times = function(exp, expectTimes, result, template) {
    var n, result1;

    n = uniquevar('n');
    if (result == null) {
      return begin(variable(n), assign(n, 0), any(andp(exp, incp(n))), unify(expectTimes, n));
    } else {
      result1 = uniqueconst('result');
      return begin(variable(n), assign(n, 0), assign(result1, []), any(andp(exp, incp(n), pushp(result1, getvalue(template)))), unify(expectTimes, n), unify(result, result1));
    }
  };

  exports.seplist = function(exp, options) {
    var expectTimes, n, result, result1, sep, template;

    if (options == null) {
      options = {};
    }
    sep = options.sep || char(string(' '));
    expectTimes = options.times || null;
    result = options.result || null;
    template = options.template || null;
    if (result !== null) {
      result1 = uniqueconst('result');
    }
    if (expectTimes === null) {
      if (result === null) {
        return andp(exp, any(andp(sep, exp)));
      } else {
        return andp(assign(result1, []), exp, pushp(result1, getvalue(template)), any(andp(sep, exp, pushp(result1, getvalue(template)))), unify(result, result1));
      }
    } else if (isInteger(expectTimes)) {
      if (result === null) {
        switch (expectTimes) {
          case 0:
            return succeed;
          case 1:
            return exp;
          default:
            return andp(exp, times(andp(sep, exp), expectTimes - 1));
        }
      } else {
        switch (expectTimes) {
          case 0:
            return unify(result, []);
          case 1:
            return andp(exp, unify(result, list(getvalue(template))));
          default:
            return andp(assign(result1, []), exp, pushp(result1, getvalue(template)), times(andp(sep, exp, pushp(result1, getvalue(template))), expectTimes - 1), unify(result, result1));
        }
      }
    } else {
      n = uniquevar('n');
      if (result === null) {
        return orp(andp(variable(n), exp, assign(n, 1), any(andp(sep, exp, incp(n))), unify(expectTimes, n)), unify(expectTimes, 0));
      } else {
        return orp(andp(variable(n), exp, assign(n, 1), assign(result1, list(getvalue(template))), any(andp(sep, exp, pushp(result1, getvalue(template)), incp(n))), unify(expectTimes, n), unify(result, result1)), andp(unify(expectTimes, 0), unify(result, [])));
      }
    }
  };

  exports.parallel = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return [PARALLEL].concat(__slice.call(args));
  };

  exports.follow = function(x) {
    return [FOLLOW, x];
  };

  exports.notfollow = function(x) {
    return [NOTFOLLOW, x];
  };

  _ref1 = ['char', 'followChars', 'notFollowChars', 'charWhen', 'spaces', 'spaces0', 'stringWhile', 'stringWhile0', 'number', 'literal', 'followLiteral', 'notFollowLiteral', 'quoteString', 'identifier'];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    name = _ref1[_j];
    exports[name] = (function(name) {
      return function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return funcall.apply(null, [jsfun('parser.' + name), 'solver'].concat(__slice.call(args)));
      };
    })(name);
  }

  char = exports.char;

  charWhen = exports.charWhen;

  stringWhile = exports.stringWhile;

  stringWhile0 = exports.stringWhile0;

  exports.charBetween = function(start, end) {
    return charWhen(function(c) {
      return (start < c && c < end);
    });
  };

  charIn = charIn = function(set) {
    return charWhen(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digit = charWhen(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digit1_9 = charWhen(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lower = charWhen(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.upper = charWhen(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letter = charWhen(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetter = charWhen(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDight = charWhen(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspace = charIn(' \t');

  exports.whitespace = charIn(' \t\r\n');

  exports.newline = charIn('\r\n');

  exports.stringBetween = function(start, end) {
    return stringWhile(function(c) {
      return (start < c && c < end);
    });
  };

  exports.stringIn = stringIn = function(set) {
    return stringWhile(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digits = stringWhile(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digits1_9 = stringWhile(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lowers = stringWhile(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.uppers = stringWhile(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letters = stringWhile(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetters = stringWhile(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDights = stringWhile(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspaces = stringIn(' \t');

  exports.whitespaces = stringIn(' \t\r\n');

  exports.newlinespaces = stringIn('\r\n');

  exports.stringBetween0 = function(start, end) {
    return stringWhile0(function(c) {
      return (start < c && c < end);
    });
  };

  exports.stringIn0 = stringIn0 = function(set) {
    return stringWhile0(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digits0 = stringWhile0(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digits1_90 = stringWhile0(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lowers0 = stringWhile0(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.uppers0 = stringWhile0(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letters0 = stringWhile0(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetters0 = stringWhile0(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDights0 = stringWhile0(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspaces0 = stringIn0(' \t');

  exports.whitespaces0 = stringIn0(' \t\r\n');

  exports.newlines0 = stringIn0('\r\n');

}).call(this);

/*
//@ sourceMappingURL=util.map
*/
