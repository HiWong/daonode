// Generated by CoffeeScript 1.6.2
(function() {
  var EXTENDING, computeLeftRecursives, cursor, hasOwnProperty, memo, memoCallpath, memoRules, originalRules, parentToChildren, prepareGrammar, rec, recRules, recursive, recursiveRules, rules, text, textLength, _memo, _memo2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  parentToChildren = {};

  rules = void 0;

  originalRules = {};

  exports.recursiveRules = recursiveRules = {};

  memoRules = {};

  recRules = {};

  memoCallpath = {};

  _memo = {};

  text = '';

  textLength = 0;

  cursor = 0;

  _memo = {};

  _memo2 = {};

  hasOwnProperty = Object.hasOwnProperty;

  exports.setRules = function(rules1) {
    return rules = rules1;
  };

  exports.parse = function(data, root, grammar) {
    if (grammar) {
      prepareGrammar(grammar);
    }
    text = data;
    textLength = text.length;
    cursor = 0;
    _memo = {};
    return root(0);
  };

  exports.prepareGrammar = prepareGrammar = function(grammar) {
    var rule, symbol, symbolToParentsMap;

    originalRules = {};
    for (symbol in grammar) {
      rule = grammar[symbol];
      if (hasOwnProperty.call(grammar, symbol)) {
        originalRules[symbol] = rule;
      }
    }
    symbolToParentsMap = {};
    return computeLeftRecursives(grammar);
  };

  exports.computeLeftRecursives = computeLeftRecursives = function(grammar) {
    var currentLeftHand;
    var addDescendents, currentLeftHand, descendents, meetTable, symbol, symbolDescedentsMap;

    for (symbol in grammar) {
      if (hasOwnProperty.call(grammar, symbol)) {
        (function(symbol) {
          return grammar[symbol] = function(start) {
            var children, _ref;

            if (start !== 0) {

            } else {
              cursor++;
              children = (_ref = parentToChildren[currentLeftHand]) != null ? _ref : parentToChildren[currentLeftHand] = [];
              if (__indexOf.call(children, symbol) < 0) {
                return children.push(symbol);
              }
            }
          };
        })(symbol);
      }
    }
    for (symbol in grammar) {
      currentLeftHand = symbol;
      originalRules[symbol](0);
    }
    addDescendents = function(symbol, meetTable, descedents) {
      var chidlren, child, _i, _len, _results;

      if (!(chidlren = parentToChildren[symbol])) {
        return;
      }
      _results = [];
      for (_i = 0, _len = chidlren.length; _i < _len; _i++) {
        child = chidlren[_i];
        if (__indexOf.call(descedents, child) < 0) {
          descedents.push(child);
        }
        if (!meetTable[child]) {
          _results.push(addDescendents(child, meetTable, descedents));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    symbolDescedentsMap = {};
    for (symbol in grammar) {
      meetTable = {};
      meetTable[symbol] = true;
      descendents = symbolDescedentsMap[symbol] = [];
      addDescendents(symbol, meetTable, descendents);
      if (__indexOf.call(descendents, symbol) >= 0) {
        grammar[symbol] = recursiveRules[symbol] = recursive(symbol);
        memoRules[symbol] = memo(symbol);
        recRules[symbol] = rec(symbol);
      } else {
        grammar[symbol] = originalRules[symbol];
      }
    }
    for (symbol in grammar) {
      if (!hasOwnProperty.call(recursiveRules, symbol)) {
        delete symbolDescedentsMap[symbol];
      } else {
        descendents = symbolDescedentsMap[symbol];
        symbolDescedentsMap[symbol] = ((function() {
          var _i, _len, _results;

          if (hasOwnProperty.call(recursiveRules, symbol)) {
            _results = [];
            for (_i = 0, _len = descendents.length; _i < _len; _i++) {
              symbol = descendents[_i];
              _results.push(symbol);
            }
            return _results;
          }
        })());
      }
    }
    return symbolDescedentsMap;
  };

  exports.setRecursiveSymbols = function() {
    var rules1, symbol, symbols, _i, _len, _results;

    rules1 = arguments[0], symbols = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    rules = rules1;
    _results = [];
    for (_i = 0, _len = symbols.length; _i < _len; _i++) {
      symbol = symbols[_i];
      originalRules[symbol] = rules[symbol];
      _results.push(rules[symbol] = recursiveRules[symbol] = recursive(symbol));
    }
    return _results;
  };

  EXTENDING = true;

  exports.recursive = recursive = function(symbol) {
    var baserule;

    baserule = originalRules[symbol];
    return function(start) {
      var callpath, hash, m, result, sym, _ref, _ref1, _ref2;

      hash = symbol + start;
      for (sym in parentToChildren[symbol]) {
        originalRules[sym] = rec(sym);
      }
      memoState[hash] = EXTENDING;
      callpath = (_ref = memoCallpath[start]) != null ? _ref : memoCallpath[start] = [symbol];
      m = (_ref1 = _memo[hash]) != null ? _ref1 : _memo[hash] = [void 0, -1];
      if (m[1] >= 0) {
        cursor = m[1];
        return m[0];
      }
      m[0] = baserule(start);
      m[1] = cursor;
      while (1) {
        hash = symbol + start;
        m = (_ref2 = _memo[hash]) != null ? _ref2 : _memo[hash] = [void 0, -1];
        baserule = originalRules[symbol];
        result = baserule(start);
        if (__indexOf.call(callpath, symbol) >= 0 && !result) {
          cursor = m[1];
          return m[0];
        }
        if (m[0] && !result) {
          cursor = m[1];
          return m[0];
        }
        if (result === m[0] && cursor === m[1]) {
          return result;
        } else {
          m[0] = result;
          m[1] = cursor;
        }
      }
    };
  };

  rec = function(symbol) {
    var rule;

    rule = originalRules[symbol];
    return function(start) {
      var callpath, cur, hash, m, result;

      callpath = memoCallpath[start];
      hash = symbol + start;
      m = _memo[hash];
      result = m[0];
      cur = m[1];
      if (status === EXTENDING) {
        if (__indexOf.call(callpath, symbol) >= 0) {
          if (cur < 0) {
            m[1] = start;
            return void 0;
          } else {
            return m[0];
          }
        } else {
          result = rule(start);
          if (cur < 0) {
            return void 0;
          } else {
            return result;
          }
        }
      } else {
        if (status === EXTENDING) {
          return callpath.push(symbol);
        } else {
          callpath.push(symbol);
          return rule(start);
        }
      }
    };
  };

  exports.memo = memo = function(symbol) {
    return function(start) {
      var hash, m;

      hash = symbol + start;
      m = _memo[hash];
      if (m) {
        return m[0];
      }
    };
  };

  exports.andp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      cursor = start;
      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (!(result = exp(cursor))) {
          return;
        }
      }
      return result;
    };
  };

  exports.orp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (result = exp(start)) {
          return result;
        }
      }
    };
  };

  exports.notp = function(exp) {
    return function(start) {
      if (exp(start)) {

      } else {
        return true;
      }
    };
  };

  exports.char = function(c) {
    return function(start) {
      if (text[start] === c) {
        cursor = start + 1;
        return c;
      }
    };
  };

  exports.literal = function(string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  exports.spaces = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  exports.spaces1 = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return cursor = cursor;
      return len;
    }
  };

  exports.wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    return function(start) {
      var result;

      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  exports.cur = function() {
    return cursor;
  };

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
