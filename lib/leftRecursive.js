// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.BaseParser = (function() {
    function _Class() {
      this.symbolToParentsMap = {};
      this.baseRules = {};
    }

    _Class.prototype.parse = function(code, options) {
      this.text = code;
      this.textLength = code.length;
      this.cursor = 0;
      this.tokens = [];
      this._memo = {};
      this.indentList = [];
      this.tabWidth = 4;
      this.yy = this.yy;
      return this.Root(0);
    };

    _Class.prototype.andp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        _this.cursor = start;
        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (!(result = exp(_this.cursor))) {
            return;
          }
        }
        return result;
      };
    };

    _Class.prototype.orp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (result = exp(start)) {
            return result;
          }
        }
      };
    };

    _Class.prototype.notp = function(exp) {
      var _this = this;

      return function(start) {
        if (exp(start)) {

        } else {
          return true;
        }
      };
    };

    _Class.prototype.char = function(c) {
      var _this = this;

      return function(start) {
        if (_this.text[start] === c) {
          _this.cursor = start + 1;
          return c;
        }
      };
    };

    _Class.prototype.literal = function(string) {
      var _this = this;

      return function(start) {
        var len, stop;

        len = string.length;
        if (_this.text.slice(start, stop = start + len) === string) {
          _this.cursor = stop;
          return true;
        }
      };
    };

    _Class.prototype.spaces = function(start) {
      var len, text;

      len = 0;
      this.cursor = start;
      text = this.text;
      while (1) {
        switch (text[this.cursor]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };

    _Class.prototype.spaces1 = function(start) {
      var cursor, len, text;

      len = 0;
      cursor = start;
      text = this.text;
      while (1) {
        switch (text[cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return this.cursor = cursor;
        return len;
      }
    };

    _Class.prototype.wrap = function(item, left, right) {
      if (left == null) {
        left = spaces;
      }
      if (right == null) {
        right = spaces;
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(this.cursor) && right(this.cursor))) {
          return result;
        }
      };
    };

    _Class.prototype.addParentChildrens = function() {
      var children, list, map, name, parent, parentChildren, parentChildrens, _i, _len, _results;

      parentChildrens = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      map = this.symbolToParentsMap;
      _results = [];
      for (_i = 0, _len = parentChildrens.length; _i < _len; _i++) {
        parentChildren = parentChildrens[_i];
        _results.push((function() {
          var _results1;

          _results1 = [];
          for (parent in parentChildren) {
            children = parentChildren[parent];
            _results1.push((function() {
              var _j, _len1, _ref, _results2;

              _results2 = [];
              for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
                name = children[_j];
                list = (_ref = map[name]) != null ? _ref : map[name] = [];
                if (parent !== name && __indexOf.call(list, parent) < 0) {
                  _results2.push(list.push(parent));
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    };

    _Class.prototype.addRecCircles = function() {
      var circle, i, j, length, list, map, name, parent, recursiveCircles, _i, _len, _results;

      recursiveCircles = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      map = this.symbolToParentsMap;
      _results = [];
      for (_i = 0, _len = recursiveCircles.length; _i < _len; _i++) {
        circle = recursiveCircles[_i];
        i = 0;
        length = circle.length;
        _results.push((function() {
          var _ref, _results1;

          _results1 = [];
          while (i < length) {
            if (i === length - 1) {
              j = 0;
            } else {
              j = i + 1;
            }
            name = circle[i];
            list = (_ref = map[name]) != null ? _ref : map[name] = [];
            parent = circle[j];
            if (parent !== name && __indexOf.call(list, parent) < 0) {
              list.push(parent);
            }
            _results1.push(i++);
          }
          return _results1;
        })());
      }
      return _results;
    };

    _Class.prototype.setMemoRules = function() {
      var map, name, _results;

      map = this.symbolToParentsMap;
      _results = [];
      for (name in map) {
        this.baseRules[name] = this[name];
        _results.push(this[name] = this.memoRule(name));
      }
      return _results;
    };

    _Class.prototype.memoRule = function(symbol) {
      var addParent, agenda, map,
        _this = this;

      map = this.symbolToParentsMap;
      agenda = [];
      addParent = function(parent) {
        var parents, _i, _len, _results;

        agenda.unshift(parent);
        parents = map[parent];
        if (parents) {
          _results = [];
          for (_i = 0, _len = parents.length; _i < _len; _i++) {
            parent = parents[_i];
            if (__indexOf.call(agenda, parent) < 0) {
              agenda.unshift(parent);
              _results.push(addParent(parent));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      };
      addParent(symbol);
      return function(start) {
        var changed, hash, hash0, m, memo, parent, result, rule, _i, _len, _ref;

        memo = _this._memo;
        hash0 = symbol + start;
        m = memo[hash0];
        if (m) {
          _this.cursor = m[1];
          return m[0];
        }
        while (agenda.length) {
          symbol = agenda.pop();
          hash = symbol + start;
          m = memo[hash];
          if (!m) {
            m = memo[hash] = [void 0, start];
          }
          rule = _this.baseRules[symbol];
          changed = false;
          while (1) {
            if ((result = rule(start)) && (result !== m[0] || _this.cursor !== m[1])) {
              memo[hash] = m = [result, _this.cursor];
              changed = true;
            } else {
              break;
            }
          }
          if (changed) {
            _ref = map[symbol];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              parent = _ref[_i];
              if (__indexOf.call(agenda, parent) < 0) {
                agenda.push(parent);
              }
            }
          }
        }
        m = memo[hash0];
        _this.cursor = m[1];
        return m[0];
      };
    };

    _Class.prototype.memo = function(symbol) {
      var _this = this;

      return function(start) {
        var m;

        m = _this._memo[symbol + start];
        if (m) {
          _this.cursor = m[1];
          return m[0];
        }
      };
    };

    return _Class;

  })();

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
