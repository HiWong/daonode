// Generated by CoffeeScript 1.6.2
(function() {
  exports.BaseParser = (function() {
    function _Class() {}

    _Class.prototype.parse = function(code, options) {
      var oldIndentList, oldMemo, oldMemoState, oldText, oldTextLength, oldTokens, oldyy, result;

      oldText = global.text;
      oldTextLength = global.textLength;
      oldTokens = global.tokens;
      oldMemo = global.memo;
      oldMemoState = global.memoState;
      oldIndentList = global.indentList;
      oldyy = global.yy;
      global.text = code;
      global.textLength = code.length;
      this.cursor = 0;
      global.tokens = [];
      global.memo = {};
      global.memoState = {};
      global.indentList = [];
      this.tabWidth = 4;
      global.yy = this.yy;
      result = this.Root(0);
      global.text = oldText;
      global.textLength = oldTextLength;
      global.tokens = oldTokens;
      global.memo = oldMemo;
      global.memoState = oldMemoState;
      global.indentList = oldIndentList;
      return result;
    };

    _Class.prototype.andp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        _this.cursor = start;
        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (!(result = exp(_this.cursor))) {
            return;
          }
        }
        return result;
      };
    };

    _Class.prototype.orp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (result = exp(start)) {
            return result;
          }
        }
      };
    };

    _Class.prototype.notp = function(exp) {
      var _this = this;

      return function(start) {
        if (exp(start)) {

        } else {
          return true;
        }
      };
    };

    _Class.prototype.char = function(c) {
      var _this = this;

      return function(start) {
        if (text[start] === c) {
          _this.cursor = start + 1;
          return c;
        }
      };
    };

    _Class.prototype.literal = function(string) {
      var _this = this;

      return function(start) {
        var len, stop;

        len = string.length;
        if (text.slice(start, stop = start + len) === string) {
          _this.cursor = stop;
          return true;
        }
      };
    };

    _Class.prototype.spaces = function(start) {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (text[this.cursor]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };

    _Class.prototype.spaces1 = function(start) {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (text[this.cursor]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return len;
      }
    };

    _Class.prototype.wrap = function(item, left, right) {
      if (left == null) {
        left = spaces;
      }
      if (right == null) {
        right = spaces;
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(this.cursor) && right(this.cursor))) {
          return result;
        }
      };
    };

    _Class.prototype.recursive = function(symbol) {
      var rec, rule,
        _this = this;

      rule = this[symbol];
      return rec = function(start) {
        var hash, m, result, state;

        hash = symbol + start;
        memoState[hash] = state = memoState[hash] || 0;
          debugger
        switch (state) {
          case 0:
            memoState[hash]++;
            memo[hash] = [void 0, start];
            if (result = rule(start)) {
              memo[hash] = [result, _this.cursor];
              return rec(start);
            } else {
              memoState[hash] = -1;
              memo[hash] = [void 0, 0];
              return void 0;
            }
            break;
          case 1:
            memoState[hash]++;
            return void 0;
          case 2:
            memoState[hash] = 3;
            if (result = rule(start)) {
              memo[hash] = [result, _this.cursor];
              memoState[hash] = 2;
              return rec(start);
            } else {
              memoState[hash] = -1;
              m = memo[hash];
              _this.cursor = m[1];
              return m[0];
            }
            break;
          case 3:
            m = memo[hash];
            _this.cursor = m[1];
            return m[0];
          case -1:
            m = memo[hash];
            _this.cursor = m[1];
            return m[0];
        }
      };
    };

    _Class.prototype.getmemo = function(symbol) {
      var _this = this;

      return function(position) {
        return memo[symbol + position][0];
      };
    };

    _Class.prototype.reduce = function(symbol) {
      return function(start) {
        var state;

        state = memoState[symbol + start];
        return state === REDUCE;
      };
    };

    _Class.prototype.alpha = function(symbol) {
      return function(start) {
        var state;

        state = memoState[symbol + start];
        return state === 2;
      };
    };

    return _Class;

  })();

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
