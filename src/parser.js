// Generated by CoffeeScript 1.6.2
(function() {
  var BacktrackableError, Env, Expr, State, Var, VarNotFound, deref, unify, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('underscore');

  BacktrackableError = (function() {
    function BacktrackableError() {}

    return BacktrackableError;

  })();

  exports.UnifyError = (function(_super) {
    __extends(UnifyError, _super);

    function UnifyError() {
      _ref = UnifyError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return UnifyError;

  })(BacktrackableError);

  VarNotFound = (function() {
    function VarNotFound(name) {
      this.name = name;
    }

    return VarNotFound;

  })();

  Env = (function() {
    function Env(outer, bindings) {
      this.outer = outer;
      this.bindings = bindings || {};
    }

    Env.prototype.bind = function(name, value) {
      return this.bindings[name] = value;
    };

    Env.prototype.get = function(name) {
      if (this.bindings.hasOwnProperty(name)) {
        return this.bindings[name];
      } else if (this.outer != null) {
        return this.outer.get(name);
      } else {
        throw new VarNotFound(name);
      }
    };

    Env.prototype.add = function(name, value) {
      var b;

      b = _.clone(this.bindings);
      b[name] = value;
      return new Env(this.outer, b);
    };

    return Env;

  })();

  Var = (function() {
    function Var(name) {
      this.name = name;
    }

    Var.prototype.deref = function(env) {
      var e, x;

      try {
        x = env.get(this.name);
      } catch (_error) {
        e = _error;
        if (e instanceof VarNotFound) {
          return this;
        } else {
          throw e;
        }
      }
      if (x === this) {
        return x;
      } else if (!(x instanceof Var)) {
        return x;
      } else {
        return x.deref(env);
      }
    };

    Var.prototype.unify = function(y, env) {
      y = y.deref(env);
      return env.bind(this.name(y));
    };

    Var.prototype.toString = function() {
      return this.name + '?';
    };

    return Var;

  })();

  exports.vars = function(names) {
    var name, _i, _len, _ref1, _results;

    _ref1 = names.split(', ');
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      _results.push(new Var(name));
    }
    return _results;
  };

  unify = function(x, y, env) {
    if (x instanceof Var) {
      x = x.deref(env);
    }
    if (y instanceof Var) {
      y = y.deref(env);
    }
    if (x === y) {
      return env;
    } else {
      if (x instanceof Var) {
        return env.add(x.name, y);
      } else if (y instanceof Var) {
        return env.add(y.name, x);
      } else {
        throw new UnifyError(x, y);
      }
    }
  };

  deref = function(x, env) {
    if (!(x instanceof Var)) {
      return x;
    } else {
      return x.deref(env);
    }
  };

  State = exports.State = (function() {
    function State(data, pos) {
      this.data = data;
      this.pos = pos;
    }

    State.prototype.toString = function() {
      return "" + this.data + ":" + this.pos;
    };

    return State;

  })();

  exports.state = function(data, pos) {
    return new State(data, pos);
  };

  exports.ParseError = (function(_super) {
    __extends(ParseError, _super);

    function ParseError(state, parser) {
      this.state = state;
      this.parser = parser;
    }

    ParseError.prototype.toString = function() {
      return "ParserError: " + (this.state.toString()) + " when parsing " + (this.parser.toString());
    };

    return ParseError;

  })(BacktrackableError);

  exports.Solver = (function() {
    function Solver(env, state) {
      this.env = env;
      this.state = state;
      this.leftExpr = null;
    }

    Solver.prototype.solve = function(exp) {
      return exp.solve(this);
    };

    return Solver;

  })();

  exports.solve = function(exp, data) {
    return new Solver(new Env(), new State(data, 0)).solve(exp);
  };

  Expr = (function() {
    function Expr() {}

    return Expr;

  })();

  exports.Unify = (function(_super) {
    __extends(Unify, _super);

    function Unify(x, y) {
      this.x = x;
      this.y = y;
    }

    Unify.prototype.solve = function(solver) {
      var env;

      env = unify(this.x, this.y, solver.env);
      return new Solver(env, solver.state);
    };

    Unify.prototype.toString = function() {
      return "" + this.x + ":=:" + this.y;
    };

    return Unify;

  })(Expr);

  exports.unify = function(x, y) {
    return new Unify(x, y);
  };

  exports.Char = (function(_super) {
    __extends(Char, _super);

    function Char(arg) {
      this.arg = arg;
    }

    Char.prototype.solve = function(solver) {
      var arg, c, data, pos, state;

      state = solver.state;
      data = state.data;
      pos = state.pos;
      if (data.length === pos) {
        throw ParseError(state, this);
      }
      c = data[pos];
      if (this.arg instanceof Var) {
        arg = this.arg.deref(solver.env);
        if (arg instanceof Var) {
          return new Solver(solver.env.add(arg.name, c), new State(data, pos + 1));
        }
      } else {
        arg = this.arg;
      }
      if (arg === data[pos]) {
        return new Solver(solver.env, new State(state.data, state.pos + 1));
      } else {
        throw new ParseError(state, this);
      }
    };

    Char.prototype.toString = function() {
      return this.arg;
    };

    return Char;

  })(Expr);

  exports.char = function(x) {
    return new Char(x);
  };

  exports.And = (function(_super) {
    __extends(And, _super);

    function And(item1, item2) {
      this.item1 = item1;
      this.item2 = item2;
    }

    And.prototype.solve = function(solver) {
      var solver1;

      solver1 = this.item1.solve(solver);
      return this.item2.solve(solver1);
    };

    And.prototype.toString = function() {
      return "" + item1 + "&" + this.item2;
    };

    return And;

  })(Expr);

  exports.and_ = function() {
    var i, items, len, result, _i, _ref1;

    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    len = items.length;
    if (len === 0) {
      throw SyntaxError("and_(" + items);
    }
    if (len === 1) {
      return items[0];
    } else {
      result = items[len - 1];
      for (i = _i = _ref1 = len - 2; _ref1 <= 0 ? _i <= 0 : _i >= 0; i = _ref1 <= 0 ? ++_i : --_i) {
        result = new And(items[i], result);
      }
      return result;
    }
  };

  exports.Or = (function(_super) {
    __extends(Or, _super);

    function Or(item1, item2) {
      this.item1 = item1;
      this.item2 = item2;
    }

    Or.prototype.solve = function(solver) {
      var e;

      try {
        return this.item1.solve(solver).setLeftExpr(item2);
      } catch (_error) {
        e = _error;
        if (e instanceof BacktrackableError) {
          return this.item2.solve(solver);
        } else {
          throw e;
        }
      }
    };

    Or.prototype.toString = function() {
      return "" + item1 + "|" + this.item2;
    };

    return Or;

  })(Expr);

  exports.or_ = function(item1, item2) {
    return new Or(item1, item2);
  };

  exports.Not = (function(_super) {
    __extends(Not, _super);

    function Not(item) {
      this.item = item;
    }

    Not.prototype.solve = function(solver) {
      var e;

      try {
        this.item.solve(solver);
      } catch (_error) {
        e = _error;
        if (e instanceof BacktrackableError) {
          return solver;
        } else {
          throw e;
        }
      }
      throw new ParseError(solver.state, this);
    };

    Not.prototype.toString = function() {
      return "not(" + item + ")";
    };

    return Not;

  })(Expr);

  exports.not_ = function(item) {
    return new Not(item);
  };

  exports.Print = (function(_super) {
    __extends(Print, _super);

    function Print() {
      var items;

      items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.items = items;
    }

    Print.prototype.solve = function(solver) {
      var x, _i, _len, _ref1;

      _ref1 = this.items;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        console.log(x + ' ');
      }
      return solver;
    };

    Print.prototype.toString = function() {
      return "print(" + items + ")";
    };

    return Print;

  })(Expr);

  exports.print_ = function(items) {
    return new Print(items);
  };

  exports.Findall = (function(_super) {
    __extends(Findall, _super);

    function Findall(item) {
      this.item = item;
    }

    Findall.prototype.solve = function(solver) {
      var other, result;

      result = this.item.solve(solver);
      other = result.leftExprs;
      if (other) {
        return new exports.Findal(other).solve(solver);
      } else {
        return solver;
      }
    };

    Findall.prototype.toString = function() {
      return "findall(" + item + ")";
    };

    return Findall;

  })(Expr);

  exports.findall = function(item) {
    return new Findall(item);
  };

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
