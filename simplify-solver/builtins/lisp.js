// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, core, debug, general, if_, if_fun, iff_fun, macro, not_, special, _,
    __slice = [].slice;

  _ = require('underscore');

  core = require("../core");

  general = require("./general");

  special = core.special;

  macro = core.macro;

  debug = core.debug;

  exports.quote = special(1, 'quote', function(solver, cont, exp) {
    return cont(exp);
  });

  exports.eval_ = special(1, 'eval', function(solver, cont, exp) {
    return solver.solve(exp, function(v) {
      return solver.solve(v, cont);
    });
  });

  exports.assign = special(2, 'assign', function(solver, cont, vari, exp) {
    return solver.solve(exp, function(v) {
      if (v instanceof core.Var) {
        new core.TypeError(v, "do NOT assign free logic var to var");
      }
      vari.binding = v;
      return cont(v);
    });
  });

  exports.zero = special(1, 'zero', function(solver, cont, vari, exp) {
    return function(v) {
      vari.binding = 0;
      return cont(v);
    };
  });

  exports.one = special(1, 'one', function(solver, cont, vari, exp) {
    return function(v) {
      vari.binding = 1;
      return cont(v);
    };
  });

  exports.begin = special(null, 'begin', function() {
    var cont, exps, solver;

    solver = arguments[0], cont = arguments[1], exps = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.solveExps(exps, cont);
  });

  if_fun = function(solver, cont, test, then_, else_) {
    return solver.solve(test, function(v) {
      if (v) {
        return solver.solve(then_, cont);
      } else {
        return solver.solve(else_, cont);
      }
    });
  };

  exports.if_ = if_ = special([2, 3], 'if_', if_fun);

  iff_fun = function(solver, cont, clauses, else_) {
    var action, length, test, then_, _ref, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new exports.TypeError(clauses);
    } else if (length === 1) {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      return if_fun(solver, cont, test, then_, else_);
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      action = function(v) {
        if (v) {
          return solver.solve(then_, cont);
        } else {
          return iff_fun(solver, cont, clauses.slice(1), else_);
        }
      };
      return solver.solve(test, action);
    }
  };

  exports.iff = special(-2, 'iff', iff_fun);

  exports.block = block = special(null, 'block', function() {
    var body, cont, fun, label, solver;

    solver = arguments[0], cont = arguments[1], label = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    fun = function(v) {
      var continues, defaultContinues, defaultExits, exits, holder, result, _base, _base1, _base2, _base3, _ref, _ref1, _ref2, _ref3;

      exits = (_ref = (_base = solver.exits)[label]) != null ? _ref : _base[label] = [];
      exits.push(cont);
      defaultExits = (_ref1 = (_base1 = solver.exits)['']) != null ? _ref1 : _base1[''] = [];
      defaultExits.push(cont);
      holder = [null];
      continues = (_ref2 = (_base2 = solver.continues)[label]) != null ? _ref2 : _base2[label] = [];
      continues.push(holder);
      defaultContinues = (_ref3 = (_base3 = solver.continues)['']) != null ? _ref3 : _base3[''] = [];
      defaultContinues.push(holder);
      holder[0] = fun;
      result = solver.solveExps(body, cont);
      exits.pop();
      if (exits.length === 0) {
        delete solver.exits[label];
      }
      continues.pop();
      if (continues.length === 0) {
        delete solver.continues[label];
      }
      defaultExits.pop();
      defaultContinues.pop();
      return result;
    };
    return fun(null);
  });

  exports.break_ = break_ = special([0, 1, 2], 'break_', function(solver, cont, label, value) {
    var exitCont, exits;

    if (label == null) {
      label = '';
    }
    if (value == null) {
      value = null;
    }
    if (value !== null && !_.isString(label)) {
      throw new TypeError([label, value]);
    }
    if (value === null && !_.isString(label)) {
      value = label;
      label = '';
    }
    exits = solver.exits[label];
    if (!exits || exits === []) {
      throw new Error(label);
    }
    exitCont = exits[exits.length - 1];
    return solver.solve(value, solver.protect(exitCont));
  });

  exports.continue_ = continue_ = special([0, 1], 'continue_', function(solver, cont, label) {
    var continueCont, continues;

    if (label == null) {
      label = '';
    }
    continues = solver.continues[label];
    if (!continues || continues === []) {
      throw new Error(label);
    }
    continueCont = continues[continues.length - 1];
    return solver.protect(continueCont[0])(null);
  });

  not_ = general.not_;

  exports.loop_ = macro(null, 'loop', function() {
    var body, label;

    label = arguments[0], body = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!_.isString(label)) {
      label = '';
      body = [label].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  });

  exports.while_ = macro(null, 'while_', function() {
    var body, label, test;

    label = arguments[0], test = arguments[1], body = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    return block.apply(null, [label].concat(__slice.call([if_(not_(test), break_(label))].concat(body).concat([continue_(label)]))));
  });

  exports.until_ = macro(null, 'until_', function() {
    var body, label, test, _i;

    label = arguments[0], body = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), test = arguments[_i++];
    if (!_.isString(label)) {
      label = '';
      test = label;
      body = [test].concat(body);
    }
    body = body.concat([if_(not_(test), continue_(label))]);
    return block.apply(null, [label].concat(__slice.call(body)));
  });

  exports.catch_ = special(-1, 'catch_', function() {
    var cont, forms, solver, tag;

    solver = arguments[0], cont = arguments[1], tag = arguments[2], forms = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return solver.solve(tag, function(v) {
      solver.pushCatch(v, cont);
      return solver.solveExps(forms, function(v2) {
        solver.popCatch(v);
        return cont(v2);
      });
    });
  });

  exports.throw_ = special(2, 'throw_', function(solver, cont, tag, form) {
    return solver.solve(tag, function(v) {
      return solver.solve(form, function(v2) {
        return solver.protect(solver.findCatch(v))(v2);
      });
    });
  });

  exports.protect = special(-1, 'protect', function() {
    var cleanup, cont, form, oldprotect, solver;

    solver = arguments[0], cont = arguments[1], form = arguments[2], cleanup = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    oldprotect = solver.protect;
    solver.protect = function(fun) {
      return function(v1) {
        return solver.solveExps(cleanup, function(v2) {
          solver.protect = oldprotect;
          return oldprotect(fun)(v1);
        });
      };
    };
    return solver.solve(form, function(v1) {
      return solver.solveExps(cleanup, function(v2) {
        solver.protect = oldprotect;
        return cont(v1);
      });
    });
  });

  exports.callcc = special(1, 'callcc', function(solver, cont, fun) {
    return function(v) {
      var cc, faked;

      faked = solver.fake();
      cc = function(v) {
        var result;

        solver.restore(faked);
        result = solver.run(v, cont);
        solver.finished = false;
        return solver.trail.getvalue(result[1]);
      };
      return cont(fun(cc));
    };
  });

  exports.callfc = special(1, 'callfc', function(solver, cont, fun) {
    return function(v) {
      var faked, fc;

      faked = solver.fake();
      fc = function(v) {
        var result;

        solver.restore(faked);
        result = solver.run(v, solver.failcont);
        solver.finished = false;
        return solver.trail.getvalue(result[1]);
      };
      return cont(fun(fc));
    };
  });

  exports.callcs = special(1, 'callcs', function(solver, cont, fun) {
    return function(v) {
      return cont(fun(solver, solver.fake(), cont));
    };
  });

  exports.quasiquote = exports.qq = special(1, 'quasiquote', function(solver, cont, item) {
    return typeof solver.quasiquote === "function" ? solver.quasiquote(item, cont) : void 0;
  });

  exports.unquote = exports.uq = special(1, 'unquote', function(solver, cont, item) {
    throw new Error("unquote: too many unquote and unquoteSlice");
  });

  exports.unquoteSlice = exports.uqs = special(1, 'unquoteSlice', function(solver, cont, item) {
    throw new Error("unquoteSlice: too many unquote and unquoteSlice");
  });

}).call(this);

/*
//@ sourceMappingURL=lisp.map
*/
