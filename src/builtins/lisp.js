// Generated by CoffeeScript 1.6.2
(function() {
  var block, break_, continue_, if_fun, iff_fun, macro, solve, special,
    __slice = [].slice;

  solve = require("../../src/solve");

  special = solve.special;

  macro = solve.macro;

  exports.quote = special(function(solver, cont, exp) {
    return function(v, solver) {
      return cont(exp, solver);
    };
  });

  exports.eval_ = special(function(solver, cont, exp) {
    return solver.cont(exp, function(v, solver) {
      return [solver.cont(v, cont), null, solver];
    });
  });

  exports.assign = special(function(solver, cont, vari, exp) {
    return solver.cont(exp, function(v, solver) {
      vari.binding = v;
      return [cont, v, solver];
    });
  });

  exports.begin = special(function() {
    var cont, exps, solver;

    solver = arguments[0], cont = arguments[1], exps = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.expsCont(exps, cont);
  });

  if_fun = function(solver, cont, test, then_, else_) {
    var else_cont, then_cont;

    then_cont = solver.cont(then_, cont);
    else_cont = solver.cont(else_, cont);
    return solver.cont(test, function(v, solver) {
      if (v) {
        return [then_cont, v, solver];
      } else {
        return [else_cont, v, solver];
      }
    });
  };

  exports.if_ = special(if_fun);

  iff_fun = function(solver, cont, clauses, else_) {
    var iff_else_cont, length, test, then_, then_cont, _ref, _ref1;

    length = clauses.length;
    if (length === 0) {
      throw new exports.TypeError(clauses);
    } else if (length === 1) {
      _ref = clauses[0], test = _ref[0], then_ = _ref[1];
      return if_fun(solver, cont, test, then_, else_);
    } else {
      _ref1 = clauses[0], test = _ref1[0], then_ = _ref1[1];
      then_cont = solver.cont(then_, cont);
      iff_else_cont = iff_fun(solver, cont, clauses.slice(1), else_);
      return solver.cont(test, function(v, solver) {
        if (v) {
          return [then_cont, v, solver];
        } else {
          return [iff_else_cont, v, solver];
        }
      });
    }
  };

  exports.iff = special(iff_fun);

  /* iff's macro version
  iff = macro (clauses_, else_) ->
    length = clauses.length
    if length is 0 then throw new exports.TypeError(clauses)
    else if length is 1
      exports.if_(clauses[0][0], clauses[0][1], else_)
    else
       exports.if_(clauses[0][0], clauses[0][1], iff(clauses[1...], else_)
  */


  exports.block = block = special(function() {
    var body, cont, continues, exits, fun, holder, label, solver, _base, _base1, _ref, _ref1;

    solver = arguments[0], cont = arguments[1], label = arguments[2], body = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    exits = (_ref = (_base = solver.exits)[label]) != null ? _ref : _base[label] = [];
    exits.push(cont);
    continues = (_ref1 = (_base1 = solver.continues)[label]) != null ? _ref1 : _base1[label] = [];
    holder = [null];
    continues.push(holder);
    holder[0] = fun = solver.expsCont(body, cont);
    exits.pop();
    continues.pop();
    return fun;
  });

  exports.break_ = break_ = special(function(solver, cont, label, value) {
    var exitCont, exits;

    if (label == null) {
      label = null;
    }
    if (value == null) {
      value = null;
    }
    exits = solver.exits[label];
    if (!exits || exits === []) {
      throw Error(label);
    }
    exitCont = exits[exits.length - 1];
    return solver.cont(value, function(v, solver) {
      var protect;

      protect = solver.protect;
      if (typeof protect === "function") {
        protect(null, solver);
      }
      return exitCont(v, solver);
    });
  });

  exports.continue_ = continue_ = special(function(solver, cont, label) {
    var continueCont, continues;

    if (label == null) {
      label = null;
    }
    continues = solver.continues[label];
    if (!continues || continues === []) {
      throw Error(label);
    }
    continueCont = continues[continues.length - 1];
    return function(v, solver) {
      var protect;

      protect = solver.protect;
      if (typeof protect === "function") {
        protect(null, solver);
      }
      return continueCont[0](v, solver);
    };
  });

  exports.loop = macro(function(label, body) {
    return block.apply(null, [label].concat(__slice.call(body.concat([continue_(label)]))));
  });

  exports.while_ = macro(function(label, test, body) {
    return block(label, [if_(not_(test), break_(label))].concat(body).concat([continue_(label)]));
  });

  exports.until = macro(function(label, body, test) {
    body = body.concat([exports.if_(exports.not_(test), exports.continue_(label))]);
    return exports.block.apply(exports, [label].concat(__slice.call(body)));
  });

  exports.catch_ = special(function() {
    var cont, forms, solver, tag;

    solver = arguments[0], cont = arguments[1], tag = arguments[2], forms = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return solver.cont(tag, function(v, solver) {
      solver.pushCatch(v, function(v, solver) {
        return cont(v, solver);
      });
      return solver.exps_cont(forms, cont)(v, solver);
    });
  });

  exports.throw_ = special(function(solver, cont, tag, form) {
    return solver.cont(tag, function(v, solver) {
      return solver.cont(form, function(v2, solver) {
        solver.protects(null);
        return solver.findCatch(v)(v2);
      });
    });
  });

  exports.unwindprotect = special(function() {
    var cleanup, cleanupCont, cleanupProtect, cont, form, oldprotect, result, solver;

    solver = arguments[0], cont = arguments[1], form = arguments[2], cleanup = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    oldprotect = solver.protect;
    cleanupProtect = solver.expsCont(cleanup, oldprotect);
    compiler.protect = function(v, solver) {
      return cleanupProtect(v, solver);
    };
    cleanupCont = function(v1, solver) {
      return solver.expsCont(cleanup, function(v2, solver) {
        return cont(v1, solver);
      });
    };
    result = solver.cont(form, cleanupCont);
    solver.protect = oldprotect;
    return result;
  });

  /*
  exports.calcc = special((solver, cont, fun) ->
    body = fun.body.subst(dict(fun.params[0], LamdaVar(fun.params[0].name)))
    k = compiler.new_var(new il.ConstLocalVar('cont'))
    params = (x.interlang() for x in fun.params)
    function1 = il.Lamda([k]+params, body.cps(compiler, k))
    k1 = compiler.new_var(new il.ConstLocalVar('cont'))
    v = compiler.new_var(new il.ConstLocalVar('v'))
    function1(cont, il.Lamda([k1, v], cont(v)))
  
    quasiquote_args: (args) ->
      if not args then pyield []
      else if args.length is 1
        for x in @quasiquote(args[0])
          try pyield x.unquote_splice
          catch e then pyield [x]
      else
        for x in @quasiquote(args[0])
          for y in @quasiquote_args(args[1..])
            try x = x.unquote_splice
            catch e then x = [x]
            pyield x+y
  
    #@special
    callfc = (compiler, cont, fun) ->
      Todo_callfc_need_tests
      fun(il.failcont)
  */


}).call(this);

/*
//@ sourceMappingURL=lisp.map
*/
