// Generated by CoffeeScript 1.6.2
(function() {
  var Trail, macro, orp_fun, solve, special, unifyFun, unifyList, unifyListFun,
    __slice = [].slice;

  solve = require("../../src/solve");

  special = solve.special;

  macro = solve.macro;

  Trail = solve.Trail;

  exports.succeed = special('succeed', function(solver, cont) {
    return cont;
  })();

  exports.fail = special('fail', function(solver, cont) {
    return function(v, solver) {
      return [solver.failcont, v, solver];
    };
  })();

  exports.andp = special('andp', function() {
    var args, cont, solver;

    solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.expsCont(args, cont);
  });

  exports.ifp = special('ifp', function(solver, cont, test, action) {
    return solver.cont(test, solver.cont(action, cont));
  });

  exports.cutable = special('cutable', function(solver, cont, x) {
    return function(v, solver) {
      var cc;

      cc = solver.cutCont;
      return solver.cont(x, function(v, solver) {
        solver.cutCont = cc;
        return [cont, v, solver];
      })(null, solver);
    };
  });

  exports.cut = special('cut', function(solver, cont) {
    return function(v, solver) {
      solver.failcont = solver.cutCont;
      return [cont, v, solver];
    };
  })();

  exports.orp = special('orp', function(solver, cont, x, y) {
    var xcont, ycont;

    xcont = solver.cont(x, cont);
    ycont = solver.cont(y, cont);
    return function(v, solver) {
      var fc, state, trail;

      trail = new Trail;
      state = solver.state;
      fc = solver.failcont;
      solver.failcont = function(v, solver) {
        trail.undo();
        solver.state = state;
        solver.failcont = fc;
        return [ycont, v, solver];
      };
      solver.trail = trail;
      return [xcont, null, solver];
    };
  });

  orp_fun = function() {
    var args, cont, length, solver, x, xcont, y, ycont;

    solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else if (length === 2) {
      x = args[0];
      y = args[1];
      xcont = solver.cont(x, cont);
      ycont = solver.cont(y, cont);
    } else {
      x = args[0];
      y = args.slice(1);
      xcont = solver.cont(x, cont);
      ycont = orp_fun.apply(null, [solver, cont].concat(__slice.call(y)));
    }
    return (function(xcont, ycont) {
      return function(v, solver) {
        var fc, state, trail;

        trail = new Trail;
        state = solver.state;
        fc = solver.failcont;
        solver.failcont = function(v, solver) {
          trail.undo();
          solver.state = state;
          solver.failcont = fc;
          return [ycont, v, solver];
        };
        solver.trail = trail;
        return [xcont, null, solver];
      };
    })(xcont, ycont);
  };

  exports.orp = special('orp', orp_fun);

  exports.notp = special('notp', function(solver, cont, x) {
    return function(v, solver) {
      var fc, state, trail;

      trail = solver.trail;
      solver.trail = new Trail;
      fc = solver.failcont;
      state = solver.state;
      solver.failcont = function(v, solver) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return [cont, v, solver];
      };
      return solver.cont(x, function(v, solver) {
        solver.failcont = fc;
        return [fc, v, solver];
      })(v, solver);
    };
  });

  exports.repeat = special('repeat', function(solver, cont) {
    return function(v, solver) {
      solver.failcont = cont;
      return [cont, null, solver];
    };
  })();

  exports.findall = special('findall', function(solver, cont, exp) {
    var findallcont;

    findallcont = solver.cont(exp, function(v, solver) {
      return [solver.failcont, v, solver];
    });
    return function(v, solver) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v, solver) {
        solver.failcont = fc;
        return [cont, v, solver];
      };
      return [findallcont, v, solver];
    };
  });

  exports.xfindall = special('findall', function(solver, cont, exp) {
    var findallcont;

    findallcont = solver.cont(exp, solver.failcont);
    return function(v, solver) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v, solver) {
        solver.failcont = fc;
        return [cont, v, solver];
      };
      return [findallcont, v, solver];
    };
  });

  exports.once = special('once', function(solver, cont, x) {
    return function(v, solver) {
      var fc;

      fc = solver.failcont;
      return [
        solver.cont(x, function(v, solver) {
          solver.failcont = fc;
          return [cont, v, solver];
        }), null, solver
      ];
    };
  });

  exports.unifyFun = unifyFun = function(solver, cont, x, y) {
    return function(v, solver) {
      if (solver.trail.unify(x, y)) {
        return [cont, true, solver];
      } else {
        return [solver.failcont, false, solver];
      }
    };
  };

  exports.unify = special('unify', unifyFun);

  exports.is_ = special('is_', function(solver, cont, vari, exp) {
    return solver.cont(exp, function(v, solver) {
      vari.bind(v, solver.trail);
      return [cont, true, solver];
    });
  });

  exports.unifyListFun = unifyListFun = function(solver, cont, xs, ys) {
    return function(v, solver) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont;
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (!solver.trail.unify(xs[i], ys[i])) {
            return [solver.failcont, false, solver];
          }
        }
      }
      return [cont, true, solver];
    };
  };

  exports.unifyList = unifyList = special('unify_list', unifyListFun);

  exports.rule = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname_rule';
    }
    return macro(name, function() {
      var args, body, clauses, head, i;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clauses = fun.apply(null, args);
      clauses = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = clauses.length; _i < _ref; i = _i += 2) {
          head = clauses[i];
          body = clauses[i + 1];
          _results.push(andp(unifyList(head, args), body));
        }
        return _results;
      })();
      return orp.apply(null, clauses);
    });
  };

}).call(this);

/*
//@ sourceMappingURL=logic.map
*/
