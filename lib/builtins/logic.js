// Generated by CoffeeScript 1.6.2
(function() {
  var ArgumentError, Trail, Var, andp, binaryPredicate, callfc, findall1, findall2, macro, notunifyFun, notunifyList, notunifyListFun, orp, orpFun, runner, solve, special, unaryPredicate, unifyFun, unifyList, unifyListFun,
    __slice = [].slice;

  ArgumentError = (solve = require("../dao")).ArgumentError;

  special = solve.special;

  macro = solve.macro;

  Trail = solve.Trail;

  Var = solve.Var;

  exports.succeed = special(0, 'succeed', function(solver, cont) {
    return cont;
  })();

  exports.fail = special(0, 'fail', function(solver, cont) {
    return function(v) {
      return solver.failcont(v);
    };
  })();

  exports.prependFailcont = special(1, 'setFailcont', function(solver, cont, fun) {
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        fun();
        return fc(v);
      };
      return cont(v);
    };
  });

  exports.andp = andp = special(null, 'andp', function() {
    var args, cont, solver;

    solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.expsCont(args, cont);
  });

  orpFun = function() {
    var args, cont, fc, length, orcont, solver, state, trail, x, xcont, y, ycont;

    solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else if (length === 2) {
      x = args[0];
      y = args[1];
      xcont = solver.cont(x, cont);
      ycont = solver.cont(y, cont);
    } else {
      x = args[0];
      y = args.slice(1);
      xcont = solver.cont(x, cont);
      ycont = orpFun.apply(null, [solver, cont].concat(__slice.call(y)));
    }
    trail = state = fc = null;
    orcont = function(v) {
      trail.undo();
      solver.state = state;
      solver.failcont = fc;
      return [ycont, v];
    };
    return function(v) {
      trail = new Trail;
      state = solver.state;
      fc = solver.failcont;
      solver.trail = trail;
      solver.failcont = orcont;
      return [xcont, null];
    };
  };

  exports.orp = orp = special(null, 'orp', orpFun);

  exports.cutable = special(1, 'cutable', function(solver, cont, x) {
    var cc, xcont;

    cc = null;
    xcont = solver.cont(x, function(v) {
      solver.cutCont = cc;
      return [cont, v];
    });
    return function(v) {
      cc = solver.cutCont;
      return xcont(null);
    };
  });

  exports.cut = special(0, 'cut', function(solver, cont) {
    return function(v) {
      solver.failcont = solver.cutCont;
      return cont(v);
    };
  })();

  exports.ifp = special([2, 3], 'ifp', function(solver, cont, test, action, else_) {
    var actionCont, cc, ccCont, elseCont, resultCont;

    cc = null;
    ccCont = function(v) {
      solver.cutCont = cc;
      return cont(v);
    };
    actionCont = solver.cont(action, ccCont);
    resultCont = solver.cont(test, function(v) {
      solver.failcont = solver.cutCont;
      return actionCont(v);
    });
    if (else_ != null) {
      elseCont = solver.cont(else_, ccCont);
      return function(v) {
        var fc, state, trail;

        cc = solver.cutCont;
        trail = new Trail;
        state = solver.state;
        fc = solver.failcont;
        solver.failcont = function(v) {
          trail.undo();
          solver.state = state;
          solver.failcont = function(v) {
            solver.failcont = fc;
            return fc(v);
          };
          return elseCont(v);
        };
        return resultCont(v);
      };
    } else {
      return function(v) {
        cc = solver.cutCont;
        return resultCont(v);
      };
    }
  });

  exports.notp = special(1, 'notp', function(solver, cont, x) {
    var fc, mycont;

    fc = null;
    mycont = solver.cont(x, function(v) {
      solver.failcont = fc;
      return [fc, v];
    });
    return function(v) {
      var state, trail;

      trail = solver.trail;
      solver.trail = new Trail;
      fc = solver.failcont;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return [cont, v];
      };
      return mycont(v);
    };
  });

  exports.repeat = special(0, 'repeat', function(solver, cont) {
    return function(v) {
      solver.failcont = cont;
      return [cont, null];
    };
  })();

  exports.findall = function(exp, result, template) {
    if (result === void 0) {
      return findall1(exp);
    } else {
      return findall2(exp, result, template);
    }
  };

  findall1 = special(1, 'findall', function(solver, cont, exp) {
    var fc, findallDone, findnext;

    fc = null;
    findnext = solver.cont(exp, function(v) {
      return solver.failcont(v);
    });
    findallDone = function(v) {
      solver.failcont = fc;
      return [cont, v];
    };
    return function(v) {
      fc = solver.failcont;
      solver.failcont = findallDone;
      return [findnext, v];
    };
  });

  findall2 = special(3, 'findall', function(solver, cont, exp, result, template) {
    var fc, findallDone, findnext, result1;

    result1 = null;
    fc = null;
    findnext = solver.cont(exp, function(v) {
      result1.push(solver.trail.getvalue(template));
      return solver.failcont(v);
    });
    findallDone = function(v) {
      solver.failcont = fc;
      return [cont, v];
    };
    return function(v) {
      result1 = [];
      result.bind(result1, solver.trail);
      fc = solver.failcont;
      solver.failcont = findallDone;
      return [findnext, v];
    };
  });

  exports.once = special(1, 'once', function(solver, cont, x) {
    var cont1, fc;

    fc = null;
    cont1 = solver.cont(x, function(v) {
      solver.failcont = fc;
      return cont(v);
    });
    return function(v) {
      fc = solver.failcont;
      return [cont1, null];
    };
  });

  exports.is_ = special(2, 'is_', function(solver, cont, vari, exp) {
    return solver.cont(exp, function(v) {
      vari.bind(v, solver.trail);
      return [cont, true];
    });
  });

  exports.bind = special(2, 'bind', function(solver, cont, vari, term) {
    return function(v) {
      vari.bind(solver.trail.deref(term), solver.trail);
      return [cont, true];
    };
  });

  exports.unifyFun = unifyFun = function(solver, cont, x, y) {
    return function(v) {
      if (solver.trail.unify(x, y)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    };
  };

  exports.unify = special(2, 'unify', unifyFun);

  exports.notunifyFun = notunifyFun = function(solver, cont, x, y) {
    return function(v) {
      if (!solver.trail.unify(x, y)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    };
  };

  exports.notunify = special(2, 'notunify', notunifyFun);

  exports.unifyListFun = unifyListFun = function(solver, cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (!solver.trail.unify(xs[i], ys[i])) {
            return solver.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.unifyList = unifyList = special(2, 'unifyList', unifyListFun);

  exports.notunifyListFun = notunifyListFun = function(solver, cont, xs, ys) {
    return function(v) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont(false);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (solver.trail.unify(xs[i], ys[i])) {
            return solver.failcont(false);
          }
        }
      }
      return cont(true);
    };
  };

  exports.notunifyList = notunifyList = special(2, 'notunifyList', notunifyListFun);

  exports.rule = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname_rule';
    }
    return macro(arity, name, function() {
      var args, body, clauses, head, i, length, result;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clauses = fun.apply(null, args);
      length = clauses.length;
      if (length === 0) {
        return succeed;
      }
      result = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = length - 1; _i < _ref; i = _i += 2) {
          head = clauses[i];
          body = clauses[i + 1];
          _results.push(andp(unifyList(head, args), body));
        }
        return _results;
      })();
      if (length - Math.floor(length / 2) * 2 === 1) {
        result.push(clauses[length - 1]);
      }
      return orp.apply(null, result);
    });
  };

  runner = function(solver, cont) {
    return function(v) {
      var _ref;

      while (!solver.done) {
        _ref = cont(v), cont = _ref[0], v = _ref[1];
      }
      solver.done = false;
      return v;
    };
  };

  callfc = require("./lisp").callfc;

  exports.callfc = callfc;

  exports.truep = special(1, 'truep', function(solver, cont, fun, x) {
    return solver.cont(x, function(x1) {
      if (x1) {
        return cont(x1);
      } else {
        return solver.failcont(x1);
      }
    });
  });

  exports.falsep = special(1, 'falsep', function(solver, cont, fun, x) {
    return solver.cont(x, function(x1) {
      if (!x1) {
        return cont(x1);
      } else {
        return solver.failcont(x1);
      }
    });
  });

  exports.unaryPredicate = unaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(1, name, function(solver, cont, x) {
      return solver.cont(x, function(x1) {
        var result;

        result = fun(x1);
        if (result) {
          return cont(result);
        } else {
          return solver.failcont(result);
        }
      });
    });
  };

  exports.binaryPredicate = binaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(2, name, function(solver, cont, x, y) {
      var x1, ycont;

      x1 = null;
      return ycont = solver.cont(y, function(y1) {
        var result;

        result = fun(x1, y1);
        if (result) {
          return cont(result);
        } else {
          return solver.failcont(result);
        }
      }, solver.cont(x, function(v) {
        x1 = v;
        return ycont(null);
      }));
    });
  };

  exports.eqp = binaryPredicate(function(x, y) {
    return x === y;
  });

  exports.nep = binaryPredicate(function(x, y) {
    return x !== y;
  });

  exports.ltp = binaryPredicate(function(x, y) {
    return x < y;
  });

  exports.lep = binaryPredicate(function(x, y) {
    return x <= y;
  });

  exports.gtp = binaryPredicate(function(x, y) {
    return x > y;
  });

  exports.gep = binaryPredicate(function(x, y) {
    return x >= y;
  });

  exports.ternaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(3, name, function(solver, cont, x, y, z) {
      var ycont, zcont;

      zcont = solver.cont(z, function(z) {
        var result;

        result = fun(x, y, z);
        if (result) {
          return cont(result);
        } else {
          return solver.failcont(result);
        }
      });
      return ycont = solver.cont(y, function(v) {
        y = v;
        return zcont(null);
      }, solver.cont(x, function(v) {
        x = v;
        return ycont(null);
      }));
    });
  };

  exports.functionPredicate = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(arity, name, function() {
      var args, cont, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return solver.argsCont(args, function(params) {
        var result;

        result = fun.apply(null, params);
        if (result) {
          return cont(result);
        } else {
          return solver.failcont(result);
        }
      });
    });
  };

  exports.between = special(3, 'between', function(solver, cont, fun, x, y, z) {
    var y1, ycont, z1, zcont;

    y1 = z1 = null;
    zcont = solver.cont(z, function(zz) {
      var fc, y11;

      if (x1 instanceof dao.Var) {
        throw dao.TypeError(x);
      } else if (y1 instanceof dao.Var) {
        throw new dao.TypeError(y);
      }
      if (y1 instanceof dao.Var) {
        y11 = y1;
        fc = solver.failcont;
        solver.failcont = function(v) {
          y11++;
          if (y11 > z1) {
            return fc(v);
          } else {
            y1.bind(y11, solver.trail);
            return cont(y11);
          }
        };
        y1.bind(y11, solver.trail);
        return cont(y11);
      } else {
        if ((x1 <= y1 && y1 <= z1)) {
          return cont(true);
        } else {
          return solver.failcont(false);
        }
      }
    });
    ycont = solver.cont(y, function(v) {
      y1 = v;
      return zcont(null);
    });
    return solver.cont(x, function(v) {
      var x1;

      x1 = v;
      return ycont(null);
    });
  });

  exports.rangep = special(2, 'rangep', function(solver, cont, x, y) {
    var x1, ycont;

    x1 = null;
    ycont = solver.cont(y, function(y) {
      var fc, result;

      if (x1 instanceof dao.Var) {
        throw dao.TypeError(x);
      } else if (y1 instanceof dao.Var) {
        throw new dao.TypeError(y);
      } else if (x1 > y1) {
        return solver.failcont(false);
      }
      result = x1;
      fc = solver.failcont;
      solver.failcont = function(v) {
        result++;
        if (result > y1) {
          return fc(v);
        } else {
          return cont(result);
        }
      };
      return cont(result);
    });
    return solver.cont(x, function(v) {
      x1 = v;
      return ycont(null);
    });
  });

  exports.varp = special(1, 'varp', function(solver, cont, x) {
    return solver.cont(x, function(x1) {
      if (x1 instanceof dao.Var) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.nonvarp = special(1, 'notvarp', function(solver, cont, x) {
    return solver.cont(x, function(x1) {
      if (!(x1 instanceof dao.Var)) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    });
  });

  exports.freep = special(1, 'freep', function(solver, cont, x) {
    return function(v) {
      if (solver.trail.deref(x) instanceof Var) {
        return cont(true);
      } else {
        return solver.failcont(false);
      }
    };
  });

  exports.numberp = special(1, 'numberp', function(solver, cont, x) {
    return solver.cont(x, function(x1) {}, _.isNumber(x1) ? cont(true) : solver.failcont(false));
  });

  exports.stringp = special(1, 'stringp', function(solver, cont, x) {
    return solver.cont(x, function(x1) {}, _.isString(x1) ? cont(true) : solver.failcont(false));
  });

  exports.atomp = special(1, 'atomp', function(solver, cont, x) {
    return solver.cont(x, function(x1) {}, _.isNumber(x1) || _.isString(x1) ? cont(true) : solver.failcont(false));
  });

  exports.listp = special(1, 'listp', function(solver, cont, x) {
    return solver.cont(x, function(x1) {}, _.isArray(x1) ? cont(true) : solver.failcont(false));
  });

  exports.callablep = special(1, 'callablep', function(solver, cont, x) {
    return solver.cont(x, function(x1) {}, x1 instanceof dao.Apply ? cont(true) : solver.failcont(false));
  });

}).call(this);

/*
//@ sourceMappingURL=logic.map
*/
