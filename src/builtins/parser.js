// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, Trail, TypeError, Var, dao, dqstring, name, solve, solver, special, sqstring, _, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  dao = require("../../src/solve");

  solver = dao.solver;

  _ref = (function() {
    var _i, _len, _ref, _results;

    _ref = "Trail, solve, Var,  ExpressionError, TypeError, special".split(", ");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      _results.push(dao[name]);
    }
    return _results;
  })(), Trail = _ref[0], solve = _ref[1], Var = _ref[2], ExpressionError = _ref[3], TypeError = _ref[4], special = _ref[5];

  exports.parse = special('parse', function(cont, exp, state) {
    return function(v) {
      var old_state;

      old_state = solver.state;
      solver.state = state;
      return solver.cont(exp, function(v) {
        solver.state = old_state;
        return [cont, v];
      })(true);
    };
  });

  exports.parse = special('parse', function(cont, exp, state) {
    var old_state;

    old_state = solver.state;
    solver.state = state;
    return solver.cont(exp, function(v) {
      solver.state = old_state;
      return [cont, v];
    });
  });

  exports.parsetext = exports.parsesequence = function(exp, sequence) {
    return exports.parse(exp, [sequence, 0]);
  };

  exports.setstate = special('setstate', function(cont, state) {
    return function(v) {
      solver.state = state;
      return cont(v);
    };
  });

  exports.settext = exports.setsequence = function(sequence) {
    return exports.setstate([sequence, 0]);
  };

  exports.getstate = special('getstate', function(cont) {
    return function(v) {
      return cont(solver.state);
    };
  });

  exports.gettext = exports.getsequence = special('gettext', function(cont) {
    return function(v) {
      return cont(solver.state[0]);
    };
  });

  exports.getpos = special('getpos', function(cont) {
    return function(v) {
      return cont(solver.state[1]);
    };
  });

  exports.eoi = special('eoi', function(cont) {
    return function(v) {
      var data, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos === data.length) {
        return cont(true);
      } else {
        return solver.failcont(v);
      }
    };
  })();

  exports.boi = special('boi', function(cont) {
    return function(v) {
      if (solver.state[1] === 0) {
        return cont(true);
      } else {
        return solver.failcont(v);
      }
    };
  })();

  exports.step = special('step', function(cont, n) {
    if (n == null) {
      n = 1;
    }
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      solver.state = [text, pos + n];
      return cont(pos + n);
    };
  });

  exports.lefttext = special('lefttext', function(cont) {
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      return cont(text.slice(pos));
    };
  });

  exports.subtext = exports.subsequence = special('subtext', function(cont, length, start) {
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      start = (start != null) || pos;
      length = (length != null) || text.length;
      return cont(text.slice(start, start + length));
    };
  });

  exports.nextchar = special('nextchar', function(cont) {
    return function(v) {
      var pos, text, _ref1;

      _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
      return cont(text[pos]);
    };
  });

  exports.follow = special('follow', function(cont, item) {
    return function(v) {
      var state;

      state = solver.state;
      return solver.cont(item, function(v) {
        solver.state = state;
        return cont(v);
      })(v);
    };
  });

  exports.may = special('may', function(cont, exp) {
    return function(v) {
      var exp_cont, fc;

      fc = solver.failcont;
      exp_cont = solver.cont(exp, cont);
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return exp_cont(v);
    };
  });

  exports.may = special('may', function(cont, exp) {
    var exp_cont, fc;

    fc = solver.failcont;
    exp_cont = solver.cont(exp, cont);
    solver.failcont = function(v) {
      solver.failcont = fc;
      return cont(v);
    };
    return exp_cont;
  });

  exports.lazymay = special('lazymay', function(cont, exp) {
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return solver.cont(exp, cont)(v);
      };
      return cont(v);
    };
  });

  exports.greedymay = special('greedymay', function(cont, exp) {
    return function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return solver.cont(exp, function(v) {
        return solver.failcont = fc;
      }, cont(v))(v);
    };
  });

  exports.any = special('any', function(cont, exp) {
    var anyCont;

    anyCont = function(v) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v) {
        solver.failcont = fc;
        return cont(v);
      };
      return solver.cont(exp, anyCont)(v);
    };
    return anyCont;
  });

  exports.any = special('any', function(cont, exp) {
    var anyCont;

    anyCont = function(v) {
      var fc, state, trail;

      fc = solver.failcont;
      trail = solver.trail;
      solver.trail = new dao.Trail;
      state = solver.state;
      solver.failcont = function(v) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return cont(v);
      };
      return solver.cont(exp, anyCont)(v);
    };
    return anyCont;
  });

  exports.lazyany = special('lazyany', function(cont, exp) {
    return function(v) {
      var anyCont, anyFcont, fc;

      fc = solver.failcont;
      anyCont = function(v) {
        solver.failcont = anyFcont;
        return cont(v);
      };
      anyFcont = function(v) {
        solver.failcont = fc;
        return solver.cont(exp, anyCont);
      };
      return anyCont(v);
    };
  });

  exports.lazyany = special('lazyany', function(cont, exp) {
    var anyCont, anyFcont, expcont, fc;

    fc = solver.failcont;
    anyCont = function(v) {
      solver.failcont = anyFcont;
      return cont(v);
    };
    expcont = solver.cont(exp, anyCont);
    anyFcont = function(v) {
      solver.failcont = fc;
      return expcont(v);
    };
    return anyCont;
  });

  exports.greedyany = special('greedyany', function(cont, exp) {
    return function(v) {
      var anyCont, fc;

      fc = solver.failcont;
      anyCont = function(v) {
        solver.failcont = function(v) {
          solver.failcont = fc;
          return cont(v);
        };
        return [solver.cont(exp, anyCont), v];
      };
      return anyCont(v);
    };
  });

  exports.char = special('char', function(cont, x) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos === data.length) {
        return solver.failcont(v);
      }
      trail = solver.trail;
      x = trail.deref(x);
      c = data[pos];
      if (x instanceof Var) {
        x.bind(c, solver.trail);
        solver.state = [data, pos + 1];
        return cont(pos + 1);
      } else if (x === c) {
        solver.state = [data, pos + 1];
        return cont(v);
      } else if (_.isString(x)) {
        if (x.length === 1) {
          return solver.failcont(v);
        } else {
          throw new ExpressionError(x);
        }
      } else {
        throw new TypeError(x);
      }
    };
  });

  exports.xchar = special('char', function(cont, x) {
    return function(v) {
      var c, data, pos, trail, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos === data.length) {
        return solver.failcont(false);
      }
      trail = solver.trail;
      x = trail.deref(x);
      c = data[pos];
      if (x instanceof Var) {
        trail.set(x, c);
        return cont(pos + 1);
      } else if (x === c) {
        solver.state = [data, pos + 1];
        return cont(pos + 1);
      } else if (_.isString(x)) {
        if (x.length === 1) {
          return solver.failcont(false);
        } else {
          throw new ExpressionError(x);
        }
      } else {
        throw new TypeError(x);
      }
    };
  });

  exports.charWhen = special('charWhen', function(cont, test) {
    return function(v) {
      var c, data, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      if (pos === data.length) {
        return solver.failcont(false);
      }
      c = data[pos];
      if (test(c)) {
        return cont(c);
      } else {
        return solver.failcont(c);
      }
    };
  });

  exports.charBetween = function(x, start, end) {
    return exports.charWhen(x, function(c) {
      return (start < c && c < end);
    });
  };

  exports.charIn = function(x, set) {
    return exports.charWhen(x, function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digit = exports.charWhen(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digit1_9 = exports.charWhen(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lower = exports.charWhen(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.upper = exports.charWhen(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letter = exports.charWhen(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetter = exports.charWhen(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDight = exports.charWhen(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspace = exports.charIn(' \t');

  exports.whitespace = exports.charIn(' \t\r\n');

  exports.newline = exports.charIn('\r\n');

  exports.stringWhile = special('stringWhile', function(cont, test) {
    return function(v) {
      var c, data, length, p, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      length = data.length;
      if (pos === length) {
        return solver.failcont(false);
      }
      c = data[pos];
      if (!test(c)) {
        return solver.failcont(c);
      }
      p = pos + 1;
      while (p < length && test(data[p])) {
        p;
      }
      return cont(text.slice(pos, p));
    };
  });

  exports.stringBetween = function(start, end) {
    return exports.stringWhile(function(c) {
      return (start < c && c < end);
    });
  };

  exports.stringIn = function(set) {
    return exports.stringWhile(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digits = exports.stringWhile(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digits1_9 = exports.stringWhile(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lowers = exports.stringWhile(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.uppers = exports.stringWhile(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letters = exports.stringWhile(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetters = exports.stringWhile(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDights = exports.stringWhile(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspaces = exports.stringIn(' \t');

  exports.whitespaces = exports.stringIn(' \t\r\n');

  exports.newlinespaces = exports.stringIn('\r\n');

  exports.stringWhile0 = special('stringWhile0', function(cont, test) {
    return function(v) {
      var c, data, length, p, pos, _ref1;

      _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
      length = data.length;
      if (pos === length) {
        return cont('');
      }
      c = data[pos];
      if (!test(c)) {
        return cont('');
      }
      p = pos + 1;
      while (p < length && test(data[p])) {
        p;
      }
      return cont(text.slice(pos, p));
    };
  });

  exports.stringBetween0 = function(start, end) {
    return exports.stringWhile0(function(c) {
      return (start < c && c < end);
    });
  };

  exports.stringIn0 = function(set) {
    return exports.stringWhile0(function(c) {
      return __indexOf.call(set, c) >= 0;
    });
  };

  exports.digits0 = exports.stringWhile0(function(c) {
    return ('0' <= c && c <= '9');
  });

  exports.digits1_90 = exports.stringWhile0(function(c) {
    return ('1' <= c && c <= '9');
  });

  exports.lowers0 = exports.stringWhile0(function(c) {
    return ('a' <= c && c <= 'z');
  });

  exports.uppers0 = exports.stringWhile0(function(c) {
    return ('A' <= c && c <= 'Z');
  });

  exports.letters0 = exports.stringWhile0(function(c) {
    return (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetters0 = exports.stringWhile0(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z'));
  });

  exports.underlineLetterDights0 = exports.stringWhile0(function(c) {
    return (c === '_') || (('a' <= c && c <= 'z')) || (('A' <= c && c <= 'Z')) || (('0' <= c && c <= '9'));
  });

  exports.tabspaces0 = exports.stringIn0(' \t');

  exports.whitespaces0 = exports.stringIn0(' \t\r\n');

  exports.newlines0 = exports.stringIn0('\r\n');

  exports.float = special('float', function(cont, arg) {
    return function(v) {
      var length, p, pos, text, val, value, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

      _ref1 = solver.parse_state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      if ((!'0' <= (_ref2 = text[pos]) && _ref2 <= '9') && text[pos] !== '.') {
        return solver.failcont(v);
      }
      p = pos;
      while (p < length && ('0' <= (_ref3 = text[p]) && _ref3 <= '9')) {
        p++;
      }
      if (p < length && text[p] === '.') {
        p++;
      }
      while (p < length && ('0' <= (_ref4 = text[p]) && _ref4 <= '9')) {
        p++;
      }
      if (p < length - 1 && (_ref5 = text[p], __indexOf.call('eE', _ref5) >= 0)) {
        p++;
        p++;
      }
      while (p < length && ('0' <= (_ref6 = text[p]) && _ref6 <= '9')) {
        p++;
      }
      if (text[{
        pos: p
      }] === '.') {
        return solver.failcont(v);
      }
      val = eval(text.slice(pos, p));
      arg = solver.trail.deref(arg);
      value = eval(text[{
        pos: p
      }]);
      if (arg instanceof Var) {
        arg.bind(value, solver.trail);
        return cont(value);
      } else {
        if (_.isNumber(arg)) {
          if (arg === value) {
            return cont(arg);
          } else {
            return solver.failcont(v)(s);
          }
        } else {
          throw new exports.TypeError(arg);
        }
      }
    };
  });

  exports.literal = special('literal', function(cont, arg) {
    return function(v) {
      var length, pos, text, _ref1;

      _ref1 = solver.parse_state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      arg = solver.trail.deref(arg);
      if (arg instanceof Var) {
        throw new exports.TypeError(arg);
      } else {
        if (text.slice(pos).indexOf(arg) === 0) {
          solver.state = [text, pos + arg.length];
          return cont(pos + arg.length);
        } else {
          return solver.failcont(false);
        }
      }
    };
  });

  exports.quoteString = special('quoteString', function(cont, quote) {
    return function(v) {
      var char, length, p, pos, string, text, _ref1;

      string = '';
      _ref1 = solver.parse_state, text = _ref1[0], pos = _ref1[1];
      length = text.length;
      if (pos >= length) {
        return solver.failcont(v);
      }
      quote = solver.trail.deref(quote);
      if (arg instanceof Var) {
        throw new exports.TypeError(arg);
      }
      if (text[pos] !== quote) {
        return solver.failcont(v);
      }
      p = pos + 1;
      while (p < length) {
        char = text[p];
        p += 1;
        if (char === '\\') {
          p++;
        } else if (char === quote) {
          string = text.slice(pos + 1, p);
          break;
        }
      }
      if (p === length) {
        return solver.failcont(v);
      }
      return cont(string);
    };
  });

  dqstring = exports.quoteString('"');

  sqstring = exports.quoteString("'");

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
