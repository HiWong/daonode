// Generated by CoffeeScript 1.6.2
(function() {
  var Trail, Var, andp, binaryPredicate, macro, notunifyFun, notunifyList, notunifyListFun, orp, orpFun, solve, special, unaryPredicate, unifyFun, unifyList, unifyListFun,
    __slice = [].slice;

  solve = require("../dao");

  special = solve.special;

  macro = solve.macro;

  Trail = solve.Trail;

  Var = solve.Var;

  exports.succeed = special(0, 'succeed', function(solver, cont) {
    return cont;
  })();

  exports.fail = special(0, 'fail', function(solver, cont) {
    return function(v, solver) {
      return solver.failcont(v, solver);
    };
  })();

  exports.prependFailcont = special(1, 'setFailcont', function(solver, cont, fun) {
    return function(v, solver) {
      var fc;

      fc = solver.failcont;
      solver.failcont = function(v, solver) {
        fun();
        return fc(v, solver);
      };
      return cont(v, solver);
    };
  });

  exports.andp = andp = special(null, 'andp', function() {
    var args, cont, solver;

    solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return solver.expsCont(args, cont);
  });

  orpFun = function() {
    var args, cont, fc, length, orcont, solver, state, trail, x, xcont, y, ycont;

    solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    length = args.length;
    if (length === 0) {
      throw new ArgumentError(args);
    } else if (length === 1) {
      return solver.cont(args[0], cont);
    } else if (length === 2) {
      x = args[0];
      y = args[1];
      xcont = solver.cont(x, cont);
      ycont = solver.cont(y, cont);
    } else {
      x = args[0];
      y = args.slice(1);
      xcont = solver.cont(x, cont);
      ycont = orpFun.apply(null, [solver, cont].concat(__slice.call(y)));
    }
    trail = state = fc = null;
    orcont = function(v, solver) {
      trail.undo();
      solver.state = state;
      solver.failcont = fc;
      return [ycont, v, solver];
    };
    return function(v, solver) {
      trail = new Trail;
      state = solver.state;
      fc = solver.failcont;
      solver.trail = trail;
      solver.failcont = orcont;
      return [xcont, null, solver];
    };
  };

  exports.orp = orp = special(null, 'orp', orpFun);

  exports.cutable = special(1, 'cutable', function(solver, cont, x) {
    var cc, xcont;

    cc = null;
    xcont = solver.cont(x, function(v, solver) {
      solver.cutCont = cc;
      return [cont, v, solver];
    });
    return function(v, solver) {
      cc = solver.cutCont;
      return xcont(null, solver);
    };
  });

  exports.cut = special(0, 'cut', function(solver, cont) {
    return function(v, solver) {
      solver.failcont = solver.cutCont;
      return cont(v, solver);
    };
  })();

  exports.ifp = special([2, 3], 'ifp', function(solver, cont, test, action, else_) {
    var actionCont, cc, ccCont, elseCont, resultCont;

    cc = null;
    ccCont = function(v, solver) {
      solver.cutCont = cc;
      return cont(v, solver);
    };
    actionCont = solver.cont(action, ccCont);
    resultCont = solver.cont(test, function(v, solver) {
      solver.failcont = solver.cutCont;
      return actionCont(v, solver);
    });
    if (else_ != null) {
      elseCont = solver.cont(else_, ccCont);
      return function(v, solver) {
        var fc, state, trail;

        cc = solver.cutCont;
        trail = new Trail;
        state = solver.state;
        fc = solver.failcont;
        solver.failcont = function(v, solver) {
          trail.undo();
          solver.state = state;
          solver.failcont = function(v, solver) {
            solver.failcont = fc;
            return fc(v, solver);
          };
          return elseCont(v, solver);
        };
        return resultCont(v, solver);
      };
    } else {
      return function(v, solver) {
        cc = solver.cutCont;
        return resultCont(v, solver);
      };
    }
  });

  exports.notp = special(1, 'notp', function(solver, cont, x) {
    var fc, mycont;

    fc = null;
    mycont = solver.cont(x, function(v, solver) {
      solver.failcont = fc;
      return [fc, v, solver];
    });
    return function(v, solver) {
      var state, trail;

      trail = solver.trail;
      solver.trail = new Trail;
      fc = solver.failcont;
      state = solver.state;
      solver.failcont = function(v, solver) {
        solver.trail.undo();
        solver.trail = trail;
        solver.state = state;
        solver.failcont = fc;
        return [cont, v, solver];
      };
      return mycont(v, solver);
    };
  });

  exports.repeat = special(0, 'repeat', function(solver, cont) {
    return function(v, solver) {
      solver.failcont = cont;
      return [cont, null, solver];
    };
  })();

  exports.findall = special(1, 'findall', function(solver, cont, exp) {
    var fc, findallDone, findnext;

    fc = null;
    findnext = solver.cont(exp, function(v, solver) {
      return solver.failcont(v, solver);
    });
    findallDone = function(v, solver) {
      solver.failcont = fc;
      return [cont, v, solver];
    };
    return function(v, solver) {
      fc = solver.failcont;
      solver.failcont = findallDone;
      return [findnext, v, solver];
    };
  });

  exports.once = special(1, 'once', function(solver, cont, x) {
    var cont1, fc;

    fc = null;
    cont1 = solver.cont(x, function(v, solver) {
      solver.failcont = fc;
      return cont(v, solver);
    });
    return function(v, solver) {
      fc = solver.failcont;
      return [cont1, null, solver];
    };
  });

  exports.is_ = special(2, 'is_', function(solver, cont, vari, exp) {
    return solver.cont(exp, function(v, solver) {
      vari.bind(v, solver.trail);
      return [cont, true, solver];
    });
  });

  exports.bind = special(2, 'bind', function(solver, cont, vari, term) {
    return function(v, solver) {
      vari.bind(solver.trail.deref(term), solver.trail);
      return [cont, true, solver];
    };
  });

  exports.unifyFun = unifyFun = function(solver, cont, x, y) {
    return function(v, solver) {
      if (solver.trail.unify(x, y)) {
        return cont(true, solver);
      } else {
        return solver.failcont(false, solver);
      }
    };
  };

  exports.unify = special(2, 'unify', unifyFun);

  exports.notunifyFun = notunifyFun = function(solver, cont, x, y) {
    return function(v, solver) {
      if (!solver.trail.unify(x, y)) {
        return cont(true, solver);
      } else {
        return solver.failcont(false, solver);
      }
    };
  };

  exports.notunify = special(2, 'notunify', notunifyFun);

  exports.unifyListFun = unifyListFun = function(solver, cont, xs, ys) {
    return function(v, solver) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont(false, solver);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (!solver.trail.unify(xs[i], ys[i])) {
            return solver.failcont(false, solver);
          }
        }
      }
      return cont(true, solver);
    };
  };

  exports.unifyList = unifyList = special(2, 'unifyList', unifyListFun);

  exports.notunifyListFun = notunifyListFun = function(solver, cont, xs, ys) {
    return function(v, solver) {
      var i, xlen, _i;

      xlen = xs.length;
      if (ys.length !== xlen) {
        solver.failcont(false, solver);
      } else {
        for (i = _i = 0; 0 <= xlen ? _i < xlen : _i > xlen; i = 0 <= xlen ? ++_i : --_i) {
          if (solver.trail.unify(xs[i], ys[i])) {
            return solver.failcont(false, solver);
          }
        }
      }
      return cont(true, solver);
    };
  };

  exports.notunifyList = notunifyList = special(2, 'notunifyList', notunifyListFun);

  exports.rule = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname_rule';
    }
    return macro(arity, name, function() {
      var args, body, clauses, head, i, length, result;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clauses = fun.apply(null, args);
      length = clauses.length;
      if (length === 0) {
        return succeed;
      }
      result = (function() {
        var _i, _ref, _results;

        _results = [];
        for (i = _i = 0, _ref = length - 1; _i < _ref; i = _i += 2) {
          head = clauses[i];
          body = clauses[i + 1];
          _results.push(andp(unifyList(head, args), body));
        }
        return _results;
      })();
      if (length - Math.floor(length / 2) * 2 === 1) {
        result.push(clauses[length - 1]);
      }
      return orp.apply(null, result);
    });
  };

  exports.callfc = special(1, 'callfc', function(solver, cont, fun) {
    return function(v, solver) {
      var result;

      result = fun(solver.failcont)[1];
      solver.done = false;
      return cont(result, solver);
    };
  });

  exports.truep = special(1, 'truep', function(solver, cont, fun, x) {
    return solver.cont(x, function(x1, solver) {
      if (x1) {
        return cont(x1, solver);
      } else {
        return solver.failcont(x1, solver);
      }
    });
  });

  exports.falsep = special(1, 'falsep', function(solver, cont, fun, x) {
    return solver.cont(x, function(x1, solver) {
      if (!x1) {
        return cont(x1, solver);
      } else {
        return solver.failcont(x1, solver);
      }
    });
  });

  exports.unaryPredicate = unaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(1, name, function(solver, cont, x) {
      return solver.cont(x, function(x1, solver) {
        var result;

        result = fun(x1);
        if (result) {
          return cont(result, solver);
        } else {
          return solver.failcont(result, solver);
        }
      });
    });
  };

  exports.binaryPredicate = binaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(2, name, function(solver, cont, x, y) {
      var x1, ycont;

      x1 = null;
      return ycont = solver.cont(y, function(y1, solver) {
        var result;

        result = fun(x1, y1);
        if (result) {
          return cont(result, solver);
        } else {
          return solver.failcont(result, solver);
        }
      }, solver.cont(x, function(v, solver) {
        x1 = v;
        return ycont(null, solver);
      }));
    });
  };

  exports.eqp = binaryPredicate(function(x, y) {
    return x === y;
  });

  exports.nep = binaryPredicate(function(x, y) {
    return x !== y;
  });

  exports.ltp = binaryPredicate(function(x, y) {
    return x < y;
  });

  exports.lep = binaryPredicate(function(x, y) {
    return x <= y;
  });

  exports.gtp = binaryPredicate(function(x, y) {
    return x > y;
  });

  exports.gep = binaryPredicate(function(x, y) {
    return x >= y;
  });

  exports.ternaryPredicate = function(name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(3, name, function(solver, cont, x, y, z) {
      var ycont, zcont;

      zcont = solver.cont(z, function(z, solver) {
        var result;

        result = fun(x, y, z);
        if (result) {
          return cont(result, solver);
        } else {
          return solver.failcont(result, solver);
        }
      });
      return ycont = solver.cont(y, function(v, solver) {
        y = v;
        return zcont(null, solver);
      }, solver.cont(x, function(v, solver) {
        x = v;
        return ycont(null, solver);
      }));
    });
  };

  exports.functionPredicate = function(arity, name, fun) {
    if (fun == null) {
      fun = name;
      name = 'noname';
    }
    return special(arity, name, function() {
      var args, cont, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return solver.argsCont(args, function(params, solver) {
        var result;

        result = fun.apply(null, params);
        if (result) {
          return cont(result, solver);
        } else {
          return solver.failcont(result, solver);
        }
      });
    });
  };

  exports.between = special(3, 'between', function(solver, cont, fun, x, y, z) {
    var y1, ycont, z1, zcont;

    y1 = z1 = null;
    zcont = solver.cont(z, function(zz, solver) {
      var fc, y11;

      if (x1 instanceof dao.Var) {
        throw dao.TypeError(x);
      } else if (y1 instanceof dao.Var) {
        throw new dao.TypeError(y);
      }
      if (y1 instanceof dao.Var) {
        y11 = y1;
        fc = solver.failcont;
        solver.failcont = function(v, solver) {
          y11++;
          if (y11 > z1) {
            return fc(v, solver);
          } else {
            y1.bind(y11, solver.trail);
            return cont(y11, solver);
          }
        };
        y1.bind(y11, solver.trail);
        return cont(y11, solver);
      } else {
        if ((x1 <= y1 && y1 <= z1)) {
          return cont(true, solver);
        } else {
          return solver.failcont(false, solver);
        }
      }
    });
    ycont = solver.cont(y, function(v, solver) {
      y1 = v;
      return zcont(null, solver);
    });
    return solver.cont(x, function(v, solver) {
      var x1;

      x1 = v;
      return ycont(null, solver);
    });
  });

  exports.rangep = special(2, 'rangep', function(solver, cont, x, y) {
    var x1, ycont;

    x1 = null;
    ycont = solver.cont(y, function(y, solver) {
      var fc, result;

      if (x1 instanceof dao.Var) {
        throw dao.TypeError(x);
      } else if (y1 instanceof dao.Var) {
        throw new dao.TypeError(y);
      } else if (x1 > y1) {
        return solver.failcont(false, solver);
      }
      result = x1;
      fc = solver.failcont;
      solver.failcont = function(v, solver) {
        result++;
        if (result > y1) {
          return fc(v, solver);
        } else {
          return cont(result, solver);
        }
      };
      return cont(result, solver);
    });
    return solver.cont(x, function(v, solver) {
      x1 = v;
      return ycont(null, solver);
    });
  });

  exports.varp = special(1, 'varp', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {
      if (x1 instanceof dao.Var) {
        return cont(true, solver);
      } else {
        return solver.failcont(false, solver);
      }
    });
  });

  exports.nonvarp = special(1, 'notvarp', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {
      if (!(x1 instanceof dao.Var)) {
        return cont(true, solver);
      } else {
        return solver.failcont(false, solver);
      }
    });
  });

  exports.freep = special(1, 'freep', function(solver, cont, x) {
    return function(v, solver) {
      if (solver.trail.deref(x) instanceof Var) {
        return cont(true, solver);
      } else {
        return solver.failcont(false, solver);
      }
    };
  });

  exports.numberp = special(1, 'numberp', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {}, _.isNumber(x1) ? cont(true, solver) : solver.failcont(false, solver));
  });

  exports.stringp = special(1, 'stringp', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {}, _.isString(x1) ? cont(true, solver) : solver.failcont(false, solver));
  });

  exports.atomp = special(1, 'atomp', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {}, _.isNumber(x1) || _.isString(x1) ? cont(true, solver) : solver.failcont(false, solver));
  });

  exports.listp = special(1, 'listp', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {}, _.isArray(x1) ? cont(true, solver) : solver.failcont(false, solver));
  });

  exports.callablep = special(1, 'callablep', function(solver, cont, x) {
    return solver.cont(x, function(x1, solver) {}, x1 instanceof dao.Apply ? cont(true, solver) : solver.failcont(false, solver));
  });

}).call(this);

/*
//@ sourceMappingURL=logic.map
*/
