// Generated by CoffeeScript 1.6.2
(function() {
  var callcc, callfc, catch_, cps_convert_exps, if_fun, throw_, unwind_protect,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if_fun = function(compiler, cont, test, then_, else_) {
    var v;

    v = compiler.new_var(new il.ConstLocalVar('v'));
    return test.cps(compiler, il.clamda(v, new il.If(v, then_.cps(compiler, cont), else_.cps(compiler, cont))));
  };

  dao.if_ = dao.special('if', if_fun);

  cps_convert_exps = function(compiler, exps, cont) {
    var v;

    v = compiler.new_var(new il.ConstLocalVar('v'));
    if (!exps) {
      il.PassStatement();
    }
    if (exps.length === 1) {
      return exps[0].cps(compiler, cont);
    } else {
      return exps[0].cps(compiler, new il.Clamda(v, cps_convert_exps(compiler, exps.slice(1), cont)));
    }
  };

  callcc = function(compiler, cont, fun) {
    var body, function1, k, k1, params, v, x;

    body = fun.body.subst(dict(fun.params[0], LamdaVar(fun.params[0].name)));
    k = compiler.new_var(new il.ConstLocalVar('cont'));
    params = (function() {
      var _i, _len, _ref, _results;

      _ref = fun.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        _results.push(x.interlang());
      }
      return _results;
    })();
    function1 = il.Lamda([k] + params, body.cps(compiler, k));
    k1 = compiler.new_var(new il.ConstLocalVar('cont'));
    v = compiler.new_var(new il.ConstLocalVar('v'));
    return function1(cont, il.Lamda([k1, v], cont(v)));
  };

  callfc = function(compiler, cont, fun) {
    Todo_callfc_need_tests;    return fun(il.failcont);
  };

  dao.block = function() {
    var exps, label, x;

    label = arguments[0], exps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return new dao.Block(label, begin.apply(null, (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        x = exps[_i];
        _results.push(element(x));
      }
      return _results;
    })()));
  };

  dao.Block = (function(_super) {
    __extends(Block, _super);

    function Block(label, body) {
      this.label = label;
      this.body = body;
    }

    Block.prototype.alpha = function(env, compiler) {
      var body, label;

      label = compiler.new_var(this.label);
      compiler.block_label_stack.push([this.label, label]);
      body = this.body.alpha(env, compiler);
      compiler.block_label_stack.pop();
      return Block(label, body);
    };

    Block.prototype.subst = function(bindings) {
      return new dao.Block(this.label, this.body.subst(bindings));
    };

    Block.prototype.cps = function(compiler, cont) {
      var block_fun, v, v1, v2;

      v = compiler.new_var(new il.ConstLocalVar('v'));
      v1 = compiler.new_var(new il.ConstLocalVar('v'));
      v2 = compiler.new_var(new il.ConstLocalVar('v'));
      block_fun = compiler.new_var(new il.ConstLocalVar('block_' + this.label.name));
      compiler.exit_block_cont_map[this.label.name] = il.clamda(v1, cont(v1));
      compiler.continue_block_cont_map[this.label.name] = il.clamda(v2, block_fun(v2));
      return il.cfunction(block_fun, v, this.body.cps(compiler, cont))(il.NONE);
    };

    Block.prototype.toString = function() {
      return "Block(" + this.label + ", " + this.body + ")";
    };

    return Block;

  })(dao.Element);

  dao.exit_block = function(label, value) {
    if (label == null) {
      label = NONE;
    }
    if (value == null) {
      value = NONE;
    }
    return dao.ExitBlock(element(label), element(value));
  };

  dao.ExitBlock = (function(_super) {
    __extends(ExitBlock, _super);

    function ExitBlock(label, value) {
      this.label = label != null ? label : NONE;
      this.value = value != null ? value : NONE;
    }

    ExitBlock.prototype.alpha = function(env, compiler) {
      var label;

      if (this.label === NONE) {
        label = compiler.get_inner_block_label(NONE);
      } else {
        label = compiler.get_block_label(this.label);
      }
      return ExitBlock(label, this.value.alpha(env, compiler));
    };

    ExitBlock.prototype.cps = function(compiler, cont) {
      var v;

      v = compiler.new_var(new il.ConstLocalVar('v'));
      return this.value.cps(compiler, il.clamda(v, compiler.protect_cont(NONE), compiler.exit_block_cont_map[this.label.name](v)));
    };

    ExitBlock.prototype.toString = function() {
      return "exit_block(" + this.label + ", " + this.value + ")";
    };

    return ExitBlock;

  })(dao.Element);

  dao.continue_block = function(label) {
    if (label == null) {
      label = NONE;
    }
    return dao.ContinueBlock(element(label));
  };

  dao.ContinueBlock = (function(_super) {
    __extends(ContinueBlock, _super);

    function ContinueBlock(label) {
      this.label = label != null ? label : NONE;
    }

    ContinueBlock.prototype.alpha = function(env, compiler) {
      var label;

      if (this.label === NONE) {
        label = compiler.get_inner_block_label(NONE);
      } else {
        label = compiler.get_block_label(this.label);
      }
      return new dao.ContinueBlock(label);
    };

    ContinueBlock.prototype.cps = function(compiler, cont) {
      return il.begin(compiler.protect_cont(NONE), compiler.continue_block_cont_map[this.label.name](il.NONE));
    };

    ContinueBlock.prototype.toString = function() {
      return "continue_block(" + this.label + ")";
    };

    return ContinueBlock;

  })(dao.Element);

  catch_ = function() {
    var compiler, cont, form, k, tag, v, v2;

    compiler = arguments[0], cont = arguments[1], tag = arguments[2], form = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    v = compiler.new_var(new il.ConstLocalVar('v'));
    v2 = compiler.new_var(new il.ConstLocalVar('v'));
    k = compiler.new_var(il.LocalVar('cont'));
    return tag.cps(compiler, il.clamda(v, il.Assign(k, il.clamda(v2, cont(v2))), il.PushCatchCont(v, k), begin.apply(null, form).cps(compiler, cont)));
  };

  throw_ = function(compiler, cont, tag, form) {
    var v, v2;

    v = compiler.new_var(new il.ConstLocalVar('v'));
    v2 = compiler.new_var(new il.ConstLocalVar('v'));
    return tag.cps(compiler, il.clamda(v, form.cps(compiler, il.clamda(v2, compiler.protect_cont(NONE), il.FindCatchCont(v)(v2)))));
  };

  unwind_protect = function() {
    var cleanup, cleanup_cont, cleanup_protect, compiler, cont, form, old_protect_cont, result, v, v1, v2;

    compiler = arguments[0], cont = arguments[1], form = arguments[2], cleanup = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    v = compiler.new_var(new il.ConstLocalVar('v'));
    v1 = compiler.new_var(new il.ConstLocalVar('v'));
    v2 = compiler.new_var(new il.ConstLocalVar('v'));
    old_protect_cont = compiler.protect_cont;
    compiler.protect_cont = il.clamda(v, NONE);
    cleanup_protect = begin.apply(null, cleanup).cps(compiler, old_protect_cont);
    compiler.protect_cont.body = cleanup_protect;
    cleanup_cont = il.clamda(v1, begin.apply(null, cleanup).cps(compiler, il.clamda(v2, cont(v1))));
    result = form.cps(compiler, cleanup_cont);
    compiler.protect_cont = old_protect_cont;
    return result;
  };

  ({
    quasiquote_args: function(args) {
      var e, x, y, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;

      if (!args) {
        return pyield([]);
      } else if (args.length === 1) {
        _ref = this.quasiquote(args[0]);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          try {
            _results.push(pyield(x.unquote_splice));
          } catch (_error) {
            e = _error;
            _results.push(pyield([x]));
          }
        }
        return _results;
      } else {
        _ref1 = this.quasiquote(args[0]);
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          x = _ref1[_j];
          _results1.push((function() {
            var _k, _len2, _ref2, _results2;

            _ref2 = this.quasiquote_args(args.slice(1));
            _results2 = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              y = _ref2[_k];
              try {
                x = x.unquote_splice;
              } catch (_error) {
                e = _error;
                x = [x];
              }
              _results2.push(pyield(x + y));
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }
    }
  });

}).call(this);

/*
//@ sourceMappingURL=special.map
*/
