// Generated by CoffeeScript 1.6.2
(function() {
  var baseRules, cursor, memoRule, symbolToParentsMap, text, textLength, _memo,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  symbolToParentsMap = {};

  baseRules = {};

  _memo = {};

  text = '';

  textLength = 0;

  cursor = 0;

  _memo = {};

  exports.clear = function() {
    baseRules = {};
    return symbolToParentsMap = {};
  };

  exports.parse = function(data, root) {
    text = data;
    textLength = text.length;
    cursor = 0;
    _memo = {};
    return root(0);
  };

  exports.andp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      cursor = start;
      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (!(result = exp(cursor))) {
          return;
        }
      }
      return result;
    };
  };

  exports.orp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (result = exp(start)) {
          return result;
        }
      }
    };
  };

  exports.notp = function(exp) {
    return function(start) {
      if (exp(start)) {

      } else {
        return true;
      }
    };
  };

  exports.char = function(c) {
    return function(start) {
      if (text[start] === c) {
        cursor = start + 1;
        return c;
      }
    };
  };

  exports.literal = function(string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  exports.spaces = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  exports.spaces1 = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return cursor = cursor;
      return len;
    }
  };

  exports.wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    return function(start) {
      var result;

      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  exports.addParentChildrens = function() {
    var children, list, map, name, parent, parentChildren, parentChildrens, _i, _len, _results;

    parentChildrens = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    map = symbolToParentsMap;
    _results = [];
    for (_i = 0, _len = parentChildrens.length; _i < _len; _i++) {
      parentChildren = parentChildrens[_i];
      _results.push((function() {
        var _results1;

        _results1 = [];
        for (parent in parentChildren) {
          children = parentChildren[parent];
          _results1.push((function() {
            var _j, _len1, _ref, _results2;

            _results2 = [];
            for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
              name = children[_j];
              list = (_ref = map[name]) != null ? _ref : map[name] = [];
              if (parent !== name && __indexOf.call(list, parent) < 0) {
                _results2.push(list.push(parent));
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.addRecCircles = function() {
    var circle, i, j, length, list, map, name, parent, recursiveCircles, _i, _len, _results;

    recursiveCircles = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    map = symbolToParentsMap;
    _results = [];
    for (_i = 0, _len = recursiveCircles.length; _i < _len; _i++) {
      circle = recursiveCircles[_i];
      i = 0;
      length = circle.length;
      _results.push((function() {
        var _ref, _results1;

        _results1 = [];
        while (i < length) {
          if (i === length - 1) {
            j = 0;
          } else {
            j = i + 1;
          }
          name = circle[i];
          list = (_ref = map[name]) != null ? _ref : map[name] = [];
          parent = circle[j];
          if (parent !== name && __indexOf.call(list, parent) < 0) {
            list.push(parent);
          }
          _results1.push(i++);
        }
        return _results1;
      })());
    }
    return _results;
  };

  exports.setMemoRules = function(rules) {
    var map, name, _results;

    map = symbolToParentsMap;
    _results = [];
    for (name in map) {
      baseRules[name] = rules[name];
      _results.push(rules[name] = memoRule(name));
    }
    return _results;
  };

  exports.memoRule = memoRule = function(symbol) {
    var addParent, agenda, map;

    map = symbolToParentsMap;
    agenda = [];
    addParent = function(parent) {
      var parents, _i, _len, _results;

      agenda.unshift(parent);
      parents = map[parent];
      if (parents) {
        _results = [];
        for (_i = 0, _len = parents.length; _i < _len; _i++) {
          parent = parents[_i];
          if (__indexOf.call(agenda, parent) < 0) {
            agenda.unshift(parent);
            _results.push(addParent(parent));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    addParent(symbol);
    return function(start) {
      var changed, hash, hash0, m, memo, parent, result, rule, _i, _len, _ref;

      memo = this._memo;
      hash0 = symbol + start;
      m = _memo[hash0];
      if (m) {
        cursor = m[1];
        return m[0];
      }
      while (agenda.length) {
        symbol = agenda.pop();
        hash = symbol + start;
        m = _memo[hash];
        if (!m) {
          m = _memo[hash] = [void 0, start];
        }
        rule = baseRules[symbol];
        changed = false;
        while (1) {
          if ((result = rule(start)) && (result !== m[0] || cursor !== m[1])) {
            _memo[hash] = m = [result, cursor];
            changed = true;
          } else {
            break;
          }
        }
        if (changed) {
          _ref = map[symbol];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            parent = _ref[_i];
            if (__indexOf.call(agenda, parent) < 0) {
              agenda.push(parent);
            }
          }
        }
      }
      m = _memo[hash0];
      cursor = m[1];
      return m[0];
    };
  };

  exports.memo = function(symbol) {
    return function(start) {
      var m;

      m = _memo[symbol + start];
      if (m) {
        cursor = m[1];
        return m[0];
      }
    };
  };

  exports.cur = function() {
    return cursor;
  };

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
