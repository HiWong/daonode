// Generated by CoffeeScript 1.6.2
(function() {
  var ExpressionError, Trail, TypeError, Var, defaultHash, defaultPureHash, special, _, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  special = require("../core").special;

  defaultPureHash = function() {
    var args, caller, name;

    name = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return (name || caller.name) + args.join(',');
  };

  exports.purememo = function(caller, name, hash) {
    if (name == null) {
      name = '';
    }
    if (hash == null) {
      hash = defaultPureHash;
    }
    if (!_.isString(name)) {
      hash = name;
      name = '';
    }
    return special(null, 'purememo', function() {
      var args, cont, fromCont, hashValue, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      hashValue = hash.apply(null, [name, caller].concat(__slice.call(args)));
      if (hashValue === void 0) {
        return solver.cont(caller.apply(null, args), cont);
      } else {
        fromCont = solver.cont(caller.apply(null, args), function(v) {
          solver.finished = true;
          return [cont, v];
        });
        return function(v) {
          var newCont, result, _ref1;

          if (solver.purememo.hasOwnProperty(hashValue)) {
            return cont(solver.purememo[hashValue]);
          } else {
            result = (_ref1 = solver.run(null, fromCont), newCont = _ref1[0], v = _ref1[1], _ref1);
            solver.finished = false;
            solver.purememo[hashValue] = v;
            return result;
          }
        };
      }
    });
  };

  exports.clearPureMemo = special(0, 'clearPureMemo', function(solver, cont) {
    return function(v) {
      solver._memoPureResult = {};
      return cont(v);
    };
  })();

  defaultHash = function() {
    var args, caller, name, solver;

    name = arguments[0], solver = arguments[1], caller = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    return (name || caller.name) + solver.state[1];
  };

  exports.memo = function(caller, name, hash) {
    if (name == null) {
      name = '';
    }
    if (hash == null) {
      hash = defaultHash;
    }
    if (!_.isString(name)) {
      hash = name;
      name = '';
    }
    return special(null, name, function() {
      var args, cont, solver;

      solver = arguments[0], cont = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return function(v) {
        var fromCont, hashValue, newCont, result, _ref1, _ref2;

        hashValue = hash.apply(null, [name, solver, caller].concat(__slice.call(args)));
        if (hashValue === void 0) {
          return solver.cont(caller.apply(null, args), cont);
        } else {
          fromCont = solver.cont(caller.apply(null, args), function(v) {
            solver.finished = true;
            return [cont, v];
          });
          if (solver.memo.hasOwnProperty(hashValue)) {
            _ref1 = solver.memo[hashValue], result = _ref1[0], solver.state[1] = _ref1[1];
            return cont(result);
          } else {
            result = (_ref2 = solver.run(null, fromCont), newCont = _ref2[0], v = _ref2[1], _ref2);
            solver.finished = false;
            solver.memo[hashValue] = [v, solver.state[1]];
            return result;
          }
        }
      };
    });
  };

  exports.clearmemo = special(0, 'clearmemo', function(solver, cont) {
    return function(v) {
      solver.memo = {};
      return cont(v);
    };
  })();

  exports.char = function(solver, x) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      x.bind(c, solver.trail);
      solver.state = [data, pos + 1];
      return pos + 1;
    } else if (x === c) {
      solver.state = [data, pos + 1];
      return pos + 1;
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return solver.failcont(pos);
      } else {
        throw new ExpressionError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.followChar = function(solver, x) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      throw new TypeError(x);
    } else if (x === c) {
      return pos;
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return solver.failcont(pos);
      } else {
        throw new ValueError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.notFollowChar = function(solver, x) {
    var c, data, pos, trail, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    x = trail.deref(x);
    c = data[pos];
    if (x instanceof Var) {
      throw new TypeError(x);
    } else if (x === c) {
      return solver.failcont(pos);
    } else if (_.isString(x)) {
      if (x.length === 1) {
        return pos;
      } else {
        throw new ValueError(x);
      }
    } else {
      throw new TypeError(x);
    }
  };

  exports.followChars = function(solver, chars) {
    var c, data, pos, trail, _ref1;

    chars = trail.deref(chars);
    if (chars instanceof Var) {
      throw new TypeError(chars);
    }
    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    c = data[pos];
    if (__indexOf.call(chars, c) >= 0) {
      return pos;
    } else if (!_.isString(chars)) {
      throw new TypeError(chars);
    } else {
      return solver.failcont(pos);
    }
  };

  exports.notFollowChars = function(solver, chars) {
    var c, data, pos, trail, _ref1;

    chars = trail.deref(chars);
    if (chars instanceof Var) {
      throw new TypeError(chars);
    }
    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    trail = solver.trail;
    c = data[pos];
    if (__indexOf.call(chars, c) >= 0) {
      return solver.failcont(pos);
    } else if (!_.isString(chars)) {
      throw new TypeError(chars);
    } else {
      return cont(pos);
    }
  };

  exports.charWhen = function(solver, test) {
    var c, data, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    if (pos >= data.length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (test(c)) {
      solver.state = [data, pos + 1];
      return pos;
    } else {
      return solver.failcont(pos);
    }
  };

  exports.spaces = function(solver) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (c !== ' ') {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && data[p] === ' ') {
      p++;
    }
    solver.state = [data, p];
    return p;
  };

  exports.spaces0 = function(solver) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos >= length) {
      return pos;
    }
    c = data[pos];
    if (c !== ' ') {
      return pos;
    }
    p = pos + 1;
    while (p < length && data[p] === ' ') {
      p++;
    }
    solver.state = [data, p];
    return pos;
  };

  exports.stringWhile = function(solver, test) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos === length) {
      return solver.failcont(pos);
    }
    c = data[pos];
    if (!test(c)) {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length && test(data[p])) {
      p++;
    }
    solver.state = [data, p];
    return data.slice(pos, p);
  };

  exports.stringWhile0 = function(solver, test) {
    var c, data, length, p, pos, _ref1;

    _ref1 = solver.state, data = _ref1[0], pos = _ref1[1];
    length = data.length;
    if (pos === length) {
      return '';
    }
    c = data[pos];
    if (!test(c)) {
      return '';
    }
    p = pos + 1;
    while (p < length && test(data[p])) {
      p++;
    }
    solver.state = [data, p];
    return data.slice(pos, p);
  };

  exports.number = exports.float = function(solver, arg) {
    var dot, length, p, pE, pos, text, value, _ref1, _ref2, _ref3, _ref4;

    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    p = pos;
    if (text[p] === '+' || text[p] === '-') {
      p++;
    }
    if (p >= length) {
      return solver.failcont(p);
    }
    dot = false;
    if (text[p] === '.') {
      dot = true;
      p++;
    }
    if (p >= length || text[p] < '0' || '9' < text[p]) {
      return solver.failcont(p);
    }
    p++;
    while (p < length && ('0' <= (_ref2 = text[p]) && _ref2 <= '9')) {
      p++;
    }
    if (!dot) {
      if (p < length && text[p] === '.') {
        p++;
      }
      while (p < length && ('0' <= (_ref3 = text[p]) && _ref3 <= '9')) {
        p++;
      }
    }
    if (p < length - 1 && text[p] === 'e' || text[p] === 'E') {
      p++;
      pE = p;
      if (p < length && (text[p] === '+' || text[p] === '-')) {
        p++;
      }
      if (p >= length || text[p] < '0' || '9' < text[p]) {
        p = pE - 1;
      } else {
        while (p < length && ('0' <= (_ref4 = text[p]) && _ref4 <= '9')) {
          p++;
        }
      }
    }
    arg = solver.trail.deref(arg);
    value = eval(text.slice(pos, p));
    if (arg instanceof Var) {
      arg.bind(value, solver.trail);
      solver.state = [text, p];
      return p;
    } else {
      if (_.isNumber(arg)) {
        if (arg === value) {
          solver.state = [text, p];
          return p;
        } else {
          return solver.failcont(pos);
        }
      } else {
        throw new TypeError(arg);
      }
    }
  };

  exports.literal = function(solver, arg) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      solver.state = [text, p];
      return p;
    } else {
      return solver.failcont(p);
    }
  };

  exports.followLiteral = function(solver, arg) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      return p;
    } else {
      return solver.failcont(p);
    }
  };

  exports.notFollowLiteral = function(solver, arg) {
    var i, length, length2, p, pos, text, _ref1;

    arg = solver.trail.deref(arg);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    i = 0;
    p = pos;
    length2 = arg.length;
    while (i < length2 && p < length && arg[i] === text[p]) {
      i++;
      p++;
    }
    if (i === length2) {
      return solver.failcont(p);
    } else {
      return p;
    }
  };

  exports.quoteString = function(solver, quote) {
    var char, length, p, pos, string, text, _ref1;

    string = '';
    _ref1 = solver.state, text = _ref1[0], pos = _ref1[1];
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    quote = solver.trail.deref(quote);
    if (arg instanceof Var) {
      throw new exports.TypeError(arg);
    }
    if (text[pos] !== quote) {
      return solver.failcont(pos);
    }
    p = pos + 1;
    while (p < length) {
      char = text[p];
      p++;
      if (char === '\\') {
        p++;
      } else if (char === quote) {
        string = text.slice(pos + 1, p);
        break;
      }
    }
    if (p === length) {
      return solver.failcont(p);
    }
    solver.state = [text, p];
    return string;
  };

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
