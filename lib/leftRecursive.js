// Generated by CoffeeScript 1.6.2
(function() {
  var BaseParser, DONE, ENTER, EXTEND, Parser, REDUCE,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ENTER = void 0;

  EXTEND = 1;

  REDUCE = 2;

  DONE = 3;

  BaseParser = (function() {
    function BaseParser() {}

    BaseParser.prototype.parse = function(code, options) {
      var oldIndentList, oldMemo, oldMemoState, oldText, oldTextLength, oldTokens, oldyy, result;

      oldText = global.text;
      oldTextLength = global.textLength;
      oldTokens = global.tokens;
      oldMemo = global.memo;
      oldMemoState = global.memoState;
      oldIndentList = global.indentList;
      oldyy = global.yy;
      global.text = code;
      global.textLength = code.length;
      this.cursor = 0;
      global.tokens = [];
      global.memo = {};
      global.memoState = {};
      global.indentList = [];
      this.tabWidth = 4;
      global.yy = this.yy;
      result = this.Root(0);
      global.text = oldText;
      global.textLength = oldTextLength;
      global.tokens = oldTokens;
      global.memo = oldMemo;
      global.memoState = oldMemoState;
      global.indentList = oldIndentList;
      return result;
    };

    BaseParser.prototype.andp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        _this.cursor = start;
        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (!(result = exp(_this.cursor))) {
            return;
          }
        }
        return result;
      };
    };

    BaseParser.prototype.orp = function(exps) {
      var _this = this;

      return function(start) {
        var exp, result, _i, _len;

        for (_i = 0, _len = exps.length; _i < _len; _i++) {
          exp = exps[_i];
          if (result = exp(start)) {
            return result;
          }
        }
      };
    };

    BaseParser.prototype.notp = function(exp) {
      var _this = this;

      return function(start) {
        if (exp(start)) {

        } else {
          return true;
        }
      };
    };

    BaseParser.prototype.char = function(c) {
      var _this = this;

      return function(start) {
        if (text[start] === c) {
          _this.cursor = start + 1;
          return c;
        }
      };
    };

    BaseParser.prototype.literal = function(string) {
      var _this = this;

      return function(start) {
        var len, stop;

        len = string.length;
        if (text.slice(start, stop = start + len) === string) {
          _this.cursor = stop;
          return true;
        }
      };
    };

    BaseParser.prototype.spaces = function(start) {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (text[this.cursor]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };

    BaseParser.prototype.spaces1 = function(start) {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (text[this.cursor]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return len;
      }
    };

    BaseParser.prototype.wrap = function(item, left, right) {
      if (left == null) {
        left = spaces;
      }
      if (right == null) {
        right = spaces;
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(this.cursor) && right(this.cursor))) {
          return result;
        }
      };
    };

    BaseParser.prototype.recursive = function(symbol) {
      var rec, rule,
        _this = this;

      rule = this[symbol];
      return rec = function(start) {
        var hash, m, result;

        hash = symbol + start;
        switch (memoState[hash]) {
          case ENTER:
            if (result = rule(start)) {
              memoState[hash] = EXTEND;
              memo[hash] = [result, _this.cursor];
              return rec(start);
            } else {
              memoState[hash] = DONE;
              memo[hash] = [void 0, 0];
              return void 0;
            }
            break;
          case REDUCE:
            m = memo[hash];
            _this.cursor = m[1];
            return m[0];
          case EXTEND:
            memoState[hash] = REDUCE;
            if (result = rule(start)) {
              memo[hash] = [result, _this.cursor];
              memoState[hash] = EXTEND;
              return rec(start);
            } else {
              memoState[hash] = DONE;
              m = memo[hash];
              _this.cursor = m[1];
              return m[0];
            }
            break;
          case DONE:
            m = memo[hash];
            _this.cursor = m[1];
            return m[0];
        }
      };
    };

    BaseParser.prototype.getmemo = function(symbol) {
      var _this = this;

      return function(position) {
        return memo[symbol + position][0];
      };
    };

    BaseParser.prototype.reduce = function(symbol) {
      return function(start) {
        var state;

        state = memoState[symbol + start];
        return state === REDUCE;
      };
    };

    BaseParser.prototype.enter = function(symbol) {
      return function(start) {
        var state;

        state = memoState[symbol + start];
        return state === ENTER;
      };
    };

    return BaseParser;

  })();

  Parser = (function(_super) {
    __extends(Parser, _super);

    function Parser() {
      this.A = __bind(this.A, this);      this.Root = this.A = this.recursive('A', this.A);
    }

    Parser.prototype.A = function(start) {
      return this.A(start) && this.char('x')(this.cursor) && this.getmemo('A')(start) + 'x' || this.enter('A')(start) && this.char('a')(start);
    };

    return Parser;

  })(BaseParser);

  Parser = (function(_super) {
    __extends(Parser, _super);

    function Parser() {
      this.B = __bind(this.B, this);
      this.A = __bind(this.A, this);      this.A = this.recursive('A');
      this.Root = this.A;
    }

    Parser.prototype.A = function(start) {
      var b;

      return (b = this.B(start)) && this.char('x')(this.cursor) && b + 'x' || this.enter('A')(start) && this.char('a')(start);
    };

    Parser.prototype.B = function(start) {
      return this.reduce('A')(start) && this.A(start) || this.enter('A')(start) && this.char('b')(start);
    };

    return Parser;

  })(BaseParser);

  exports.parse = function(text) {
    return new Parser().parse(text);
  };

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
