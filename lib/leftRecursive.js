// Generated by CoffeeScript 1.6.2
(function() {
  var baseRules, cursor, memo, memoCallpath, rec, recursive, recursiveRules, rules, symbolToParentsMap, text, textLength, _memo, _memo2,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  symbolToParentsMap = {};

  rules = void 0;

  baseRules = {};

  recursiveRules = {};

  memoCallpath = {};

  _memo = {};

  text = '';

  textLength = 0;

  cursor = 0;

  _memo = {};

  _memo2 = {};

  exports.setRules = function(rules1) {
    return rules = rules1;
  };

  exports.clear = function() {
    baseRules = {};
    return symbolToParentsMap = {};
  };

  exports.parse = function(data, root) {
    text = data;
    textLength = text.length;
    cursor = 0;
    _memo = {};
    return root(0);
  };

  exports.andp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      cursor = start;
      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (!(result = exp(cursor))) {
          return;
        }
      }
      return result;
    };
  };

  exports.orp = function(exps) {
    return function(start) {
      var exp, result, _i, _len;

      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (result = exp(start)) {
          return result;
        }
      }
    };
  };

  exports.notp = function(exp) {
    return function(start) {
      if (exp(start)) {

      } else {
        return true;
      }
    };
  };

  exports.char = function(c) {
    return function(start) {
      if (text[start] === c) {
        cursor = start + 1;
        return c;
      }
    };
  };

  exports.literal = function(string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  exports.spaces = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  exports.spaces1 = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return cursor = cursor;
      return len;
    }
  };

  exports.wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    return function(start) {
      var result;

      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  exports.setRecursiveSymbols = function() {
    var rules1, symbol, symbols, _i, _len, _results;

    rules1 = arguments[0], symbols = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    rules = rules1;
    _results = [];
    for (_i = 0, _len = symbols.length; _i < _len; _i++) {
      symbol = symbols[_i];
      baseRules[symbol] = rules[symbol];
      _results.push(rules[symbol] = recursiveRules[symbol] = recursive(symbol));
    }
    return _results;
  };

  exports.recursive = recursive = function(symbol) {
    var baserule;

    baserule = baseRules[symbol];
    return function(start) {
      var callpath, hash, m, result, _ref, _ref1, _ref2;

      hash = symbol + start;
      callpath = (_ref = memoCallpath[start]) != null ? _ref : memoCallpath[start] = [symbol];
      m = (_ref1 = _memo[hash]) != null ? _ref1 : _memo[hash] = [void 0, -1];
      if (m[1] >= 0) {
        cursor = m[1];
        return m[0];
      }
      m[0] = baserule(start);
      m[1] = cursor;
      while (1) {
        symbol = callpath.pop();
        hash = symbol + start;
        m = (_ref2 = _memo[hash]) != null ? _ref2 : _memo[hash] = [void 0, -1];
        baserule = baseRules[symbol];
        result = baserule(start);
        if (__indexOf.call(callpath, symbol) >= 0 && !result) {
          cursor = m[1];
          return m[0];
        }
        if (m[0] && !result) {
          cursor = m[1];
          return m[0];
        }
        if (result === m[0] && cursor === m[1]) {
          return result;
        } else {
          m[0] = result;
          m[1] = cursor;
        }
      }
    };
  };

  exports.memo = memo = function(symbol) {
    return function(start) {
      var hash, m;

      hash = symbol + start;
      m = _memo[hash];
      if (m) {
        return m[0];
      }
    };
  };

  exports.rec = rec = function(symbol) {
    return function(start) {
      var callpath, hash, m, _ref;

      hash = symbol + start;
      callpath = (_ref = memoCallpath[start]) != null ? _ref : memoCallpath[start] = [];
      callpath.push(symbol);
      m = _memo[hash];
      if (m) {
        return m[0];
      }
    };
  };

  exports.cur = function() {
    return cursor;
  };

}).call(this);

/*
//@ sourceMappingURL=leftRecursive.map
*/
