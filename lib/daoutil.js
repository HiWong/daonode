// Generated by CoffeeScript 1.6.2
(function() {
  var ADD, AND, BITAND, BITNOT, BITOR, DIV, ExpressionError, LSFHIFT, MOD, MUL, NOT, OR, RSHIFT, SUB, StateMachine, Trail, TypeError, Var, binaryOperatorMap, hasOwnProperty, index, newToken, nextToken, pair, readToken, suffixOperatorMap, tokenInfoList, tokenNames, unaryOperatorMap, util, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

  _ref = require("./solve"), Trail = _ref.Trail, Var = _ref.Var, ExpressionError = _ref.ExpressionError, TypeError = _ref.TypeError;

  _ref1 = util = require("./util"), ADD = _ref1.ADD, SUB = _ref1.SUB, MUL = _ref1.MUL, DIV = _ref1.DIV, MOD = _ref1.MOD, LSFHIFT = _ref1.LSFHIFT, RSHIFT = _ref1.RSHIFT, AND = _ref1.AND, OR = _ref1.OR, NOT = _ref1.NOT, BITAND = _ref1.BITAND, BITOR = _ref1.BITOR, BITNOT = _ref1.BITNOT;

  index = 0;

  exports.tokenInfoList = tokenInfoList = [];

  newToken = function(text) {
    var i, name, names, symbol, _i, _len;

    i = text.indexOf(': ');
    names = text.slice(0, i).split(' ');
    symbol = text.slice(i + 2);
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      tokenNames[name] = global[name] = index;
    }
    tokenInfoList.push([symbol, index]);
    return index++;
  };

  exports.tokenNames = tokenNames = {};

  _ref2 = ['TKNLINECOMMENTBEGIN TKNSHARP: #', 'TKNSHARP2: ##', 'TKNSHARP3: ###', "TKNQUOTE: '", "TKNQUOTE2: ''", "TKNQUOTE3: '''", 'TKNDOUBLEQUOTE1: "', 'TKNDOUBLEQUOTE2: ""', 'TKNDOUBLEQUOTE3: """', 'TKNBACKQUOTE: `', 'TKNBACKQUOTE2: ``', 'TKNBACKQUOTE3: ```', 'TKNLPAREN: (', 'TKNRPAREN: )', 'TKNLBRACKET: [', 'TKNRBRACKET: ]', 'TKNLBRACE: {', 'TKNRBRACE: }', 'TKNCOLON: :', 'TKNCOLON2: ::', 'TKNCOLON3: :::', 'TKNSEMICOLON: ;', 'TKNDOT: .', 'TKNDOT2: ..', 'TKNDOT3: ...', 'TKNEQ: =', 'TKNEQ2: ==', 'TKNEQ3: ===', 'TKNGT: >', 'TKNGT2 TKNRSHIFT: >>', 'TKNGT3: >>>', 'TKNLT: <', 'TKNLT2 TKNLSHIFT: <<', 'TKNLT3: <<<', 'TKNNE: !=', 'TKNLTGT: <>', 'TKNGE: >=', 'TKNLE: <=', 'TKNSUBARROW: ->', 'TKNEQARROW: =>', 'TKNCOLONEQ: :=', 'TKNCOLONSUB: :-', 'TKNPOSITIVE TKNADD: +', 'TKNINC TKNADD2: ++', 'TKNADD3: +++', 'TKNNEG TKNSUB: -', 'TKNDEC TKNSUB2: --', 'TKNSUB3: ---', 'TKNMUL: *', 'TKNMUL2: **', 'TKNMUL3: ***', 'TKNDIV: /', 'TKNDIV2: //', 'TKNDIV3: ///', 'TKNMOD: %', 'TKNMOD2: %%', 'TKNMOD3: %%%', 'TKNVLINE TKNBITOR: |', 'TKNVLINE2 TKNOR: ||', 'TKNVLINE3: |||', 'TKNBITNOT: ~', 'TKNBITXOR: ^', 'TKNNOT: !', 'TKNBITAND AMPERSAND1: &', 'TKNAND AMPERSAND2: &&', 'AMPERSAND3: &&&', 'TKNRETURN: return', 'TKNPASS: pass', 'TKNCONTINUE: continue', 'TKNBREAK: break', 'TKNIF: if', 'TKNELSE: else', 'TKNELSEIF: elseif', 'TKNELIF: elif', 'TKNSWITCH: switch', 'TKNDEFAULT: default', 'TKNTRY: try', 'TKNCATCH: catch', 'TKNEXCEPT: except', 'TKNFINALLY: finally', 'TKNTHROW: throw', 'TKNRAISE: raise', 'TKNERROR: error', 'TKNWHILE: while', 'TKNUNTIL: until', 'TKNLOOP: loop', 'TKNWHEN: when', 'TKNON: on', 'TKNLET: let', 'TKNWHERE: where', 'TKNCASE: case', 'TKNVAR: var', 'TKNWITH: with', 'TKNDELETE: delete', 'TKNDEL: del', 'TKNFUNCTION: function', 'TKNFUN: fun', 'TKNDEF: def', 'TKNCLASS: class', 'TKNMACRO: macro', 'TKNIN: in', 'TKNIS: is', 'TKNIS: unify', 'TKNINSTANCEOF: instanceof', 'TKNTYPEOF: typeof', 'TKNDOF: of', 'TKNAND: and', 'TKNNOT: not', 'TKNOR: or', 'TKNVOID: void', 'TKNNEW: new', 'TKNDEBUGGER: debugger', 'TKNTHIS: this'];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    x = _ref2[_i];
    newToken(x);
  }

  exports.binaryOperator = function(solver, cont) {
    var c, c1, length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        solver.parsercursor = pos + 1;
        return cont(util.ADD);
      case '-':
        solver.parsercursor = pos + 1;
        return cont(util.SUB);
      case '*':
        solver.parsercursor = pos + 1;
        return cont(util.MUL);
      case '/':
        solver.parsercursor = pos + 1;
        return cont(util.DIV);
      case '%':
        solver.parsercursor = pos + 1;
        return cont(util.MOD);
      case '=':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.EQ);
        } else {
          return solver.failcont(pos);
        }
        break;
      case '!':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.NE);
        } else {
          return solver.failcont(pos);
        }
        break;
      case '>':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.GE);
        } else if (c1 === '>') {
          solver.parsercursor = pos + 2;
          return cont(util.RSHIFT);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.gt);
        }
        break;
      case '<':
        c1 = text[pos + 1];
        if (c1 === '=') {
          solver.parsercursor = pos + 2;
          return cont(util.le);
        } else if (c1 === '<') {
          solver.parsercursor = pos + 2;
          return cont(util.LSHIFT);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.lt);
        }
        break;
      default:
        return solver.failcont(pos);
    }
  };

  exports.unaryOperator = function(solver, cont) {
    var c, c1, length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.INC);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.pos);
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.DEC);
        } else {
          solver.parsercursor = pos + 1;
          return cont(util.NEG);
        }
        break;
      case '!':
        solver.parsercursor = pos + 1;
        return cont(util.NOT);
      case '~':
        solver.parsercursor = pos + 1;
        return cont(util.BITNOT);
      default:
        return solver.failcont(pos);
    }
  };

  exports.suffixOperator = function(solver, cont) {
    var c, c1, length, pos, text;

    text = solver.parserdata;
    pos = solver.parsercursor;
    length = text.length;
    if (pos >= length) {
      return solver.failcont(pos);
    }
    c = text[pos];
    switch (c) {
      case '+':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.INC);
        } else {
          return solver.failcont(pos);
        }
        break;
      case '-':
        c1 = text[pos + 1];
        if (c1 === '+') {
          solver.parsercursor = pos + 2;
          return cont(util.DEC);
        } else {
          return solver.failcont(pos);
        }
        break;
      default:
        return solver.failcont(pos);
    }
  };

  hasOwnProperty = Object.hasOwnProperty;

  exports.StateMachine = StateMachine = (function() {
    function StateMachine(items) {
      var item, _j, _len1;

      if (items == null) {
        items = [];
      }
      this.index = 1;
      this.stateMap = {};
      this.stateMap[0] = {};
      this.tagMap = {};
      for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
        item = items[_j];
        this.add(item[0], item[1]);
      }
    }

    StateMachine.prototype.add = function(word, tag) {
      var c, i, length, newState, s, state;

      length = word.length;
      state = 0;
      i = 0;
      while (i < length - 1) {
        c = word[i++];
        if (hasOwnProperty.call(this.stateMap[state], c)) {
          state = this.stateMap[state][c];
          if (state < 0) {
            state = -state;
          }
        } else {
          newState = this.index++;
          this.stateMap[state][c] = newState;
          this.stateMap[newState] = {};
          state = newState;
        }
      }
      c = word[i];
      if (hasOwnProperty.call(this.stateMap[state], c)) {
        s = this.stateMap[state][c];
        if (s > 0) {
          this.stateMap[state][c] = -s;
          return this.tagMap[s] = tag;
        }
      } else {
        newState = this.index++;
        this.stateMap[state][c] = -newState;
        this.stateMap[newState] = {};
        return this.tagMap[newState] = tag;
      }
    };

    StateMachine.prototype.match = function(text, i) {
      var cursor, length, state, succeedState;

      state = 0;
      length = text.length;
      while (i < length) {
        state = this.stateMap[state][text[i++]];
        if (state === void 0) {
          i--;
          break;
        } else if (state < 0) {
          state = -state;
          succeedState = state;
          cursor = i;
        }
      }
      if (succeedState) {
        return [this.tagMap[succeedState], cursor];
      } else {
        return [null, i];
      }
    };

    return StateMachine;

  })();

  exports.readToken = readToken = function(solver) {
    var cursor, result, start, text, tokenStateMachine, value;

    tokenStateMachine = solver.tokenStateMachine;
    text = solver.parserdata;
    start = solver.parsercursor;
    result = tokenStateMachine.match(text, start);
    value = result[0];
    cursor = result[1];
    if (value) {
      solver.parsercursor = cursor;
      return value;
    } else {
      solver.parsercursor = start;
      return null;
    }
  };

  binaryOperatorMap = {};

  _ref3 = [[TKNADD, ADD], [TKNSUB, SUB], [TKNMUL, MUL], [TKNDIV, DIV], [TKNMOD, MOD], [TKNAND, AND], [TKNOR, OR], [TKNBITAND, BITAND], [TKNBITOR, BITOR], [TKNLSHIFT, LSHIFT], [TKNRSHIFT, RSHIFT], [TKNEQ, EQ], [TKNNE, NE], [TKNLT, LT], [TKNLE, LE], [TKNGE, GE], [TKNGT, GT]];
  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
    pair = _ref3[_j];
    binaryOperatorMap[pair[0]] = pair[1];
  }

  exports.binaryOperator = function(solver, cont) {
    var op, start, token;

    start = solver.parsercursor;
    token = readToken(solver);
    op = binaryOperatorMap[token];
    if (op !== void 0) {
      return cont(op);
    } else {
      solver.parsercursor = start;
      return solver.failcont(null);
    }
  };

  unaryOperatorMap = {};

  _ref4 = [[TKNNOT, NOT], [TKNBITNOT, BITNOT], [TKNNEG, NEG], [TKNPOSITIVE, POSITIVE], [TKNINC, INC], [TKNDEC, DEC]];
  for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
    pair = _ref4[_k];
    unaryOperatorMap[pair[0]] = pair[1];
  }

  exports.unaryOperator = function(solver, cont) {
    var op, start, token;

    start = solver.parsercursor;
    token = readToken(solver);
    op = unaryOperatorMap[token];
    if (op !== void 0) {
      return cont(op);
    } else {
      solver.parsercursor = start;
      return solver.failcont(null);
    }
  };

  suffixOperatorMap = {};

  _ref5 = [[TKNINC, INC], [TKNDEC, SUFFIXDEC]];
  for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
    pair = _ref5[_l];
    suffixOperatorMap[pair[0]] = pair[1];
  }

  exports.suffixOperator = function(solver, cont) {
    var op, start, token;

    start = solver.parsercursor;
    token = readToken(solver);
    op = suffixOperatorMap[token];
    if (op !== void 0) {
      return cont(op);
    } else {
      solver.parsercursor = start;
      return solver.failcont(null);
    }
  };

  nextToken = function(solver, cont) {
    var c, c2, cursor, result, result2, text;

    text = solver.parserdata;
    cursor = solver.parsercursor;
    c = text[cursor];
    switch (c) {
      case void 0:
        return [EOI, cursor];
      case '0':
        c2 = cursor[1];
        switch (c2) {
          case 'x':
          case 'X':
          case 'h':
          case 'H':
            return hexadigit(text, cursor);
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
            return octal(text, cursor);
        }
        break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        return number(text, cursor);
      case '+':
      case '-':
        c2 = cursor[1];
        switch (c) {
          case '0':
            c2 = cursor[1];
            switch (c2) {
              case 'x':
              case 'X':
              case 'h':
              case 'H':
                return hexadigit(text, cursor);
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                return octal(text, cursor);
            }
            break;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            return number(text, cursor);
        }
        break;
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
        result = keyword(text, cursor);
        if (result[0] === void 0) {
          return result2 = identifier(text, result[1]);
        } else {
          c2 = text[result[1]];
          if (isIdentifierCharacter(c2)) {
            return result2 = identifier(text, result[1]);
          }
        }
        break;
      case '_':
      case '$':
      case 'z':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
        return identifier(text, cursor);
      case ' ':
      case '\t':
        return whitespace(text, cursor);
      case '"':
      case "'":
        result = quoteString(text, cursor, c);
        if (result[0] === void 0) {
          return [QUOTE, c];
        }
        break;
      case '#':
        return result = comment(text, cursor);
      case '\r':
      case '\n':
        return newlineIndent(text, cursor, solver);
      default:
        return symbolToken(text, cursor);
    }
  };

}).call(this);

/*
//@ sourceMappingURL=daoutil.map
*/
